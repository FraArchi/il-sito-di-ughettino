# üêæ Progetto: La Cuccia di Ugo

**Data di esportazione:** mer 13 ago 2025, 12:00:14, CEST

## ÔøΩ Statistiche del progetto

- **File totali:** 106
- **Righe di codice totali:** 26,418
- **File pi√π grande:** `../backend/package-lock.json` (419.8 KB)

### üìÅ Distribuzione per tipo di file

- **.conf**: 1 file
- **.example**: 3 file
- **.html**: 3 file
- **.js**: 45 file
- **.json**: 7 file
- **.md**: 7 file
- **.prisma**: 1 file
- **.py**: 5 file
- **.sh**: 6 file
- **.sql**: 3 file
- **.txt**: 1 file
- **.xml**: 2 file
- **.yml**: 9 file
- **no_extension**: 13 file

---

## üóÇÔ∏è Struttura del progetto

| üìÅ Percorso | üìè Dimensione | üîß Tipo |
|-------------|---------------|----------|
| `../.env.example` | 286 B | .example |
| `../.github/FUNDING.yml` | 979 B | .yml |
| `../.github/dependabot.yml` | 286 B | .yml |
| `../.github/workflows-disabled/ci.yml` | 2.5 KB | .yml |
| `../.github/workflows-disabled/deploy.yml` | 2.3 KB | .yml |
| `../.github/workflows/update-sitemap-lastmod.yml` | 1.0 KB | .yml |
| `../.gitignore` | 855 B | text |
| `../LICENSE` | 11.1 KB | text |
| `../Makefile` | 417 B | text |
| `../README.md` | 2.6 KB | .md |
| `../RENDER_DEPLOY.md` | 0 B | .md |
| `../backend/.dockerignore` | 99 B | text |
| `../backend/.env.example` | 1.9 KB | .example |
| `../backend/.gitignore` | 463 B | text |
| `../backend/Dockerfile` | 1.4 KB | text |
| `../backend/SETUP_COMPLETE.md` | 3.6 KB | .md |
| `../backend/Supabase-Backend-app/.env.example` | 2.2 KB | .example |
| `../backend/Supabase-Backend-app/.github/workflows/deploy.yml` | 722 B | .yml |
| `../backend/Supabase-Backend-app/README.md` | 2.5 KB | .md |
| `../backend/Supabase-Backend-app/backend-2/README.md` | 1.5 KB | .md |
| `../backend/Supabase-Backend-app/backend-2/package.json` | 590 B | .json |
| `../backend/Supabase-Backend-app/backend-2/src/app.js` | 578 B | .js |
| `../backend/Supabase-Backend-app/backend-2/src/config/env.js` | 281 B | .js |
| `../backend/Supabase-Backend-app/backend-2/src/controllers/index.js` | 842 B | .js |
| `../backend/Supabase-Backend-app/backend-2/src/middlewares/auth.js` | 602 B | .js |
| `../backend/Supabase-Backend-app/backend-2/src/models/index.js` | 560 B | .js |
| `../backend/Supabase-Backend-app/backend-2/src/routes/index.js` | 325 B | .js |
| `../backend/Supabase-Backend-app/backend-2/src/services/index.js` | 458 B | .js |
| `../backend/Supabase-Backend-app/backend-2/src/utils/logger.js` | 623 B | .js |
| `../backend/Supabase-Backend-app/supabase/init.sql` | 728 B | .sql |
| `../backend/backend/docker/mediapipe/Dockerfile` | 0 B | text |
| `../backend/backend/docker/stable-diffusion/Dockerfile` | 0 B | text |
| `../backend/docker-compose.yml` | 2.8 KB | .yml |
| `../backend/docker/coqui-tts/Dockerfile` | 655 B | text |
| `../backend/docker/coqui-tts/app.py` | 3.5 KB | .py |
| `../backend/docker/grafana/provisioning/datasources/prometheus.yml` | 159 B | .yml |
| `../backend/docker/mediapipe/Dockerfile` | 672 B | text |
| `../backend/docker/mediapipe/app.py` | 6.0 KB | .py |
| `../backend/docker/nginx/nginx.conf` | 1.1 KB | .conf |
| `../backend/docker/nginx/ssl/README.md` | 190 B | .md |
| `../backend/docker/postgres/init.sql` | 1.5 KB | .sql |
| `../backend/docker/prometheus/prometheus.yml` | 665 B | .yml |
| `../backend/package-lock.json` | 419.8 KB | .json |
| `../backend/package.json` | 2.8 KB | .json |
| `../backend/prisma/schema.prisma` | 11.2 KB | .prisma |
| `../backend/public/index.html` | 767 B | .html |
| `../backend/public/test-ai.html` | 7.2 KB | .html |
| `../backend/scripts/backup.sh` | 598 B | .sh |
| `../backend/scripts/restore.sh` | 308 B | .sh |
| `../backend/src/app.js` | 6.2 KB | .js |
| `../backend/src/config/envLoader.js` | 1.0 KB | .js |
| `../backend/src/config/redis.js` | 2.9 KB | .js |
| `../backend/src/config/supabase.js` | 811 B | .js |
| `../backend/src/config/swagger.js` | 750 B | .js |
| `../backend/src/controllers/authController.js` | 7.0 KB | .js |
| `../backend/src/controllers/postController.js` | 9.6 KB | .js |
| `../backend/src/middleware/authMiddleware.js` | 6.3 KB | .js |
| `../backend/src/middleware/errorHandler.js` | 2.4 KB | .js |
| `../backend/src/routes/adminRoutes.js` | 1.6 KB | .js |
| `../backend/src/routes/aiRoutes.js` | 14.4 KB | .js |
| `../backend/src/routes/analyticsRoutes.js` | 1.4 KB | .js |
| `../backend/src/routes/authRoutes.js` | 10.6 KB | .js |
| `../backend/src/routes/commentRoutes.js` | 1.5 KB | .js |
| `../backend/src/routes/gamificationRoutes.js` | 1.4 KB | .js |
| `../backend/src/routes/notificationRoutes.js` | 1.1 KB | .js |
| `../backend/src/routes/photoBoothRoutes.js` | 1.9 KB | .js |
| `../backend/src/routes/postRoutes.js` | 13.0 KB | .js |
| `../backend/src/routes/publicIntegrationRoutes.js` | 4.3 KB | .js |
| `../backend/src/routes/quizRoutes.js` | 1.6 KB | .js |
| `../backend/src/routes/ugoAI.js` | 12.2 KB | .js |
| `../backend/src/routes/userRoutes.js` | 2.2 KB | .js |
| `../backend/src/server.js` | 2.8 KB | .js |
| `../backend/src/services/authService.js` | 12.0 KB | .js |
| `../backend/src/services/commentService.js` | 13.4 KB | .js |
| `../backend/src/services/conversationMemory.js` | 15.5 KB | .js |
| `../backend/src/services/emailService.js` | 17.6 KB | .js |
| `../backend/src/services/emotionEngine.js` | 16.7 KB | .js |
| `../backend/src/services/postService.js` | 17.7 KB | .js |
| `../backend/src/services/socketService.js` | 1.1 KB | .js |
| `../backend/src/services/ugoAICompanion.js` | 13.3 KB | .js |
| `../backend/src/services/ugoContextBuilder.js` | 18.2 KB | .js |
| `../backend/src/services/ugoPersonality.js` | 12.2 KB | .js |
| `../backend/src/utils/logger.js` | 2.5 KB | .js |
| `../backend/src/validators/authValidators.js` | 6.6 KB | .js |
| `../backend/src/validators/postValidators.js` | 7.7 KB | .js |
| `../backend/supabase/init.sql` | 2.5 KB | .sql |
| `../backend/test_contact_curl.sh` | 752 B | .sh |
| `../backend/test_newsletter_curl.sh` | 638 B | .sh |
| `../backend/test_upload_curl.sh` | 849 B | .sh |
| `../backend/tests/publicRoutes.test.js` | 1.1 KB | .js |
| `../backend/wait-for-it.sh` | 388 B | .sh |
| `../docs/.gitignore` | 32 B | text |
| `../docs/.nojekyll` | 0 B | text |
| `../docs/CNAME` | 16 B | text |
| `../docs/SUPABASE-SETUP.md` | 2.9 KB | .md |
| `../docs/check_index_links.py` | 2.0 KB | .py |
| `../docs/fix_css_paths.py` | 1.0 KB | .py |
| `../docs/fix_links_optimized.py` | 5.0 KB | .py |
| `../docs/index.html` | 16.4 KB | .html |
| `../docs/manifest.json` | 1.5 KB | .json |
| `../docs/package.json` | 469 B | .json |
| `../docs/robots.txt` | 70 B | .txt |
| `../docs/rss.xml` | 5.3 KB | .xml |
| `../docs/sitemap.xml` | 7.9 KB | .xml |
| `../package-lock.json` | 37.0 KB | .json |
| `../package.json` | 77 B | .json |

---

## üìÑ Contenuto dei file

*(Ordinati per percorso crescente)*

### üìÑ `../.env.example`

**üìè Dimensione:** 286 B | **üìù Righe:** 10

```example
# Frontend consumption (never commit real service key)
SUPABASE_URL="https://YOUR-PROJECT.supabase.co"
SUPABASE_ANON_KEY="YOUR_PUBLIC_ANON_KEY"

# Backend only (do not expose)
SUPABASE_SERVICE_ROLE_KEY="YOUR_SERVICE_ROLE_KEY"

# API Base
API_BASE_URL="http://localhost:3000/api/public"

```

---

### üìÑ `../.github/FUNDING.yml`

**üìè Dimensione:** 979 B | **üìù Righe:** 17

```yml
support by sharing the site to all pet and life lovers <3
# These are supported funding model platforms

github: # Replace with up to 4 GitHub Sponsors-enabled usernames e.g., [user1, user2]
patreon: # Replace with a single Patreon username
open_collective: # Replace with a single Open Collective username
ko_fi: # Replace with a single Ko-fi username
tidelift: # Replace with a single Tidelift platform-name/package-name e.g., npm/babel
community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry
liberapay: # Replace with a single Liberapay username
issuehunt: # Replace with a single IssueHunt username
lfx_crowdfunding: # Replace with a single LFX Crowdfunding project-name e.g., cloud-foundry
polar: # Replace with a single Polar username
buy_me_a_coffee: # Replace with a single Buy Me a Coffee username
thanks_dev: # Replace with a single thanks.dev username
custom: # Replace with up to 4 custom sponsorship URLs e.g., ['link1', 'link2']

```

---

### üìÑ `../.github/dependabot.yml`

**üìè Dimensione:** 286 B | **üìù Righe:** 14

```yml
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/backend"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 10
    commit-message:
      prefix: "deps"
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"

```

---

### üìÑ `../.github/workflows-disabled/ci.yml`

**üìè Dimensione:** 2.5 KB | **üìù Righe:** 82

```yml
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18, 20]
        python-version: ["3.11"]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
          cache-dependency-path: |
            backend/package-lock.json

      - name: Install backend deps
        working-directory: backend
        run: |
          if [ -f package.json ]; then npm ci; fi

      - name: Lint backend
        working-directory: backend
        run: |
          if [ -f package.json ]; then npm run lint || echo "Lint warnings"; fi

      - name: Test backend
        working-directory: backend
        env:
          NODE_ENV: test
          LOG_LEVEL: error
          # Provide dummy Supabase vars so any accidental import won't crash tests
          SUPABASE_URL: http://localhost:54321
          SUPABASE_ANON_KEY: test_anon_key
          SUPABASE_SERVICE_ROLE_KEY: test_service_role_key
          # Avoid any optional external logging or Sentry in CI
          SENTRY_DSN: ""
          LOG_HTTP_ENDPOINT: ""
          ALLOW_START_WITHOUT_DB: "true"
        run: |
          if [ -f package.json ]; then npm test; fi

      - name: npm audit (high)
        working-directory: backend
        run: |
          if [ -f package.json ]; then npm audit --audit-level=high || true; fi

      - name: Build backend Docker (smoke)
        working-directory: backend
        run: |
          docker build -t ugo-backend:test .

      - name: Setup Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install Python deps
        run: |
          if [ -f requirements.txt ]; then pip install -r requirements.txt; else echo "No Python deps"; fi

      - name: Python security audit (pip-audit or safety)
        run: |
          pip install --upgrade pip >/dev/null 2>&1 || true
          pip install pip-audit safety >/dev/null 2>&1 || true
          if [ -f requirements.txt ]; then pip-audit || safety check || true; else echo "No Python requirements"; fi

      - name: Pytest (if present)
        run: |
          if [ -f tests ] || [ -f pytest.ini ] || [ -f pyproject.toml ]; then pytest || echo "Pytests failed (continuing)"; else echo "No Python tests"; fi

```

---

### üìÑ `../.github/workflows-disabled/deploy.yml`

**üìè Dimensione:** 2.3 KB | **üìù Righe:** 71

```yml
name: Backend Deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
      SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: backend
        run: npm ci

      - name: Lint
        working-directory: backend
        run: |
          if [ -f package.json ]; then npm run lint || echo "Lint warnings"; fi

      - name: Run tests
        working-directory: backend
        run: |
          if [ -f package.json ]; then npm test || echo "Tests failed (continuing)"; fi

      - name: Supabase SQL Init
        if: env.SUPABASE_URL != ''
        env:
          SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
          SUPABASE_DB_USER: ${{ secrets.SUPABASE_DB_USER }}
          SUPABASE_DB_HOST: ${{ secrets.SUPABASE_DB_HOST }}
          SUPABASE_DB_PORT: ${{ secrets.SUPABASE_DB_PORT }}
          SUPABASE_DB_NAME: ${{ secrets.SUPABASE_DB_NAME }}
        run: |
          if [ -n "$SUPABASE_DB_HOST" ]; then
            echo "Running init.sql against database";
            sudo apt-get update && sudo apt-get install -y postgresql-client;
            psql "host=$SUPABASE_DB_HOST port=${SUPABASE_DB_PORT:-5432} dbname=$SUPABASE_DB_NAME user=$SUPABASE_DB_USER password=$SUPABASE_DB_PASSWORD sslmode=require" -f backend/supabase/init.sql;
          else
            echo "Skipping SQL init (DB host not set)";
          fi

      - name: Build Docker image
        working-directory: backend
        run: |
          echo "Building Docker image";
          docker build -t ugo-backend:latest .

      - name: (Optional) Push to Registry
        if: false
        run: echo "Add registry login & docker push here"

      - name: Deployment Placeholder
        run: |
          echo "Add deployment step (e.g., Render, Fly.io, Railway) with service API.";
          echo "Use secrets for API tokens.";

```

---

### üìÑ `../.github/workflows/update-sitemap-lastmod.yml`

**üìè Dimensione:** 1.0 KB | **üìù Righe:** 43

```yml
name: Update sitemap lastmod

on:
  push:
    branches: [ main ]
    paths:
      - 'docs/**'
      - '!docs/sitemap.xml'
  schedule:
    - cron: '15 3 * * *'  # giornaliero alle 03:15 UTC
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-lastmod:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Update <lastmod> in sitemap.xml
        run: node tools/update-sitemap-lastmod.mjs

      - name: Commit and push changes (if any)
        run: |
          if git diff --quiet docs/sitemap.xml; then
            echo "No changes to sitemap.xml"
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add docs/sitemap.xml
          git commit -m "chore: update sitemap lastmod [skip ci]"
          git push
```

---

### üìÑ `../.gitignore`

**üìè Dimensione:** 855 B | **üìù Righe:** 72

```text
# Root .gitignore (frontend + backend)

# Environment / secrets
.env
*.env
.env.*
backend/.env
backend/**/*.env
supabase/.env

# Node dependencies
node_modules/
**/node_modules/

# Logs & runtime
logs/
**/logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
/tmp/
.pids
*.pid
*.seed

# Coverage / build artifacts
coverage/
coverage-*
build/
dist/
.tmp/
.next/
.vercel/
serverless/
out/

# OS / Editor
.DS_Store
Thumbs.db
.vscode/
.idea/
*.swp
*.swo
*.orig

# Caches
.cache/
.parcel-cache/
.eslintcache
.stylelintcache

# Uploads (ignore raw uploads if not versioned)
backend/uploads/

# Prisma local databases
backend/prisma/*.db

# Docker overrides
**/docker-compose.override.yml

# Misc archives
*.tgz
*.tar
*.zip

# Lockfiles (optional keep) - comment out if you want them tracked
# pnpm-lock.yaml
# yarn.lock
# package-lock.json

```

---

### üìÑ `../LICENSE`

**üìè Dimensione:** 11.1 KB | **üìù Righe:** 202

```text
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

---

### üìÑ `../Makefile`

**üìè Dimensione:** 417 B | **üìù Righe:** 28

```text
# Makefile helpers

.PHONY: dev prod lint test audit audit-fix ci

dev:
	cd backend && npm run dev

prod:
	cd backend && npm run start:prod

lint:
	cd backend && npm run lint

test:
	cd backend && npm test || true

audit:
	cd backend && npm audit --audit-level=high || true

audit-fix:
	cd backend && npm audit fix || true

ci:
	@echo "Run CI locally:"
	@echo "- make lint"
	@echo "- make test"
	@echo "- make audit"

```

---

### üìÑ `../README.md`

**üìè Dimensione:** 2.6 KB | **üìù Righe:** 127

```md
# La Cuccia di Ugo üêæ - Il cane pi√π buono del mondo

![La Cuccia di Ugo - Official Website]

**Visita il sito ufficiale:** [https://lacucciadiugo.it](https://lacucciadiugo.it)

*Aggiornato: 13 agosto 2025 - Sito ottimizzato per Google con schema.org e favicon!* üéâ

---

## üì¢ Descrizione

Questo progetto √® il sito web personale di *Ughettino*, una pagina statica semplice, elegante e funzionale.

---

## üöÄ Caratteristiche principali

- Sito statico leggero, hosting GitHub Pages
- Backend Node/Express sicuro per newsletter, contatti, upload
- RLS Supabase e bucket storage `uploads`
- UI moderna e responsive con sezioni: Hero, Chi √® Ugo, Avventure, Community, Divertiti (Quiz/Photo Booth)

---

## üóÑ Backend & API Public

Rotte pubbliche:
- POST `/api/public/newsletter`
- POST `/api/public/contact`
- POST `/api/public/upload`

Avvio locale
````
cd backend
cp .env.example .env   # inserisci le chiavi reali Supabase
npm ci
ALLOW_START_WITHOUT_DB=true npm start
````

Test rapido API
````
./backend/test_newsletter_curl.sh
./backend/test_contact_curl.sh
./backend/test_upload_curl.sh
````

---

## üõ° Supabase & Sicurezza

Env principali (`backend/.env`):
````
SUPABASE_URL=
SUPABASE_ANON_KEY=
SUPABASE_SERVICE_ROLE_KEY=
````

Tabelle & RLS: `backend/supabase/init.sql`

Storage: bucket `uploads` (public = true)

---

## üîí Segreti
- `.env` non tracciati; usare `.env.example`
- Rigenera chiavi accidentalmente committate e ripulisci la history

---

## üß∞ CI/CD
- Workflow CI: `.github/workflows/ci.yml`
  - working-directory: `backend`
  - `npm ci` e poi `npm test`
  - env test ridotti: `NODE_ENV=test`, `LOG_LEVEL=error`, dummy `SUPABASE_*`, `SENTRY_DSN=""`, `ALLOW_START_WITHOUT_DB=true`
  - Lint, audit high, Docker build smoke
- Deploy: `.github/workflows/deploy.yml`

Esecuzione locale test backend
````
cd backend
npm ci
npm run lint
npm test
````

---

## üîç Dipendenze & sicurezza
- Audit Node: `make audit` o `npm audit --audit-level=high`
- Dependabot abilitato

---

## üß≠ Monitoraggio
- Sentry opzionale (`SENTRY_DSN`)
- Prometheus `/metrics`
- Logging JSON (Winston)

---

## ‚ö° Performance & Caching
- Gzip lato backend
- Immagini ottimizzate e lazy loading

---

## üîé SEO & GDPR
- `docs/sitemap.xml`, `docs/robots.txt`
- Cookie banner con Consent Mode GA

---

## üß™ Test automatizzati
- Backend: `make test` (usa `npm test`), test in `backend/tests`
- Script curl: `backend/test_*.sh`
- CI esegue lint + test su push/PR

---

## üë©‚Äçüíª Developer Experience
- Makefile: `make dev`, `make prod`, `make lint`, `make test`, `make audit`, `make audit-fix`
- Avvio rapido: `cp backend/.env.example backend/.env && (cd backend && npm ci && npm run dev)`




```

---

### üìÑ `../RENDER_DEPLOY.md`

**üìè Dimensione:** 0 B | **üìù Righe:** 1

```md

```

---

### üìÑ `../backend/.dockerignore`

**üìè Dimensione:** 99 B | **üìù Righe:** 11

```text
node_modules
npm-debug.log
Dockerfile*
.dockerignore
.git
.gitignore
.vscode
.env
.env.local
*.log

```

---

### üìÑ `../backend/.env.example`

**üìè Dimensione:** 1.9 KB | **üìù Righe:** 81

```example
# Database
DATABASE_URL="postgresql://username:password@localhost:5432/ugo_db"
REDIS_URL="redis://localhost:6379"

# JWT
JWT_SECRET="change-me"
JWT_REFRESH_SECRET="change-me"
JWT_EXPIRE="15m"
JWT_REFRESH_EXPIRE="7d"

# AWS S3
AWS_ACCESS_KEY_ID="your-access-key-id"
AWS_SECRET_ACCESS_KEY="your-secret-access-key"
AWS_BUCKET_NAME="ugo-site-uploads"
AWS_REGION="eu-west-1"

# Cloudinary (Alternative to AWS S3)
CLOUDINARY_CLOUD_NAME="your-cloud-name"
CLOUDINARY_API_KEY="your-api-key"
CLOUDINARY_API_SECRET="your-api-secret"

# Email Configuration (SendGrid)
SENDGRID_API_KEY="your-sendgrid-api-key"
FROM_EMAIL="noreply@example.com"
SUPPORT_EMAIL="support@example.com"

# OAuth
GOOGLE_CLIENT_ID="your-google-client-id"
GOOGLE_CLIENT_SECRET="your-google-client-secret"
FACEBOOK_APP_ID="your-facebook-app-id"
FACEBOOK_APP_SECRET="your-facebook-app-secret"

# Server Configuration
NODE_ENV="development"
PORT=3000
HOST="localhost"
CORS_ORIGIN="http://localhost:3000"
SESSION_SECRET="change-me"

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100

# Supabase
SUPABASE_URL="https://YOUR-PROJECT.supabase.co"
SUPABASE_ANON_KEY="YOUR_PUBLIC_ANON_KEY"
SUPABASE_SERVICE_ROLE_KEY="YOUR_SERVICE_ROLE_KEY"

# File Upload
MAX_FILE_SIZE=5242880
ALLOWED_FILE_TYPES="image/jpeg,image/png,image/gif,image/webp"

# Monitoring & Analytics
SENTRY_DSN=""
ANALYTICS_API_KEY=""
LOG_HTTP_ENDPOINT=""  # optional: send JSON logs to external endpoint

# Backups
S3_BUCKET=""          # optional: for backup uploads
RETENTION_DAYS=7       # local retention

# Two-Factor Authentication
APP_NAME="Il Mondo di Ugo"
ISSUER_NAME="ilmondidiugo.com"

# Background Jobs
QUEUE_REDIS_URL="redis://localhost:6379/1"

# Health Check
HEALTH_CHECK_PATH="/health"

# Admin Settings
ADMIN_EMAIL="admin@example.com"
ADMIN_USERNAME="admin"

# Feature Flags
ENABLE_REGISTRATION=true
ENABLE_SOCIAL_LOGIN=true
ENABLE_2FA=false
ENABLE_EMAIL_VERIFICATION=true

```

---

### üìÑ `../backend/.gitignore`

**üìè Dimensione:** 463 B | **üìù Righe:** 49

```text
# Dependencies
node_modules/

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
logs/
*.log

# Runtime data
pids
*.pid
*.seed

# Environment variables
.env
.env.local
.env.*.local

# Build output
build/
dist/
.tmp/
coverage/

# IDE / Editor
.vscode/
.idea/
*.swp
.DS_Store

# Misc
*.tgz
.cache/
.vercel/
.next/
serverless/

# Docker artifacts
**/docker-compose.override.yml

# Prisma
prisma/*.db

# Uploads (if ephemeral / generated)
uploads/

```

---

### üìÑ `../backend/Dockerfile`

**üìè Dimensione:** 1.4 KB | **üìù Righe:** 51

```text
# Stage di build (installa tutte le dipendenze e genera Prisma client)
FROM node:18-slim AS builder
WORKDIR /app

# Copia package-lock per npm ci (pi√π riproducibile)
COPY package*.json ./

# Installa tutte le dipendenze (dev + prod)
RUN npm ci

# Copia il sorgente e prisma schema
COPY prisma ./prisma
COPY src ./src
COPY .env* ./

# Genera Prisma client (non richiede DB)
RUN npx prisma generate --schema=./prisma/schema.prisma

# Stage finale (runtime snello)
FROM node:18-slim AS runtime
WORKDIR /app
ENV NODE_ENV=production

# Installo strumenti di utilit√† (bash, curl) necessari per wait-script e healthcheck
RUN apt-get update \
  && apt-get install -y --no-install-recommends bash curl ca-certificates netcat \
  && rm -rf /var/lib/apt/lists/*

# Copio solo quello che serve dal builder (node_modules + prisma client + sorgente)
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/src ./src
COPY --from=builder /app/prisma ./prisma
COPY --from=builder /app/package*.json ./

# Copia helper
COPY wait-for-it.sh /wait-for-it.sh
RUN chmod +x /wait-for-it.sh

# Cartelle runtime
RUN mkdir -p uploads logs

# Espongo porta
EXPOSE 3000

# Healthcheck: richiede curl (installato sopra)
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# Avvio: aspetta postgres e poi parte il server
CMD ["bash", "/wait-for-it.sh", "postgres:5432", "--", "node", "src/server.js"]

```

---

### üìÑ `../backend/SETUP_COMPLETE.md`

**üìè Dimensione:** 3.6 KB | **üìù Righe:** 128

```md
# UGO AI - Sistema Docker Completo üöÄ

## Setup Completato ‚úÖ

Il sistema UGO AI √® ora completamente configurato e operativo con tutti i servizi Docker.

### Servizi Attivi

| Servizio | Porta | URL | Stato |
|----------|-------|-----|--------|
| **Nginx (Reverse Proxy)** | 80, 443 | http://localhost | ‚úÖ Attivo |
| **Backend Node.js** | 3000 | http://localhost:3000 | ‚ö†Ô∏è In avvio |
| **PostgreSQL Database** | 5432 | localhost:5432 | ‚úÖ Attivo |
| **Redis Cache** | 6379 | localhost:6379 | ‚úÖ Attivo |
| **Ollama AI (LLM)** | 11434 | http://localhost:11434 | ‚ö†Ô∏è In avvio |
| **Stable Diffusion** | 7860 | http://localhost:7860 | ‚ö° Buildando |
| **Coqui TTS** | 5002 | http://localhost:5002 | ‚úÖ Attivo |
| **MediaPipe** | 5003 | http://localhost:5003 | ‚úÖ Attivo |
| **Prometheus** | 9090 | http://localhost:9090 | ‚úÖ Attivo |
| **Grafana** | 3001 | http://localhost:3001 | ‚úÖ Attivo |

### Test dei Servizi

````bash
# Testa MediaPipe (Riconoscimento facciale/mani)
curl http://localhost:5003/health

# Testa TTS (Sintesi vocale)
curl http://localhost:5002/health

# Accedi a Grafana (admin/admin)
http://localhost:3001

# Accedi a Prometheus
http://localhost:9090
````

### Struttura Creata

````
backend/
‚îú‚îÄ‚îÄ docker/
‚îÇ   ‚îú‚îÄ‚îÄ stable-diffusion/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app.py
‚îÇ   ‚îú‚îÄ‚îÄ mediapipe/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app.py
‚îÇ   ‚îú‚îÄ‚îÄ coqui-tts/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app.py
‚îÇ   ‚îú‚îÄ‚îÄ nginx/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ nginx.conf
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ssl/
‚îÇ   ‚îú‚îÄ‚îÄ postgres/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ init.sql
‚îÇ   ‚îú‚îÄ‚îÄ prometheus/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ prometheus.yml
‚îÇ   ‚îî‚îÄ‚îÄ grafana/
‚îÇ       ‚îî‚îÄ‚îÄ provisioning/
‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îî‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ uploads/
‚îú‚îÄ‚îÄ logs/
‚îú‚îÄ‚îÄ Dockerfile
‚îî‚îÄ‚îÄ docker-compose.yml
````

### API Disponibili

#### MediaPipe Service (Port 5003)
- `GET /health` - Status del servizio
- `POST /detect_faces` - Rilevamento volti
- `POST /detect_hands` - Rilevamento mani
- `POST /detect_pose` - Rilevamento postura

#### TTS Service (Port 5002)
- `GET /health` - Status del servizio
- `POST /synthesize` - Sintesi vocale
- `GET /voices` - Lista delle voci disponibili

#### Stable Diffusion (Port 7860)
- `GET /health` - Status del servizio
- `POST /generate` - Generazione immagini

### Comandi Utili

````bash
# Visualizza status di tutti i container
docker compose ps

# Visualizza i logs di un servizio
docker compose logs [nome-servizio]

# Ferma tutti i servizi
docker compose down

# Riavvia tutti i servizi
docker compose up -d

# Ribuilda un servizio specifico
docker compose build [nome-servizio]
````

### Note Importanti

1. **Primo Avvio**: Ollama e il backend potrebbero richiedere qualche minuto per scaricare i modelli
2. **GPU**: Stable Diffusion funziona su CPU (pi√π lento) - per GPU serve driver NVIDIA
3. **Modelli AI**: I modelli vengono scaricati automaticamente al primo utilizzo
4. **Persistenza**: Tutti i dati sono salvati in volumi Docker persistenti

### Accesso Web

- **Dashboard principale**: http://localhost
- **Grafana**: http://localhost:3001 (admin/admin)
- **Prometheus**: http://localhost:9090

## Errori Risolti ‚úÖ

- ‚ùå Cartelle Docker mancanti ‚Üí ‚úÖ Create tutte le directory necessarie
- ‚ùå Dockerfile mancanti ‚Üí ‚úÖ Creati tutti i Dockerfile
- ‚ùå Script Python mancanti ‚Üí ‚úÖ Creati app.py per tutti i servizi
- ‚ùå Configurazioni mancanti ‚Üí ‚úÖ Nginx, Prometheus, Postgres configurati
- ‚ùå Version warning ‚Üí ‚úÖ Rimosso version obsoleto
- ‚ùå GPU dependency ‚Üí ‚úÖ Reso opzionale

Il sistema √® ora pronto per lo sviluppo e l'utilizzo! üéâ

```

---

### üìÑ `../backend/Supabase-Backend-app/.env.example`

**üìè Dimensione:** 2.2 KB | **üìù Righe:** 75

```example
# Database
DATABASE_URL="postgresql://username:password@localhost:5432/ugo_db"
REDIS_URL="redis://localhost:6379"

# JWT
JWT_SECRET="ugo-super-secret-jwt-key-2024-francesco-archi"
JWT_REFRESH_SECRET="ugo-refresh-secret-key-2024-francesco-archi"
JWT_EXPIRE="15m"
JWT_REFRESH_EXPIRE="7d"

# AWS S3
AWS_ACCESS_KEY_ID="your-access-key-id"
AWS_SECRET_ACCESS_KEY="your-secret-access-key"
AWS_BUCKET_NAME="ugo-site-uploads"
AWS_REGION="eu-west-1"

# Cloudinary (Alternative to AWS S3)
CLOUDINARY_CLOUD_NAME="your-cloud-name"
CLOUDINARY_API_KEY="your-api-key"
CLOUDINARY_API_SECRET="your-api-secret"

# Email Configuration (SendGrid)
SENDGRID_API_KEY="your-sendgrid-api-key"
FROM_EMAIL="noreply@ilmondidiugo.com"
SUPPORT_EMAIL="support@ilmondidiugo.com"

# OAuth
GOOGLE_CLIENT_ID="your-google-client-id"
GOOGLE_CLIENT_SECRET="your-google-client-secret"
FACEBOOK_APP_ID="your-facebook-app-id"
FACEBOOK_APP_SECRET="your-facebook-app-secret"

# Server Configuration
NODE_ENV="development"
PORT=3000
HOST="localhost"
CORS_ORIGIN="https://fraarchi.github.io"
SESSION_SECRET="ugo-session-secret-2024"

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100

# File Upload
MAX_FILE_SIZE=5242880
ALLOWED_FILE_TYPES="image/jpeg,image/png,image/gif,image/webp"

# Monitoring & Analytics
SENTRY_DSN="your-sentry-dsn"
ANALYTICS_API_KEY="your-analytics-key"

# Two-Factor Authentication
APP_NAME="Il Mondo di Ugo"
ISSUER_NAME="ilmondidiugo.com"

# Background Jobs
QUEUE_REDIS_URL="redis://localhost:6379/1"

# Health Check
HEALTH_CHECK_PATH="/health"

# Admin Settings
ADMIN_EMAIL="francesco@ilmondidiugo.com"
ADMIN_USERNAME="francesco"

# Feature Flags
ENABLE_REGISTRATION=true
ENABLE_SOCIAL_LOGIN=true
ENABLE_2FA=false
ENABLE_EMAIL_VERIFICATION=true

# Supabase
SUPABASE_URL="https://mdnxxalnykygpgkbqqfn.supabase.co"
SUPABASE_ANON_KEY="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1kbnh4YWxueWt5Z3Bna2JxcWZuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ2NTkzNjAsImV4cCI6MjA3MDIzNTM2MH0.Pi5I-CGBX9nHAEcGm2pkNHfvgYsEONHaxOShkLaDaUM"
SUPABASE_SERVICE_ROLE_KEY="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1kbnh4YWxueWt5Z3Bna2JxcWZuIiwicm9zZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1NDY1OTM2MCwiZXhwIjoyMDcwMjM1MzYwfQ.LNffCCmV-kRQBQu3Fn1We4pmQpze1TUrXp0WoBLZ5g0"
```

---

### üìÑ `../backend/Supabase-Backend-app/.github/workflows/deploy.yml`

**üìè Dimensione:** 722 B | **üìù Righe:** 38

```yml
name: Deploy Backend

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'

      - name: Install dependencies
        run: |
          cd backend
          npm install

      - name: Run migrations and seed database
        run: |
          cd backend
          npx supabase db push --file ../supabase/init.sql

      - name: Deploy application
        run: |
          cd backend
          npm run build
          npm start

      - name: Notify deployment success
        run: echo "Deployment successful!"
```

---

### üìÑ `../backend/Supabase-Backend-app/README.md`

**üìè Dimensione:** 2.5 KB | **üìù Righe:** 77

```md
# Ugo Backend Project

This repository contains the backend code for the Ugo project, which is a web application designed to manage various functionalities related to user interactions and data handling.

## Table of Contents

- [Installation](#installation)
- [Usage](#usage)
- [Environment Variables](#environment-variables)
- [Folder Structure](#folder-structure)
- [Contributing](#contributing)
- [License](#license)

## Installation

1. Clone the repository:
   ````
   git clone https://github.com/yourusername/ugo-backend.git
   ````
2. Navigate to the backend directory:
   ````
   cd ugo-backend/backend
   ````
3. Install the dependencies:
   ````
   npm install
   ````
4. Create a `.env` file based on the `.env.example` template and fill in the required environment variables.

## Usage

To start the backend server, run:
````
npm start
````
The server will be running on `http://localhost:3000`.

## Environment Variables

Make sure to set up the following environment variables in your `.env` file:

- `DATABASE_URL`: Connection string for the PostgreSQL database.
- `REDIS_URL`: Connection string for the Redis server.
- `JWT_SECRET`: Secret key for JWT authentication.
- `AWS_ACCESS_KEY_ID`: AWS access key ID for S3.
- `AWS_SECRET_ACCESS_KEY`: AWS secret access key for S3.
- `SENDGRID_API_KEY`: API key for SendGrid email service.
- Other variables as specified in the `.env.example` file.

## Folder Structure

````
ugo-backend
‚îú‚îÄ‚îÄ backend
‚îÇ   ‚îú‚îÄ‚îÄ src
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config          # Configuration files
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controllers     # Request handling logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes          # API routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middlewares     # Middleware functions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services        # Business logic and database interactions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models          # Data models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils           # Utility functions
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app.js          # Entry point of the application
‚îÇ   ‚îú‚îÄ‚îÄ package.json        # NPM package configuration
‚îú‚îÄ‚îÄ supabase                # Database initialization scripts
‚îú‚îÄ‚îÄ .github                 # GitHub Actions workflows
‚îú‚îÄ‚îÄ .env.example            # Template for environment variables
‚îî‚îÄ‚îÄ .gitignore              # Files to ignore in Git
````

## Contributing

Contributions are welcome! Please open an issue or submit a pull request for any improvements or bug fixes.

## License

This project is licensed under the MIT License. See the LICENSE file for details.
```

---

### üìÑ `../backend/Supabase-Backend-app/backend-2/README.md`

**üìè Dimensione:** 1.5 KB | **üìù Righe:** 60

```md
# Ugo Backend

This is the backend for the Ugo project, which provides the necessary API and services for the application.

## Table of Contents

- [Installation](#installation)
- [Usage](#usage)
- [Environment Variables](#environment-variables)
- [API Endpoints](#api-endpoints)
- [Contributing](#contributing)
- [License](#license)

## Installation

1. Clone the repository:
   ````
   git clone https://github.com/yourusername/ugo-backend.git
   cd ugo-backend/backend
   ````

2. Install the dependencies:
   ````
   npm install
   ````

3. Create a `.env` file based on the `.env.example` file and fill in the required environment variables.

## Usage

To start the server, run:
````
npm start
````

The server will run on `http://localhost:3000`.

## Environment Variables

Make sure to set the following environment variables in your `.env` file:

- `DATABASE_URL`: Connection string for the PostgreSQL database.
- `REDIS_URL`: Connection string for the Redis server.
- `JWT_SECRET`: Secret key for JWT authentication.
- `AWS_ACCESS_KEY_ID`: AWS access key ID for S3.
- `AWS_SECRET_ACCESS_KEY`: AWS secret access key for S3.
- `SENDGRID_API_KEY`: API key for SendGrid.
- Other variables as specified in the `.env.example` file.

## API Endpoints

Refer to the documentation in the `src/controllers/index.js` file for available API endpoints and their usage.

## Contributing

Contributions are welcome! Please open an issue or submit a pull request for any improvements or bug fixes.

## License

This project is licensed under the MIT License. See the LICENSE file for details.
```

---

### üìÑ `../backend/Supabase-Backend-app/backend-2/package.json`

**üìè Dimensione:** 590 B | **üìù Righe:** 27

```json
{
  "name": "ugo-backend",
  "version": "1.0.0",
  "description": "Backend for Il Mondo di Ugo",
  "main": "src/app.js",
  "scripts": {
    "start": "node src/app.js",
    "dev": "nodemon src/app.js",
    "test": "jest"
  },
  "dependencies": {
    "dotenv": "^10.0.0",
    "express": "^4.17.1",
    "pg": "^8.7.1",
    "redis": "^3.1.2",
    "jsonwebtoken": "^8.5.1",
    "sendgrid/mail": "^7.4.0",
    "sentry-node": "^6.0.0",
    "supabase-js": "^1.28.0"
  },
  "devDependencies": {
    "jest": "^27.0.0",
    "nodemon": "^2.0.12"
  },
  "author": "Francesco Archi",
  "license": "MIT"
}
```

---

### üìÑ `../backend/Supabase-Backend-app/backend-2/src/app.js`

**üìè Dimensione:** 578 B | **üìù Righe:** 26

```js
import express from 'express';
import { env } from './config/env.js';
import routes from './routes/index.js';
import { logger } from './utils/logger.js';

const app = express();

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Routes
app.use('/api', routes);

// Health check route
app.get('/health', (req, res) => {
    res.status(200).json({ status: 'OK' });
});

// Start the server
const PORT = env.PORT || 3000;
app.listen(PORT, () => {
    logger.info(`Server is running on http://${env.HOST}:${PORT}`);
});

export default app;
```

---

### üìÑ `../backend/Supabase-Backend-app/backend-2/src/config/env.js`

**üìè Dimensione:** 281 B | **üìù Righe:** 10

```js
import path from 'path';
import { fileURLToPath } from 'url';
import dotenv from 'dotenv';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

dotenv.config({ path: path.join(__dirname, '../../.env') });

export const env = process.env;
```

---

### üìÑ `../backend/Supabase-Backend-app/backend-2/src/controllers/index.js`

**üìè Dimensione:** 842 B | **üìù Righe:** 27

```js
import { env } from '../config/env.js';

// Example controller function for handling a request
export const getContacts = async (req, res) => {
    try {
        // Logic to retrieve contacts from the database
        res.status(200).json({ message: 'Contacts retrieved successfully' });
    } catch (error) {
        res.status(500).json({ error: 'An error occurred while retrieving contacts' });
    }
};

// Example controller function for handling a file upload
export const uploadFile = async (req, res) => {
    try {
        // Logic to handle file upload
        res.status(201).json({ message: 'File uploaded successfully' });
    } catch (error) {
        res.status(500).json({ error: 'An error occurred while uploading the file' });
    }
};

// Export all controller functions
export default {
    getContacts,
    uploadFile,
};
```

---

### üìÑ `../backend/Supabase-Backend-app/backend-2/src/middlewares/auth.js`

**üìè Dimensione:** 602 B | **üìù Righe:** 22

```js
import jwt from 'jsonwebtoken';
import { env } from '../config/env.js';

export const authenticateToken = (req, res, next) => {
    const token = req.headers['authorization']?.split(' ')[1];
    if (!token) return res.sendStatus(401);

    jwt.verify(token, env.JWT_SECRET, (err, user) => {
        if (err) return res.sendStatus(403);
        req.user = user;
        next();
    });
};

export const authorizeRoles = (...roles) => {
    return (req, res, next) => {
        if (!req.user || !roles.includes(req.user.role)) {
            return res.sendStatus(403);
        }
        next();
    };
};
```

---

### üìÑ `../backend/Supabase-Backend-app/backend-2/src/models/index.js`

**üìè Dimensione:** 560 B | **üìù Righe:** 21

```js
import { Sequelize } from 'sequelize';

// Initialize Sequelize with your database configuration
const sequelize = new Sequelize(process.env.DATABASE_URL, {
  dialect: 'postgres',
  logging: false, // Set to true for SQL query logging
});

// Import models
import User from './User.js';
import Contact from './Contact.js';
import Upload from './Upload.js';

// Define associations
User.hasMany(Contact);
Contact.belongsTo(User);
User.hasMany(Upload);
Upload.belongsTo(User);

// Export models and sequelize instance
export { sequelize, User, Contact, Upload };
```

---

### üìÑ `../backend/Supabase-Backend-app/backend-2/src/routes/index.js`

**üìè Dimensione:** 325 B | **üìù Righe:** 12

```js
import express from 'express';
import { someControllerFunction } from '../controllers/index.js';
import { authenticate } from '../middlewares/auth.js';

const router = express.Router();

// Define routes
router.get('/some-endpoint', authenticate, someControllerFunction);

// Add more routes as needed

export default router;
```

---

### üìÑ `../backend/Supabase-Backend-app/backend-2/src/services/index.js`

**üìè Dimensione:** 458 B | **üìù Righe:** 17

```js
import { env } from '../config/env.js';

// Example service function to get data from the database
export const getData = async () => {
    // Logic to interact with the database or external services
};

// Example service function to create data in the database
export const createData = async (data) => {
    // Logic to interact with the database or external services
};

// Exporting all service functions
export default {
    getData,
    createData,
};
```

---

### üìÑ `../backend/Supabase-Backend-app/backend-2/src/utils/logger.js`

**üìè Dimensione:** 623 B | **üìù Righe:** 26

```js
import winston from 'winston';

const logger = winston.createLogger({
    level: 'info',
    format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json()
    ),
    transports: [
        new winston.transports.Console(),
        new winston.transports.File({ filename: 'error.log', level: 'error' }),
        new winston.transports.File({ filename: 'combined.log' })
    ],
});

export const logInfo = (message) => {
    logger.info(message);
};

export const logError = (message) => {
    logger.error(message);
};

export const logWarning = (message) => {
    logger.warn(message);
};
```

---

### üìÑ `../backend/Supabase-Backend-app/supabase/init.sql`

**üìè Dimensione:** 728 B | **üìù Righe:** 26

```sql
CREATE TABLE contacts (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE uploads (
    id SERIAL PRIMARY KEY,
    user_id INT REFERENCES contacts(id),
    file_url TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Row Level Security Policies
ALTER TABLE contacts ENABLE ROW LEVEL SECURITY;
CREATE POLICY select_contacts ON contacts
    FOR SELECT
    USING (auth.uid() = id);

ALTER TABLE uploads ENABLE ROW LEVEL SECURITY;
CREATE POLICY select_uploads ON uploads
    FOR SELECT
    USING (auth.uid() = user_id);
```

---

### üìÑ `../backend/backend/docker/mediapipe/Dockerfile`

**üìè Dimensione:** 0 B | **üìù Righe:** 1

```text

```

---

### üìÑ `../backend/backend/docker/stable-diffusion/Dockerfile`

**üìè Dimensione:** 0 B | **üìù Righe:** 1

```text

```

---

### üìÑ `../backend/docker-compose.yml`

**üìè Dimensione:** 2.8 KB | **üìù Righe:** 122

```yml
version: 3.x

services:
  ugo-backend:
    build:
      context: .         # se il Dockerfile √® in ./backend -> usa "./backend"
      dockerfile: Dockerfile
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      NODE_ENV: "production"
      DATABASE_URL: "postgresql://postgres:password@postgres:5432/ugo_db"
      REDIS_URL: "redis://redis:6379"
    depends_on:
      - postgres
      - redis
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:3000/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 5s

  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: ugo_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_INITDB_ARGS: "--encoding=UTF-8 --locale=C"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./docker/postgres/init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5433:5432"   # mappa: host 5433 -> container 5432 (ok se hai un Postgres locale)
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 10
      start_period: 10s

  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes --maxmemory 512mb --maxmemory-policy allkeys-lru
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    restart: unless-stopped

  ollama:
    image: ollama/ollama:latest
    ports:
      - "11434:11434"
    volumes:
      - ollama_data:/root/.ollama
    environment:
      - OLLAMA_MODELS=llama3.1:8b
      - OLLAMA_HOST=0.0.0.0
      - OLLAMA_ORIGINS=*
    restart: unless-stopped

  mediapipe-service:
    build:
      context: ./docker/mediapipe
      dockerfile: Dockerfile
    ports:
      - "5003:5003"
    volumes:
      - mediapipe_cache:/cache
    environment:
      - CACHE_PATH=/cache
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./docker/nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./docker/nginx/ssl:/etc/nginx/ssl
      - ./public:/var/www/html
    depends_on:
      - ugo-backend
    restart: unless-stopped

  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./docker/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    restart: unless-stopped

  grafana:
    image: grafana/grafana:latest
    ports:
      - "3001:3000"
    volumes:
      - grafana_data:/var/lib/grafana
      - ./docker/grafana/provisioning:/etc/grafana/provisioning
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    restart: unless-stopped
    depends_on:
      - postgres
      - redis
      - ollama

volumes:
  postgres_data:
  redis_data:
  ollama_data:
  mediapipe_cache:
  prometheus_data:
  grafana_data:

```

---

### üìÑ `../backend/docker/coqui-tts/Dockerfile`

**üìè Dimensione:** 655 B | **üìù Righe:** 40

```text
FROM python:3.10-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    wget \
    curl \
    git \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies for TTS
RUN pip install --no-cache-dir \
    TTS \
    flask \
    flask-cors \
    torch \
    torchaudio \
    soundfile \
    librosa \
    numpy

# Create directories
RUN mkdir -p /models /cache

# Copy application files
COPY app.py .

# Expose port
EXPOSE 5002

# Set environment variables
ENV MODEL_PATH=/models/tts_model.pth
ENV CACHE_PATH=/cache
ENV PYTHONUNBUFFERED=1

# Run the application
CMD ["python", "app.py"]

```

---

### üìÑ `../backend/docker/coqui-tts/app.py`

**üìè Dimensione:** 3.5 KB | **üìù Righe:** 115

```py
from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
from TTS.api import TTS
import io
import base64
import os
import tempfile
import soundfile as sf

app = Flask(__name__)
CORS(app)

# Initialize TTS model
print("Loading TTS model...")
try:
    # Use a lightweight TTS model
    tts = TTS(model_name="tts_models/en/ljspeech/tacotron2-DDC", progress_bar=False)
    print("TTS model loaded successfully!")
except Exception as e:
    print(f"Error loading TTS model: {e}")
    # Fallback to a simpler model
    try:
        tts = TTS(model_name="tts_models/en/ljspeech/speedy-speech", progress_bar=False)
        print("Fallback TTS model loaded!")
    except Exception as e2:
        print(f"Error loading fallback model: {e2}")
        tts = None

@app.route('/health', methods=['GET'])
def health_check():
    return jsonify({"status": "healthy", "model_loaded": tts is not None})

@app.route('/synthesize', methods=['POST'])
def synthesize_speech():
    if not tts:
        return jsonify({"error": "TTS model not loaded"}), 500
        
    data = request.json
    text = data.get('text', 'Hello, this is a test.')
    language = data.get('language', 'en')
    speaker = data.get('speaker', None)
    
    if not text:
        return jsonify({"error": "No text provided"}), 400
    
    try:
        print(f"Synthesizing speech for text: {text[:50]}...")
        
        # Create temporary file for output
        with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as temp_file:
            temp_path = temp_file.name
        
        # Generate speech
        if speaker and hasattr(tts, 'speakers') and tts.speakers:
            tts.tts_to_file(text=text, file_path=temp_path, speaker=speaker)
        else:
            tts.tts_to_file(text=text, file_path=temp_path)
        
        # Read the generated audio file
        audio_data, sample_rate = sf.read(temp_path)
        
        # Convert to base64 for response
        audio_buffer = io.BytesIO()
        sf.write(audio_buffer, audio_data, sample_rate, format='WAV')
        audio_base64 = base64.b64encode(audio_buffer.getvalue()).decode()
        
        # Clean up temporary file
        os.unlink(temp_path)
        
        return jsonify({
            "success": True,
            "audio": f"data:audio/wav;base64,{audio_base64}",
            "sample_rate": sample_rate,
            "duration": len(audio_data) / sample_rate
        })
        
    except Exception as e:
        print(f"Error synthesizing speech: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/voices', methods=['GET'])
def get_voices():
    if not tts:
        return jsonify({"error": "TTS model not loaded"}), 500
    
    try:
        speakers = []
        if hasattr(tts, 'speakers') and tts.speakers:
            speakers = tts.speakers
        
        languages = []
        if hasattr(tts, 'languages') and tts.languages:
            languages = tts.languages
            
        return jsonify({
            "speakers": speakers,
            "languages": languages,
            "model_name": getattr(tts, 'model_name', 'unknown')
        })
        
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/', methods=['GET'])
def home():
    return jsonify({
        "message": "Coqui TTS API",
        "endpoints": ["/health", "/synthesize", "/voices"],
        "model_loaded": tts is not None
    })

if __name__ == '__main__':
    print("Starting Coqui TTS API server...")
    app.run(host='0.0.0.0', port=5002, debug=False)

```

---

### üìÑ `../backend/docker/grafana/provisioning/datasources/prometheus.yml`

**üìè Dimensione:** 159 B | **üìù Righe:** 10

```yml
apiVersion: 1

datasources:
  - name: Prometheus
    type: prometheus
    access: proxy
    url: http://prometheus:9090
    isDefault: true
    editable: true

```

---

### üìÑ `../backend/docker/mediapipe/Dockerfile`

**üìè Dimensione:** 672 B | **üìù Righe:** 41

```text
FROM python:3.10-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    libgl1-mesa-glx \
    libglib2.0-0 \
    libsm6 \
    libxext6 \
    libxrender-dev \
    libgomp1 \
    wget \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
RUN pip install --no-cache-dir \
    mediapipe \
    flask \
    flask-cors \
    opencv-python-headless \
    pillow \
    numpy \
    requests

# Create cache directory
RUN mkdir -p /cache

# Copy application files
COPY app.py .

# Expose port
EXPOSE 5003

# Set environment variables
ENV CACHE_PATH=/cache
ENV PYTHONUNBUFFERED=1

# Run the application
CMD ["python", "app.py"]

```

---

### üìÑ `../backend/docker/mediapipe/app.py`

**üìè Dimensione:** 6.0 KB | **üìù Righe:** 186

```py
from flask import Flask, request, jsonify
from flask_cors import CORS
import mediapipe as mp
import cv2
import numpy as np
import base64
import io
from PIL import Image
import os

app = Flask(__name__)
CORS(app)

# Initialize MediaPipe solutions
mp_face_detection = mp.solutions.face_detection
mp_face_mesh = mp.solutions.face_mesh
mp_hands = mp.solutions.hands
mp_pose = mp.solutions.pose
mp_drawing = mp.solutions.drawing_utils

# Initialize detectors
face_detection = mp_face_detection.FaceDetection(model_selection=0, min_detection_confidence=0.5)
face_mesh = mp_face_mesh.FaceMesh(static_image_mode=True, max_num_faces=1, refine_landmarks=True, min_detection_confidence=0.5)
hands = mp_hands.Hands(static_image_mode=True, max_num_hands=2, min_detection_confidence=0.5)
pose = mp_pose.Pose(static_image_mode=True, model_complexity=2, enable_segmentation=True, min_detection_confidence=0.5)

print("MediaPipe models initialized successfully!")

@app.route('/health', methods=['GET'])
def health_check():
    return jsonify({"status": "healthy", "services": ["face_detection", "face_mesh", "hands", "pose"]})

def decode_image(image_data):
    """Decode base64 image data to numpy array"""
    if image_data.startswith('data:image'):
        image_data = image_data.split(',')[1]
    
    image_bytes = base64.b64decode(image_data)
    image = Image.open(io.BytesIO(image_bytes))
    return cv2.cvtColor(np.array(image), cv2.COLOR_RGB2BGR)

def encode_image(image):
    """Encode numpy array to base64"""
    _, buffer = cv2.imencode('.jpg', image)
    img_str = base64.b64encode(buffer).decode()
    return f"data:image/jpeg;base64,{img_str}"

@app.route('/detect_faces', methods=['POST'])
def detect_faces():
    try:
        data = request.json
        image_data = data.get('image')
        
        if not image_data:
            return jsonify({"error": "No image provided"}), 400
        
        # Decode image
        image = decode_image(image_data)
        image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        
        # Process with MediaPipe
        results = face_detection.process(image_rgb)
        
        faces = []
        if results.detections:
            for detection in results.detections:
                bbox = detection.location_data.relative_bounding_box
                faces.append({
                    "x": bbox.xmin,
                    "y": bbox.ymin,
                    "width": bbox.width,
                    "height": bbox.height,
                    "confidence": detection.score[0]
                })
                
                # Draw bounding box
                h, w, _ = image.shape
                x = int(bbox.xmin * w)
                y = int(bbox.ymin * h)
                width = int(bbox.width * w)
                height = int(bbox.height * h)
                cv2.rectangle(image, (x, y), (x + width, y + height), (0, 255, 0), 2)
        
        return jsonify({
            "success": True,
            "faces": faces,
            "count": len(faces),
            "annotated_image": encode_image(image)
        })
        
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/detect_hands', methods=['POST'])
def detect_hands():
    try:
        data = request.json
        image_data = data.get('image')
        
        if not image_data:
            return jsonify({"error": "No image provided"}), 400
        
        # Decode image
        image = decode_image(image_data)
        image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        
        # Process with MediaPipe
        results = hands.process(image_rgb)
        
        hands_data = []
        if results.multi_hand_landmarks:
            for hand_landmarks in results.multi_hand_landmarks:
                landmarks = []
                for landmark in hand_landmarks.landmark:
                    landmarks.append({
                        "x": landmark.x,
                        "y": landmark.y,
                        "z": landmark.z
                    })
                hands_data.append({"landmarks": landmarks})
                
                # Draw landmarks
                mp_drawing.draw_landmarks(image, hand_landmarks, mp_hands.HAND_CONNECTIONS)
        
        return jsonify({
            "success": True,
            "hands": hands_data,
            "count": len(hands_data),
            "annotated_image": encode_image(image)
        })
        
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/detect_pose', methods=['POST'])
def detect_pose():
    try:
        data = request.json
        image_data = data.get('image')
        
        if not image_data:
            return jsonify({"error": "No image provided"}), 400
        
        # Decode image
        image = decode_image(image_data)
        image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        
        # Process with MediaPipe
        results = pose.process(image_rgb)
        
        pose_data = None
        if results.pose_landmarks:
            landmarks = []
            for landmark in results.pose_landmarks.landmark:
                landmarks.append({
                    "x": landmark.x,
                    "y": landmark.y,
                    "z": landmark.z,
                    "visibility": landmark.visibility
                })
            pose_data = {"landmarks": landmarks}
            
            # Draw landmarks
            mp_drawing.draw_landmarks(image, results.pose_landmarks, mp_pose.POSE_CONNECTIONS)
        
        return jsonify({
            "success": True,
            "pose": pose_data,
            "detected": pose_data is not None,
            "annotated_image": encode_image(image)
        })
        
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/', methods=['GET'])
def home():
    return jsonify({
        "message": "MediaPipe API",
        "endpoints": ["/health", "/detect_faces", "/detect_hands", "/detect_pose"]
    })

if __name__ == '__main__':
    print("Starting MediaPipe API server...")
    app.run(host='0.0.0.0', port=5003, debug=False)

```

---

### üìÑ `../backend/docker/nginx/nginx.conf`

**üìè Dimensione:** 1.1 KB | **üìù Righe:** 43

```conf
events {
    worker_connections 1024;
}

http {
    upstream backend {
        server ugo-backend:3000;
    }
    
    upstream mediapipe_service {
        server mediapipe-service:5003;
    }

    server {
        listen 80;
        server_name localhost;
        
        # Main backend API
        location /api/ {
            proxy_pass http://backend/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
        
        # MediaPipe service
        location /mediapipe/ {
            proxy_pass http://mediapipe_service/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
        
        # Static files
        location / {
            root /var/www/html;
            try_files $uri $uri/ /index.html;
        }
    }
}

```

---

### üìÑ `../backend/docker/nginx/ssl/README.md`

**üìè Dimensione:** 190 B | **üìù Righe:** 4

```md
# SSL certificates will be placed here
# For development, you can generate self-signed certificates:
# openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout server.key -out server.crt

```

---

### üìÑ `../backend/docker/postgres/init.sql`

**üìè Dimensione:** 1.5 KB | **üìù Righe:** 46

```sql
-- Initialize the database with basic structure
CREATE DATABASE IF NOT EXISTS ugo_db;

-- Create basic tables if they don't exist
\c ugo_db;

CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    username VARCHAR(100) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS posts (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    title VARCHAR(255) NOT NULL,
    content TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS conversations (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    title VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS messages (
    id SERIAL PRIMARY KEY,
    conversation_id INTEGER REFERENCES conversations(id),
    role VARCHAR(50) NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_posts_user_id ON posts(user_id);
CREATE INDEX IF NOT EXISTS idx_conversations_user_id ON conversations(user_id);
CREATE INDEX IF NOT EXISTS idx_messages_conversation_id ON messages(conversation_id);

```

---

### üìÑ `../backend/docker/prometheus/prometheus.yml`

**üìè Dimensione:** 665 B | **üìù Righe:** 34

```yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  # - "first_rules.yml"
  # - "second_rules.yml"

scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  - job_name: 'ugo-backend'
    static_configs:
      - targets: ['ugo-backend:3000']
    metrics_path: '/metrics'
    scrape_interval: 30s

  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres:5432']
    scrape_interval: 30s

  - job_name: 'redis'
    static_configs:
      - targets: ['redis:6379']
    scrape_interval: 30s

  - job_name: 'nginx'
    static_configs:
      - targets: ['nginx:80']
    scrape_interval: 30s

```

---

### üìÑ `../backend/package-lock.json`

**üìè Dimensione:** 419.8 KB | **üìù Righe:** 11,499

```json
{
  "name": "ugo-backend",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "ugo-backend",
      "version": "1.0.0",
      "license": "MIT",
      "dependencies": {
        "@prisma/client": "^5.6.0",
        "@sendgrid/mail": "^8.1.5",
        "axios": "^1.6.0",
        "bcryptjs": "^2.4.3",
        "cloudinary": "^1.41.0",
        "compression": "^1.7.4",
        "connect-redis": "^7.1.0",
        "cors": "^2.8.5",
        "dotenv": "^16.3.1",
        "express": "^4.18.2",
        "express-async-errors": "^3.1.1",
        "express-rate-limit": "^7.1.5",
        "express-slow-down": "^2.0.1",
        "express-validator": "^7.2.1",
        "faker": "^5.5.3",
        "helmet": "^7.1.0",
        "ioredis": "^5.3.2",
        "joi": "^17.11.0",
        "jsonwebtoken": "^9.0.2",
        "morgan": "^1.10.1",
        "multer": "^1.4.5-lts.1",
        "node-cron": "^3.0.3",
        "nodemailer": "^6.9.7",
        "passport": "^0.7.0",
        "passport-facebook": "^3.0.0",
        "passport-google-oauth20": "^2.0.0",
        "prisma": "^5.6.0",
        "redis": "^4.6.10",
        "sharp": "^0.32.6",
        "socket.io": "^4.7.4",
        "swagger-jsdoc": "^6.2.8",
        "swagger-ui-express": "^5.0.0",
        "winston": "^3.11.0"
      },
      "devDependencies": {
        "@faker-js/faker": "^8.3.1",
        "@sentry/node": "^10.3.0",
        "@types/jest": "^29.5.8",
        "eslint": "^8.54.0",
        "eslint-config-node": "^4.1.0",
        "eslint-plugin-node": "^11.1.0",
        "jest": "^29.7.0",
        "nodemon": "^3.0.1",
        "prom-client": "^15.1.3",
        "supertest": "^6.3.3"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@ampproject/remapping": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
      "dev": true,
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@apidevtools/json-schema-ref-parser": {
      "version": "9.1.2",
      "resolved": "https://registry.npmjs.org/@apidevtools/json-schema-ref-parser/-/json-schema-ref-parser-9.1.2.tgz",
      "integrity": "sha512-r1w81DpR+KyRWd3f+rk6TNqMgedmAxZP5v5KWlXQWlgMUUtyEJch0DKEci1SorPMiSeM8XPl7MZ3miJ60JIpQg==",
      "dependencies": {
        "@jsdevtools/ono": "^7.1.3",
        "@types/json-schema": "^7.0.6",
        "call-me-maybe": "^1.0.1",
        "js-yaml": "^4.1.0"
      }
    },
    "node_modules/@apidevtools/openapi-schemas": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/@apidevtools/openapi-schemas/-/openapi-schemas-2.1.0.tgz",
      "integrity": "sha512-Zc1AlqrJlX3SlpupFGpiLi2EbteyP7fXmUOGup6/DnkRgjP9bgMM/ag+n91rsv0U1Gpz0H3VILA/o3bW7Ua6BQ==",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/@apidevtools/swagger-methods": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/@apidevtools/swagger-methods/-/swagger-methods-3.0.2.tgz",
      "integrity": "sha512-QAkD5kK2b1WfjDS/UQn/qQkbwF31uqRjPTrsCs5ZG9BQGAkjwvqGFjjPqAuzac/IYzpPtRzjCP1WrTuAIjMrXg=="
    },
    "node_modules/@apidevtools/swagger-parser": {
      "version": "10.0.3",
      "resolved": "https://registry.npmjs.org/@apidevtools/swagger-parser/-/swagger-parser-10.0.3.tgz",
      "integrity": "sha512-sNiLY51vZOmSPFZA5TF35KZ2HbgYklQnTSDnkghamzLb3EkNtcQnrBQEj5AOCxHpTtXpqMCRM1CrmV2rG6nw4g==",
      "dependencies": {
        "@apidevtools/json-schema-ref-parser": "^9.0.6",
        "@apidevtools/openapi-schemas": "^2.0.4",
        "@apidevtools/swagger-methods": "^3.0.2",
        "@jsdevtools/ono": "^7.1.3",
        "call-me-maybe": "^1.0.1",
        "z-schema": "^5.0.1"
      },
      "peerDependencies": {
        "openapi-types": ">=7"
      }
    },
    "node_modules/@babel/code-frame": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.27.1.tgz",
      "integrity": "sha512-cjQ7ZlQ0Mv3b47hABuTevyTuYN4i+loJKGeV9flcCgIK37cCXRh+L1bd3iBHlynerhQ7BhCkn2BPbQUL+rGqFg==",
      "dev": true,
      "dependencies": {
        "@babel/helper-validator-identifier": "^7.27.1",
        "js-tokens": "^4.0.0",
        "picocolors": "^1.1.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/compat-data": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.28.0.tgz",
      "integrity": "sha512-60X7qkglvrap8mn1lh2ebxXdZYtUcpd7gsmy9kLaBJ4i/WdY8PqTSdxyA8qraikqKQK5C1KRBKXqznrVapyNaw==",
      "dev": true,
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/core": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.28.0.tgz",
      "integrity": "sha512-UlLAnTPrFdNGoFtbSXwcGFQBtQZJCNjaN6hQNP3UPvuNXT1i82N26KL3dZeIpNalWywr9IuQuncaAfUaS1g6sQ==",
      "dev": true,
      "dependencies": {
        "@ampproject/remapping": "^2.2.0",
        "@babel/code-frame": "^7.27.1",
        "@babel/generator": "^7.28.0",
        "@babel/helper-compilation-targets": "^7.27.2",
        "@babel/helper-module-transforms": "^7.27.3",
        "@babel/helpers": "^7.27.6",
        "@babel/parser": "^7.28.0",
        "@babel/template": "^7.27.2",
        "@babel/traverse": "^7.28.0",
        "@babel/types": "^7.28.0",
        "convert-source-map": "^2.0.0",
        "debug": "^4.1.0",
        "gensync": "^1.0.0-beta.2",
        "json5": "^2.2.3",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/babel"
      }
    },
    "node_modules/@babel/core/node_modules/debug": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.1.tgz",
      "integrity": "sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==",
      "dev": true,
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/@babel/core/node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true
    },
    "node_modules/@babel/generator": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.28.0.tgz",
      "integrity": "sha512-lJjzvrbEeWrhB4P3QBsH7tey117PjLZnDbLiQEKjQ/fNJTjuq4HSqgFA+UNSwZT8D7dxxbnuSBMsa1lrWzKlQg==",
      "dev": true,
      "dependencies": {
        "@babel/parser": "^7.28.0",
        "@babel/types": "^7.28.0",
        "@jridgewell/gen-mapping": "^0.3.12",
        "@jridgewell/trace-mapping": "^0.3.28",
        "jsesc": "^3.0.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-compilation-targets": {
      "version": "7.27.2",
      "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.27.2.tgz",
      "integrity": "sha512-2+1thGUUWWjLTYTHZWK1n8Yga0ijBz1XAhUXcKy81rd5g6yh7hGqMp45v7cadSbEHc9G3OTv45SyneRN3ps4DQ==",
      "dev": true,
      "dependencies": {
        "@babel/compat-data": "^7.27.2",
        "@babel/helper-validator-option": "^7.27.1",
        "browserslist": "^4.24.0",
        "lru-cache": "^5.1.1",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-globals": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/helper-globals/-/helper-globals-7.28.0.tgz",
      "integrity": "sha512-+W6cISkXFa1jXsDEdYA8HeevQT/FULhxzR99pxphltZcVaugps53THCeiWA8SguxxpSp3gKPiuYfSWopkLQ4hw==",
      "dev": true,
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-imports": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.27.1.tgz",
      "integrity": "sha512-0gSFWUPNXNopqtIPQvlD5WgXYI5GY2kP2cCvoT8kczjbfcfuIljTbcWrulD1CIPIX2gt1wghbDy08yE1p+/r3w==",
      "dev": true,
      "dependencies": {
        "@babel/traverse": "^7.27.1",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-transforms": {
      "version": "7.27.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.27.3.tgz",
      "integrity": "sha512-dSOvYwvyLsWBeIRyOeHXp5vPj5l1I011r52FM1+r1jCERv+aFXYk4whgQccYEGYxK2H3ZAIA8nuPkQ0HaUo3qg==",
      "dev": true,
      "dependencies": {
        "@babel/helper-module-imports": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.27.1",
        "@babel/traverse": "^7.27.3"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-plugin-utils": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.27.1.tgz",
      "integrity": "sha512-1gn1Up5YXka3YYAHGKpbideQ5Yjf1tDa9qYcgysz+cNCXukyLl6DjPXhD3VRwSb8c0J9tA4b2+rHEZtc6R0tlw==",
      "dev": true,
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
      "dev": true,
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.27.1.tgz",
      "integrity": "sha512-D2hP9eA+Sqx1kBZgzxZh0y1trbuU+JoDkiEwqhQ36nodYqJwyEIhPSdMNd7lOm/4io72luTPWH20Yda0xOuUow==",
      "dev": true,
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-option": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.27.1.tgz",
      "integrity": "sha512-YvjJow9FxbhFFKDSuFnVCe2WxXk1zWc22fFePVNEaWJEu8IrZVlda6N0uHwzZrUM1il7NC9Mlp4MaJYbYd9JSg==",
      "dev": true,
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helpers": {
      "version": "7.28.2",
      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.28.2.tgz",
      "integrity": "sha512-/V9771t+EgXz62aCcyofnQhGM8DQACbRhvzKFsXKC9QM+5MadF8ZmIm0crDMaz3+o0h0zXfJnd4EhbYbxsrcFw==",
      "dev": true,
      "dependencies": {
        "@babel/template": "^7.27.2",
        "@babel/types": "^7.28.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.28.0.tgz",
      "integrity": "sha512-jVZGvOxOuNSsuQuLRTh13nU0AogFlw32w/MT+LV6D3sP5WdbW61E77RnkbaO2dUvmPAYrBDJXGn5gGS6tH4j8g==",
      "dev": true,
      "dependencies": {
        "@babel/types": "^7.28.0"
      },
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/plugin-syntax-async-generators": {
      "version": "7.8.4",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-async-generators/-/plugin-syntax-async-generators-7.8.4.tgz",
      "integrity": "sha512-tycmZxkGfZaxhMRbXlPXuVFpdWlXpir2W4AMhSJgRKzk/eDlIXOhb2LHWoLpDF7TEHylV5zNhykX6KAgHJmTNw==",
      "dev": true,
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-bigint": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-bigint/-/plugin-syntax-bigint-7.8.3.tgz",
      "integrity": "sha512-wnTnFlG+YxQm3vDxpGE57Pj0srRU4sHE/mDkt1qv2YJJSeUAec2ma4WLUnUPeKjyrfntVwe/N6dCXpU+zL3Npg==",
      "dev": true,
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-class-properties": {
      "version": "7.12.13",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-class-properties/-/plugin-syntax-class-properties-7.12.13.tgz",
      "integrity": "sha512-fm4idjKla0YahUNgFNLCB0qySdsoPiZP3iQE3rky0mBUtMZ23yDJ9SJdg6dXTSDnulOVqiF3Hgr9nbXvXTQZYA==",
      "dev": true,
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.12.13"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-class-static-block": {
      "version": "7.14.5",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-class-static-block/-/plugin-syntax-class-static-block-7.14.5.tgz",
      "integrity": "sha512-b+YyPmr6ldyNnM6sqYeMWE+bgJcJpO6yS4QD7ymxgH34GBPNDM/THBh8iunyvKIZztiwLH4CJZ0RxTk9emgpjw==",
      "dev": true,
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.14.5"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-import-attributes": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-import-attributes/-/plugin-syntax-import-attributes-7.27.1.tgz",
      "integrity": "sha512-oFT0FrKHgF53f4vOsZGi2Hh3I35PfSmVs4IBFLFj4dnafP+hIWDLg3VyKmUHfLoLHlyxY4C7DGtmHuJgn+IGww==",
      "dev": true,
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-import-meta": {
      "version": "7.10.4",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-import-meta/-/plugin-syntax-import-meta-7.10.4.tgz",
      "integrity": "sha512-Yqfm+XDx0+Prh3VSeEQCPU81yC+JWZ2pDPFSS4ZdpfZhp4MkFMaDC1UqseovEKwSUpnIL7+vK+Clp7bfh0iD7g==",
      "dev": true,
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.10.4"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-json-strings": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-json-strings/-/plugin-syntax-json-strings-7.8.3.tgz",
      "integrity": "sha512-lY6kdGpWHvjoe2vk4WrAapEuBR69EMxZl+RoGRhrFGNYVK8mOPAW8VfbT/ZgrFbXlDNiiaxQnAtgVCZ6jv30EA==",
      "dev": true,
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-jsx": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-jsx/-/plugin-syntax-jsx-7.27.1.tgz",
      "integrity": "sha512-y8YTNIeKoyhGd9O0Jiyzyyqk8gdjnumGTQPsz0xOZOQ2RmkVJeZ1vmmfIvFEKqucBG6axJGBZDE/7iI5suUI/w==",
      "dev": true,
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-logical-assignment-operators": {
      "version": "7.10.4",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-logical-assignment-operators/-/plugin-syntax-logical-assignment-operators-7.10.4.tgz",
      "integrity": "sha512-d8waShlpFDinQ5MtvGU9xDAOzKH47+FFoney2baFIoMr952hKOLp1HR7VszoZvOsV/4+RRszNY7D17ba0te0ig==",
      "dev": true,
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.10.4"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-nullish-coalescing-operator": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-nullish-coalescing-operator/-/plugin-syntax-nullish-coalescing-operator-7.8.3.tgz",
      "integrity": "sha512-aSff4zPII1u2QD7y+F8oDsz19ew4IGEJg9SVW+bqwpwtfFleiQDMdzA/R+UlWDzfnHFCxxleFT0PMIrR36XLNQ==",
      "dev": true,
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-numeric-separator": {
      "version": "7.10.4",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-numeric-separator/-/plugin-syntax-numeric-separator-7.10.4.tgz",
      "integrity": "sha512-9H6YdfkcK/uOnY/K7/aA2xpzaAgkQn37yzWUMRK7OaPOqOpGS1+n0H5hxT9AUw9EsSjPW8SVyMJwYRtWs3X3ug==",
      "dev": true,
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.10.4"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-object-rest-spread": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-object-rest-spread/-/plugin-syntax-object-rest-spread-7.8.3.tgz",
      "integrity": "sha512-XoqMijGZb9y3y2XskN+P1wUGiVwWZ5JmoDRwx5+3GmEplNyVM2s2Dg8ILFQm8rWM48orGy5YpI5Bl8U1y7ydlA==",
      "dev": true,
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-optional-catch-binding": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-optional-catch-binding/-/plugin-syntax-optional-catch-binding-7.8.3.tgz",
      "integrity": "sha512-6VPD0Pc1lpTqw0aKoeRTMiB+kWhAoT24PA+ksWSBrFtl5SIRVpZlwN3NNPQjehA2E/91FV3RjLWoVTglWcSV3Q==",
      "dev": true,
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-optional-chaining": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-optional-chaining/-/plugin-syntax-optional-chaining-7.8.3.tgz",
      "integrity": "sha512-KoK9ErH1MBlCPxV0VANkXW2/dw4vlbGDrFgz8bmUsBGYkFRcbRwMh6cIJubdPrkxRwuGdtCk0v/wPTKbQgBjkg==",
      "dev": true,
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-private-property-in-object": {
      "version": "7.14.5",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-private-property-in-object/-/plugin-syntax-private-property-in-object-7.14.5.tgz",
      "integrity": "sha512-0wVnp9dxJ72ZUJDV27ZfbSj6iHLoytYZmh3rFcxNnvsJF3ktkzLDZPy/mA17HGsaQT3/DQsWYX1f1QGWkCoVUg==",
      "dev": true,
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.14.5"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-top-level-await": {
      "version": "7.14.5",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-top-level-await/-/plugin-syntax-top-level-await-7.14.5.tgz",
      "integrity": "sha512-hx++upLv5U1rgYfwe1xBQUhRmU41NEvpUvrp8jkrSCdvGSnM5/qdRMtylJ6PG5OFkBaHkbTAKTnd3/YyESRHFw==",
      "dev": true,
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.14.5"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-typescript": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-typescript/-/plugin-syntax-typescript-7.27.1.tgz",
      "integrity": "sha512-xfYCBMxveHrRMnAWl1ZlPXOZjzkN82THFvLhQhFXFt81Z5HnN+EtUkZhv/zcKpmT3fzmWZB0ywiBrbC3vogbwQ==",
      "dev": true,
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/template": {
      "version": "7.27.2",
      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.27.2.tgz",
      "integrity": "sha512-LPDZ85aEJyYSd18/DkjNh4/y1ntkE5KwUHWTiqgRxruuZL2F1yuHligVHLvcHY2vMHXttKFpJn6LwfI7cw7ODw==",
      "dev": true,
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/parser": "^7.27.2",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/traverse": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.28.0.tgz",
      "integrity": "sha512-mGe7UK5wWyh0bKRfupsUchrQGqvDbZDbKJw+kcRGSmdHVYrv+ltd0pnpDTVpiTqnaBru9iEvA8pz8W46v0Amwg==",
      "dev": true,
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/generator": "^7.28.0",
        "@babel/helper-globals": "^7.28.0",
        "@babel/parser": "^7.28.0",
        "@babel/template": "^7.27.2",
        "@babel/types": "^7.28.0",
        "debug": "^4.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/traverse/node_modules/debug": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.1.tgz",
      "integrity": "sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==",
      "dev": true,
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/@babel/traverse/node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true
    },
    "node_modules/@babel/types": {
      "version": "7.28.2",
      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.28.2.tgz",
      "integrity": "sha512-ruv7Ae4J5dUYULmeXw1gmb7rYRz57OWCPM57pHojnLq/3Z1CK2lNSLTCVjxVk1F/TZHwOZZrOWi0ur95BbLxNQ==",
      "dev": true,
      "dependencies": {
        "@babel/helper-string-parser": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@bcoe/v8-coverage": {
      "version": "0.2.3",
      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
      "dev": true
    },
    "node_modules/@colors/colors": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/@colors/colors/-/colors-1.6.0.tgz",
      "integrity": "sha512-Ir+AOibqzrIsL6ajt3Rz3LskB7OiMVHqltZmspbW/TJuTVuyOMirVqAkjfY6JISiLHgyNqicAC8AyHHGzNd/dA==",
      "engines": {
        "node": ">=0.1.90"
      }
    },
    "node_modules/@dabh/diagnostics": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/@dabh/diagnostics/-/diagnostics-2.0.3.tgz",
      "integrity": "sha512-hrlQOIi7hAfzsMqlGSFyVucrx38O+j6wiGOf//H2ecvIEqYN4ADBSS2iLMh5UFyDunCNniUIPk/q3riFv45xRA==",
      "dependencies": {
        "colorspace": "1.1.x",
        "enabled": "2.0.x",
        "kuler": "^2.0.0"
      }
    },
    "node_modules/@eslint-community/eslint-utils": {
      "version": "4.7.0",
      "resolved": "https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.7.0.tgz",
      "integrity": "sha512-dyybb3AcajC7uha6CvhdVRJqaKyn7w2YKqKyAN37NKYgZT36w+iRb0Dymmc5qEJ549c/S31cMMSFd75bteCpCw==",
      "dev": true,
      "dependencies": {
        "eslint-visitor-keys": "^3.4.3"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      },
      "peerDependencies": {
        "eslint": "^6.0.0 || ^7.0.0 || >=8.0.0"
      }
    },
    "node_modules/@eslint-community/regexpp": {
      "version": "4.12.1",
      "resolved": "https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.12.1.tgz",
      "integrity": "sha512-CCZCDJuduB9OUkFkY2IgppNZMi2lBQgD2qzwXkEia16cge2pijY/aXi96CJMquDMn3nJdlPV1A5KrJEXwfLNzQ==",
      "dev": true,
      "engines": {
        "node": "^12.0.0 || ^14.0.0 || >=16.0.0"
      }
    },
    "node_modules/@eslint/eslintrc": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-2.1.4.tgz",
      "integrity": "sha512-269Z39MS6wVJtsoUl10L60WdkhJVdPG24Q4eZTH3nnF6lpvSShEK3wQjDX9JRWAUPvPh7COouPpU9IrqaZFvtQ==",
      "dev": true,
      "dependencies": {
        "ajv": "^6.12.4",
        "debug": "^4.3.2",
        "espree": "^9.6.0",
        "globals": "^13.19.0",
        "ignore": "^5.2.0",
        "import-fresh": "^3.2.1",
        "js-yaml": "^4.1.0",
        "minimatch": "^3.1.2",
        "strip-json-comments": "^3.1.1"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint/eslintrc/node_modules/debug": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.1.tgz",
      "integrity": "sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==",
      "dev": true,
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/@eslint/eslintrc/node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true
    },
    "node_modules/@eslint/js": {
      "version": "8.57.1",
      "resolved": "https://registry.npmjs.org/@eslint/js/-/js-8.57.1.tgz",
      "integrity": "sha512-d9zaMRSTIKDLhctzH12MtXvJKSSUhaHcjV+2Z+GK+EEY7XKpP5yR4x+N3TAcHTcu963nIr+TMcCb4DBCYX1z6Q==",
      "dev": true,
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      }
    },
    "node_modules/@faker-js/faker": {
      "version": "8.4.1",
      "resolved": "https://registry.npmjs.org/@faker-js/faker/-/faker-8.4.1.tgz",
      "integrity": "sha512-XQ3cU+Q8Uqmrbf2e0cIC/QN43sTBSC8KF12u29Mb47tWrt2hAgBXSgpZMj4Ao8Uk0iJcU99QsOCaIL8934obCg==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/fakerjs"
        }
      ],
      "engines": {
        "node": "^14.17.0 || ^16.13.0 || >=18.0.0",
        "npm": ">=6.14.13"
      }
    },
    "node_modules/@hapi/hoek": {
      "version": "9.3.0",
      "resolved": "https://registry.npmjs.org/@hapi/hoek/-/hoek-9.3.0.tgz",
      "integrity": "sha512-/c6rf4UJlmHlC9b5BaNvzAcFv7HZ2QHaV0D4/HNlBdvFnvQq8RI4kYdhyPCl7Xj+oWvTWQ8ujhqS53LIgAe6KQ=="
    },
    "node_modules/@hapi/topo": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/@hapi/topo/-/topo-5.1.0.tgz",
      "integrity": "sha512-foQZKJig7Ob0BMAYBfcJk8d77QtOe7Wo4ox7ff1lQYoNNAb6jwcY1ncdoy2e9wQZzvNy7ODZCYJkK8kzmcAnAg==",
      "dependencies": {
        "@hapi/hoek": "^9.0.0"
      }
    },
    "node_modules/@humanwhocodes/config-array": {
      "version": "0.13.0",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/config-array/-/config-array-0.13.0.tgz",
      "integrity": "sha512-DZLEEqFWQFiyK6h5YIeynKx7JlvCYWL0cImfSRXZ9l4Sg2efkFGTuFf6vzXjK1cq6IYkU+Eg/JizXw+TD2vRNw==",
      "deprecated": "Use @eslint/config-array instead",
      "dev": true,
      "dependencies": {
        "@humanwhocodes/object-schema": "^2.0.3",
        "debug": "^4.3.1",
        "minimatch": "^3.0.5"
      },
      "engines": {
        "node": ">=10.10.0"
      }
    },
    "node_modules/@humanwhocodes/config-array/node_modules/debug": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.1.tgz",
      "integrity": "sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==",
      "dev": true,
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/@humanwhocodes/config-array/node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true
    },
    "node_modules/@humanwhocodes/module-importer": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/module-importer/-/module-importer-1.0.1.tgz",
      "integrity": "sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==",
      "dev": true,
      "engines": {
        "node": ">=12.22"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@humanwhocodes/object-schema": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/object-schema/-/object-schema-2.0.3.tgz",
      "integrity": "sha512-93zYdMES/c1D69yZiKDBj0V24vqNzB/koF26KPaagAfd3P/4gUlh3Dys5ogAK+Exi9QyzlD8x/08Zt7wIKcDcA==",
      "deprecated": "Use @eslint/object-schema instead",
      "dev": true
    },
    "node_modules/@ioredis/commands": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/@ioredis/commands/-/commands-1.3.0.tgz",
      "integrity": "sha512-M/T6Zewn7sDaBQEqIZ8Rb+i9y8qfGmq+5SDFSf9sA2lUZTmdDLVdOiQaeDp+Q4wElZ9HG1GAX5KhDaidp6LQsQ=="
    },
    "node_modules/@istanbuljs/load-nyc-config": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@istanbuljs/load-nyc-config/-/load-nyc-config-1.1.0.tgz",
      "integrity": "sha512-VjeHSlIzpv/NyD3N0YuHfXOPDIixcA1q2ZV98wsMqcYlPmv2n3Yb2lYP9XMElnaFVXg5A7YLTeLu6V84uQDjmQ==",
      "dev": true,
      "dependencies": {
        "camelcase": "^5.3.1",
        "find-up": "^4.1.0",
        "get-package-type": "^0.1.0",
        "js-yaml": "^3.13.1",
        "resolve-from": "^5.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/@istanbuljs/load-nyc-config/node_modules/argparse": {
      "version": "1.0.10",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz",
      "integrity": "sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==",
      "dev": true,
      "dependencies": {
        "sprintf-js": "~1.0.2"
      }
    },
    "node_modules/@istanbuljs/load-nyc-config/node_modules/find-up": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-4.1.0.tgz",
      "integrity": "sha512-PpOwAdQ/YlXQ2vj8a3h8IipDuYRi3wceVQQGYWxNINccq40Anw7BlsEXCMbt1Zt+OLA6Fq9suIpIWD0OsnISlw==",
      "dev": true,
      "dependencies": {
        "locate-path": "^5.0.0",
        "path-exists": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/@istanbuljs/load-nyc-config/node_modules/js-yaml": {
      "version": "3.14.1",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-3.14.1.tgz",
      "integrity": "sha512-okMH7OXXJ7YrN9Ok3/SXrnu4iX9yOk+25nqX4imS2npuvTYDmo/QEZoqwZkYaIDk3jVvBOTOIEgEhaLOynBS9g==",
      "dev": true,
      "dependencies": {
        "argparse": "^1.0.7",
        "esprima": "^4.0.0"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/@istanbuljs/load-nyc-config/node_modules/locate-path": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-5.0.0.tgz",
      "integrity": "sha512-t7hw9pI+WvuwNJXwk5zVHpyhIqzg2qTlklJOf0mVxGSbe3Fp2VieZcduNYjaLDoy6p9uGpQEGWG87WpMKlNq8g==",
      "dev": true,
      "dependencies": {
        "p-locate": "^4.1.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/@istanbuljs/load-nyc-config/node_modules/p-limit": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-2.3.0.tgz",
      "integrity": "sha512-//88mFWSJx8lxCzwdAABTJL2MyWB12+eIY7MDL2SqLmAkeKU9qxRvWuSyTjm3FUmpBEMuFfckAIqEaVGUDxb6w==",
      "dev": true,
      "dependencies": {
        "p-try": "^2.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/@istanbuljs/load-nyc-config/node_modules/p-locate": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-4.1.0.tgz",
      "integrity": "sha512-R79ZZ/0wAxKGu3oYMlz8jy/kbhsNrS7SKZ7PxEHBgJ5+F2mtFW2fK2cOtBh1cHYkQsbzFV7I+EoRKe6Yt0oK7A==",
      "dev": true,
      "dependencies": {
        "p-limit": "^2.2.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/@istanbuljs/load-nyc-config/node_modules/resolve-from": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-5.0.0.tgz",
      "integrity": "sha512-qYg9KP24dD5qka9J47d0aVky0N+b4fTU89LN9iDnjB5waksiC49rvMB0PrUJQGoTmH50XPiqOvAjDfaijGxYZw==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/@istanbuljs/schema": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/@jest/console": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/console/-/console-29.7.0.tgz",
      "integrity": "sha512-5Ni4CU7XHQi32IJ398EEP4RrB8eV09sXP2ROqD4bksHrnTree52PsxvX8tpL8LvTZ3pFzXyPbNQReSN41CAhOg==",
      "dev": true,
      "dependencies": {
        "@jest/types": "^29.6.3",
        "@types/node": "*",
        "chalk": "^4.0.0",
        "jest-message-util": "^29.7.0",
        "jest-util": "^29.7.0",
        "slash": "^3.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/core": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/core/-/core-29.7.0.tgz",
      "integrity": "sha512-n7aeXWKMnGtDA48y8TLWJPJmLmmZ642Ceo78cYWEpiD7FzDgmNDV/GCVRorPABdXLJZ/9wzzgZAlHjXjxDHGsg==",
      "dev": true,
      "dependencies": {
        "@jest/console": "^29.7.0",
        "@jest/reporters": "^29.7.0",
        "@jest/test-result": "^29.7.0",
        "@jest/transform": "^29.7.0",
        "@jest/types": "^29.6.3",
        "@types/node": "*",
        "ansi-escapes": "^4.2.1",
        "chalk": "^4.0.0",
        "ci-info": "^3.2.0",
        "exit": "^0.1.2",
        "graceful-fs": "^4.2.9",
        "jest-changed-files": "^29.7.0",
        "jest-config": "^29.7.0",
        "jest-haste-map": "^29.7.0",
        "jest-message-util": "^29.7.0",
        "jest-regex-util": "^29.6.3",
        "jest-resolve": "^29.7.0",
        "jest-resolve-dependencies": "^29.7.0",
        "jest-runner": "^29.7.0",
        "jest-runtime": "^29.7.0",
        "jest-snapshot": "^29.7.0",
        "jest-util": "^29.7.0",
        "jest-validate": "^29.7.0",
        "jest-watcher": "^29.7.0",
        "micromatch": "^4.0.4",
        "pretty-format": "^29.7.0",
        "slash": "^3.0.0",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "peerDependencies": {
        "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
      },
      "peerDependenciesMeta": {
        "node-notifier": {
          "optional": true
        }
      }
    },
    "node_modules/@jest/environment": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/environment/-/environment-29.7.0.tgz",
      "integrity": "sha512-aQIfHDq33ExsN4jP1NWGXhxgQ/wixs60gDiKO+XVMd8Mn0NWPWgc34ZQDTb2jKaUWQ7MuwoitXAsN2XVXNMpAw==",
      "dev": true,
      "dependencies": {
        "@jest/fake-timers": "^29.7.0",
        "@jest/types": "^29.6.3",
        "@types/node": "*",
        "jest-mock": "^29.7.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/expect": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/expect/-/expect-29.7.0.tgz",
      "integrity": "sha512-8uMeAMycttpva3P1lBHB8VciS9V0XAr3GymPpipdyQXbBcuhkLQOSe8E/p92RyAdToS6ZD1tFkX+CkhoECE0dQ==",
      "dev": true,
      "dependencies": {
        "expect": "^29.7.0",
        "jest-snapshot": "^29.7.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/expect-utils": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/expect-utils/-/expect-utils-29.7.0.tgz",
      "integrity": "sha512-GlsNBWiFQFCVi9QVSx7f5AgMeLxe9YCCs5PuP2O2LdjDAA8Jh9eX7lA1Jq/xdXw3Wb3hyvlFNfZIfcRetSzYcA==",
      "dev": true,
      "dependencies": {
        "jest-get-type": "^29.6.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/fake-timers": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/fake-timers/-/fake-timers-29.7.0.tgz",
      "integrity": "sha512-q4DH1Ha4TTFPdxLsqDXK1d3+ioSL7yL5oCMJZgDYm6i+6CygW5E5xVr/D1HdsGxjt1ZWSfUAs9OxSB/BNelWrQ==",
      "dev": true,
      "dependencies": {
        "@jest/types": "^29.6.3",
        "@sinonjs/fake-timers": "^10.0.2",
        "@types/node": "*",
        "jest-message-util": "^29.7.0",
        "jest-mock": "^29.7.0",
        "jest-util": "^29.7.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/globals": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/globals/-/globals-29.7.0.tgz",
      "integrity": "sha512-mpiz3dutLbkW2MNFubUGUEVLkTGiqW6yLVTA+JbP6fI6J5iL9Y0Nlg8k95pcF8ctKwCS7WVxteBs29hhfAotzQ==",
      "dev": true,
      "dependencies": {
        "@jest/environment": "^29.7.0",
        "@jest/expect": "^29.7.0",
        "@jest/types": "^29.6.3",
        "jest-mock": "^29.7.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/reporters": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/reporters/-/reporters-29.7.0.tgz",
      "integrity": "sha512-DApq0KJbJOEzAFYjHADNNxAE3KbhxQB1y5Kplb5Waqw6zVbuWatSnMjE5gs8FUgEPmNsnZA3NCWl9NG0ia04Pg==",
      "dev": true,
      "dependencies": {
        "@bcoe/v8-coverage": "^0.2.3",
        "@jest/console": "^29.7.0",
        "@jest/test-result": "^29.7.0",
        "@jest/transform": "^29.7.0",
        "@jest/types": "^29.6.3",
        "@jridgewell/trace-mapping": "^0.3.18",
        "@types/node": "*",
        "chalk": "^4.0.0",
        "collect-v8-coverage": "^1.0.0",
        "exit": "^0.1.2",
        "glob": "^7.1.3",
        "graceful-fs": "^4.2.9",
        "istanbul-lib-coverage": "^3.0.0",
        "istanbul-lib-instrument": "^6.0.0",
        "istanbul-lib-report": "^3.0.0",
        "istanbul-lib-source-maps": "^4.0.0",
        "istanbul-reports": "^3.1.3",
        "jest-message-util": "^29.7.0",
        "jest-util": "^29.7.0",
        "jest-worker": "^29.7.0",
        "slash": "^3.0.0",
        "string-length": "^4.0.1",
        "strip-ansi": "^6.0.0",
        "v8-to-istanbul": "^9.0.1"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "peerDependencies": {
        "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
      },
      "peerDependenciesMeta": {
        "node-notifier": {
          "optional": true
        }
      }
    },
    "node_modules/@jest/schemas": {
      "version": "29.6.3",
      "resolved": "https://registry.npmjs.org/@jest/schemas/-/schemas-29.6.3.tgz",
      "integrity": "sha512-mo5j5X+jIZmJQveBKeS/clAueipV7KgiX1vMgCxam1RNYiqE1w62n0/tJJnHtjW8ZHcQco5gY85jA3mi0L+nSA==",
      "dev": true,
      "dependencies": {
        "@sinclair/typebox": "^0.27.8"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/source-map": {
      "version": "29.6.3",
      "resolved": "https://registry.npmjs.org/@jest/source-map/-/source-map-29.6.3.tgz",
      "integrity": "sha512-MHjT95QuipcPrpLM+8JMSzFx6eHp5Bm+4XeFDJlwsvVBjmKNiIAvasGK2fxz2WbGRlnvqehFbh07MMa7n3YJnw==",
      "dev": true,
      "dependencies": {
        "@jridgewell/trace-mapping": "^0.3.18",
        "callsites": "^3.0.0",
        "graceful-fs": "^4.2.9"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/test-result": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/test-result/-/test-result-29.7.0.tgz",
      "integrity": "sha512-Fdx+tv6x1zlkJPcWXmMDAG2HBnaR9XPSd5aDWQVsfrZmLVT3lU1cwyxLgRmXR9yrq4NBoEm9BMsfgFzTQAbJYA==",
      "dev": true,
      "dependencies": {
        "@jest/console": "^29.7.0",
        "@jest/types": "^29.6.3",
        "@types/istanbul-lib-coverage": "^2.0.0",
        "collect-v8-coverage": "^1.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/test-sequencer": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/test-sequencer/-/test-sequencer-29.7.0.tgz",
      "integrity": "sha512-GQwJ5WZVrKnOJuiYiAF52UNUJXgTZx1NHjFSEB0qEMmSZKAkdMoIzw/Cj6x6NF4AvV23AUqDpFzQkN/eYCYTxw==",
      "dev": true,
      "dependencies": {
        "@jest/test-result": "^29.7.0",
        "graceful-fs": "^4.2.9",
        "jest-haste-map": "^29.7.0",
        "slash": "^3.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/transform": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/transform/-/transform-29.7.0.tgz",
      "integrity": "sha512-ok/BTPFzFKVMwO5eOHRrvnBVHdRy9IrsrW1GpMaQ9MCnilNLXQKmAX8s1YXDFaai9xJpac2ySzV0YeRRECr2Vw==",
      "dev": true,
      "dependencies": {
        "@babel/core": "^7.11.6",
        "@jest/types": "^29.6.3",
        "@jridgewell/trace-mapping": "^0.3.18",
        "babel-plugin-istanbul": "^6.1.1",
        "chalk": "^4.0.0",
        "convert-source-map": "^2.0.0",
        "fast-json-stable-stringify": "^2.1.0",
        "graceful-fs": "^4.2.9",
        "jest-haste-map": "^29.7.0",
        "jest-regex-util": "^29.6.3",
        "jest-util": "^29.7.0",
        "micromatch": "^4.0.4",
        "pirates": "^4.0.4",
        "slash": "^3.0.0",
        "write-file-atomic": "^4.0.2"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/types": {
      "version": "29.6.3",
      "resolved": "https://registry.npmjs.org/@jest/types/-/types-29.6.3.tgz",
      "integrity": "sha512-u3UPsIilWKOM3F9CXtrG8LEJmNxwoCQC/XVj4IKYXvvpx7QIi/Kg1LI5uDmDpKlac62NUtX7eLjRh+jVZcLOzw==",
      "dev": true,
      "dependencies": {
        "@jest/schemas": "^29.6.3",
        "@types/istanbul-lib-coverage": "^2.0.0",
        "@types/istanbul-reports": "^3.0.0",
        "@types/node": "*",
        "@types/yargs": "^17.0.8",
        "chalk": "^4.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.12",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.12.tgz",
      "integrity": "sha512-OuLGC46TjB5BbN1dH8JULVVZY4WTdkF7tV9Ys6wLL1rubZnCMstOhNHueU5bLCrnRuDhKPDM4g6sw4Bel5Gzqg==",
      "dev": true,
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.0",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "dev": true,
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.4",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.4.tgz",
      "integrity": "sha512-VT2+G1VQs/9oz078bLrYbecdZKs912zQlkelYpuf+SXF+QvZDYJlbx/LSx+meSAwdDFnF8FVXW92AVjjkVmgFw==",
      "dev": true
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.29",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.29.tgz",
      "integrity": "sha512-uw6guiW/gcAGPDhLmd77/6lW8QLeiV5RUTsAX46Db6oLhGaVj4lhnPwb184s1bkc8kdVg/+h988dro8GRDpmYQ==",
      "dev": true,
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.1.0",
        "@jridgewell/sourcemap-codec": "^1.4.14"
      }
    },
    "node_modules/@jsdevtools/ono": {
      "version": "7.1.3",
      "resolved": "https://registry.npmjs.org/@jsdevtools/ono/-/ono-7.1.3.tgz",
      "integrity": "sha512-4JQNk+3mVzK3xh2rqd6RB4J46qUR19azEHBneZyTZM+c456qOrbbM/5xcR8huNCCcbVt7+UmizG6GuUvPvKUYg=="
    },
    "node_modules/@noble/hashes": {
      "version": "1.8.0",
      "resolved": "https://registry.npmjs.org/@noble/hashes/-/hashes-1.8.0.tgz",
      "integrity": "sha512-jCs9ldd7NwzpgXDIf6P3+NrHh9/sD6CQdxHyjQI+h/6rDNo88ypBxxz45UDuZHz9r3tNz7N/VInSVoVdtXEI4A==",
      "dev": true,
      "engines": {
        "node": "^14.21.3 || >=16"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      }
    },
    "node_modules/@nodelib/fs.scandir": {
      "version": "2.1.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
      "integrity": "sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==",
      "dev": true,
      "dependencies": {
        "@nodelib/fs.stat": "2.0.5",
        "run-parallel": "^1.1.9"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.stat": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz",
      "integrity": "sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==",
      "dev": true,
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.walk": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz",
      "integrity": "sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==",
      "dev": true,
      "dependencies": {
        "@nodelib/fs.scandir": "2.1.5",
        "fastq": "^1.6.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@opentelemetry/api": {
      "version": "1.9.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/api/-/api-1.9.0.tgz",
      "integrity": "sha512-3giAOQvZiH5F9bMlMiv8+GSPMeqg0dbaeo58/0SlA9sxSqZhnUtxzX9/2FzyhS9sWQf5S0GJE0AKBrFqjpeYcg==",
      "dev": true,
      "engines": {
        "node": ">=8.0.0"
      }
    },
    "node_modules/@opentelemetry/api-logs": {
      "version": "0.203.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/api-logs/-/api-logs-0.203.0.tgz",
      "integrity": "sha512-9B9RU0H7Ya1Dx/Rkyc4stuBZSGVQF27WigitInx2QQoj6KUpEFYPKoWjdFTunJYxmXmh17HeBvbMa1EhGyPmqQ==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/api": "^1.3.0"
      },
      "engines": {
        "node": ">=8.0.0"
      }
    },
    "node_modules/@opentelemetry/context-async-hooks": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/@opentelemetry/context-async-hooks/-/context-async-hooks-2.0.1.tgz",
      "integrity": "sha512-XuY23lSI3d4PEqKA+7SLtAgwqIfc6E/E9eAQWLN1vlpC53ybO3o6jW4BsXo1xvz9lYyyWItfQDDLzezER01mCw==",
      "dev": true,
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": ">=1.0.0 <1.10.0"
      }
    },
    "node_modules/@opentelemetry/core": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/@opentelemetry/core/-/core-2.0.1.tgz",
      "integrity": "sha512-MaZk9SJIDgo1peKevlbhP6+IwIiNPNmswNL4AF0WaQJLbHXjr9SrZMgS12+iqr9ToV4ZVosCcc0f8Rg67LXjxw==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/semantic-conventions": "^1.29.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": ">=1.0.0 <1.10.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation": {
      "version": "0.203.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation/-/instrumentation-0.203.0.tgz",
      "integrity": "sha512-ke1qyM+3AK2zPuBPb6Hk/GCsc5ewbLvPNkEuELx/JmANeEp6ZjnZ+wypPAJSucTw0wvCGrUaibDSdcrGFoWxKQ==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/api-logs": "0.203.0",
        "import-in-the-middle": "^1.8.1",
        "require-in-the-middle": "^7.1.1"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-amqplib": {
      "version": "0.50.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-amqplib/-/instrumentation-amqplib-0.50.0.tgz",
      "integrity": "sha512-kwNs/itehHG/qaQBcVrLNcvXVPW0I4FCOVtw3LHMLdYIqD7GJ6Yv2nX+a4YHjzbzIeRYj8iyMp0Bl7tlkidq5w==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/core": "^2.0.0",
        "@opentelemetry/instrumentation": "^0.203.0",
        "@opentelemetry/semantic-conventions": "^1.27.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-connect": {
      "version": "0.47.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-connect/-/instrumentation-connect-0.47.0.tgz",
      "integrity": "sha512-pjenvjR6+PMRb6/4X85L4OtkQCootgb/Jzh/l/Utu3SJHBid1F+gk9sTGU2FWuhhEfV6P7MZ7BmCdHXQjgJ42g==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/core": "^2.0.0",
        "@opentelemetry/instrumentation": "^0.203.0",
        "@opentelemetry/semantic-conventions": "^1.27.0",
        "@types/connect": "3.4.38"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-dataloader": {
      "version": "0.21.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-dataloader/-/instrumentation-dataloader-0.21.0.tgz",
      "integrity": "sha512-Xu4CZ1bfhdkV3G6iVHFgKTgHx8GbKSqrTU01kcIJRGHpowVnyOPEv1CW5ow+9GU2X4Eki8zoNuVUenFc3RluxQ==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/instrumentation": "^0.203.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-express": {
      "version": "0.52.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-express/-/instrumentation-express-0.52.0.tgz",
      "integrity": "sha512-W7pizN0Wh1/cbNhhTf7C62NpyYw7VfCFTYg0DYieSTrtPBT1vmoSZei19wfKLnrMsz3sHayCg0HxCVL2c+cz5w==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/core": "^2.0.0",
        "@opentelemetry/instrumentation": "^0.203.0",
        "@opentelemetry/semantic-conventions": "^1.27.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-fs": {
      "version": "0.23.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-fs/-/instrumentation-fs-0.23.0.tgz",
      "integrity": "sha512-Puan+QopWHA/KNYvDfOZN6M/JtF6buXEyD934vrb8WhsX1/FuM7OtoMlQyIqAadnE8FqqDL4KDPiEfCQH6pQcQ==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/core": "^2.0.0",
        "@opentelemetry/instrumentation": "^0.203.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-generic-pool": {
      "version": "0.47.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-generic-pool/-/instrumentation-generic-pool-0.47.0.tgz",
      "integrity": "sha512-UfHqf3zYK+CwDwEtTjaD12uUqGGTswZ7ofLBEdQ4sEJp9GHSSJMQ2hT3pgBxyKADzUdoxQAv/7NqvL42ZI+Qbw==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/instrumentation": "^0.203.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-graphql": {
      "version": "0.51.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-graphql/-/instrumentation-graphql-0.51.0.tgz",
      "integrity": "sha512-LchkOu9X5DrXAnPI1+Z06h/EH/zC7D6sA86hhPrk3evLlsJTz0grPrkL/yUJM9Ty0CL/y2HSvmWQCjbJEz/ADg==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/instrumentation": "^0.203.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-hapi": {
      "version": "0.50.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-hapi/-/instrumentation-hapi-0.50.0.tgz",
      "integrity": "sha512-5xGusXOFQXKacrZmDbpHQzqYD1gIkrMWuwvlrEPkYOsjUqGUjl1HbxCsn5Y9bUXOCgP1Lj6A4PcKt1UiJ2MujA==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/core": "^2.0.0",
        "@opentelemetry/instrumentation": "^0.203.0",
        "@opentelemetry/semantic-conventions": "^1.27.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-http": {
      "version": "0.203.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-http/-/instrumentation-http-0.203.0.tgz",
      "integrity": "sha512-y3uQAcCOAwnO6vEuNVocmpVzG3PER6/YZqbPbbffDdJ9te5NkHEkfSMNzlC3+v7KlE+WinPGc3N7MR30G1HY2g==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/core": "2.0.1",
        "@opentelemetry/instrumentation": "0.203.0",
        "@opentelemetry/semantic-conventions": "^1.29.0",
        "forwarded-parse": "2.1.2"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-ioredis": {
      "version": "0.51.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-ioredis/-/instrumentation-ioredis-0.51.0.tgz",
      "integrity": "sha512-9IUws0XWCb80NovS+17eONXsw1ZJbHwYYMXiwsfR9TSurkLV5UNbRSKb9URHO+K+pIJILy9wCxvyiOneMr91Ig==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/instrumentation": "^0.203.0",
        "@opentelemetry/redis-common": "^0.38.0",
        "@opentelemetry/semantic-conventions": "^1.27.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-kafkajs": {
      "version": "0.12.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-kafkajs/-/instrumentation-kafkajs-0.12.0.tgz",
      "integrity": "sha512-bIe4aSAAxytp88nzBstgr6M7ZiEpW6/D1/SuKXdxxuprf18taVvFL2H5BDNGZ7A14K27haHqzYqtCTqFXHZOYg==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/instrumentation": "^0.203.0",
        "@opentelemetry/semantic-conventions": "^1.30.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-knex": {
      "version": "0.48.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-knex/-/instrumentation-knex-0.48.0.tgz",
      "integrity": "sha512-V5wuaBPv/lwGxuHjC6Na2JFRjtPgstw19jTFl1B1b6zvaX8zVDYUDaR5hL7glnQtUSCMktPttQsgK4dhXpddcA==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/instrumentation": "^0.203.0",
        "@opentelemetry/semantic-conventions": "^1.33.1"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-koa": {
      "version": "0.51.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-koa/-/instrumentation-koa-0.51.0.tgz",
      "integrity": "sha512-XNLWeMTMG1/EkQBbgPYzCeBD0cwOrfnn8ao4hWgLv0fNCFQu1kCsJYygz2cvKuCs340RlnG4i321hX7R8gj3Rg==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/core": "^2.0.0",
        "@opentelemetry/instrumentation": "^0.203.0",
        "@opentelemetry/semantic-conventions": "^1.27.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-lru-memoizer": {
      "version": "0.48.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-lru-memoizer/-/instrumentation-lru-memoizer-0.48.0.tgz",
      "integrity": "sha512-KUW29wfMlTPX1wFz+NNrmE7IzN7NWZDrmFWHM/VJcmFEuQGnnBuTIdsP55CnBDxKgQ/qqYFp4udQFNtjeFosPw==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/instrumentation": "^0.203.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-mongodb": {
      "version": "0.56.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-mongodb/-/instrumentation-mongodb-0.56.0.tgz",
      "integrity": "sha512-YG5IXUUmxX3Md2buVMvxm9NWlKADrnavI36hbJsihqqvBGsWnIfguf0rUP5Srr0pfPqhQjUP+agLMsvu0GmUpA==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/instrumentation": "^0.203.0",
        "@opentelemetry/semantic-conventions": "^1.27.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-mongoose": {
      "version": "0.50.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-mongoose/-/instrumentation-mongoose-0.50.0.tgz",
      "integrity": "sha512-Am8pk1Ct951r4qCiqkBcGmPIgGhoDiFcRtqPSLbJrUZqEPUsigjtMjoWDRLG1Ki1NHgOF7D0H7d+suWz1AAizw==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/core": "^2.0.0",
        "@opentelemetry/instrumentation": "^0.203.0",
        "@opentelemetry/semantic-conventions": "^1.27.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-mysql": {
      "version": "0.49.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-mysql/-/instrumentation-mysql-0.49.0.tgz",
      "integrity": "sha512-QU9IUNqNsrlfE3dJkZnFHqLjlndiU39ll/YAAEvWE40sGOCi9AtOF6rmEGzJ1IswoZ3oyePV7q2MP8SrhJfVAA==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/instrumentation": "^0.203.0",
        "@opentelemetry/semantic-conventions": "^1.27.0",
        "@types/mysql": "2.15.27"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-mysql2": {
      "version": "0.49.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-mysql2/-/instrumentation-mysql2-0.49.0.tgz",
      "integrity": "sha512-dCub9wc02mkJWNyHdVEZ7dvRzy295SmNJa+LrAJY2a/+tIiVBQqEAajFzKwp9zegVVnel9L+WORu34rGLQDzxA==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/instrumentation": "^0.203.0",
        "@opentelemetry/semantic-conventions": "^1.27.0",
        "@opentelemetry/sql-common": "^0.41.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-pg": {
      "version": "0.55.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-pg/-/instrumentation-pg-0.55.0.tgz",
      "integrity": "sha512-yfJ5bYE7CnkW/uNsnrwouG/FR7nmg09zdk2MSs7k0ZOMkDDAE3WBGpVFFApGgNu2U+gtzLgEzOQG4I/X+60hXw==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/core": "^2.0.0",
        "@opentelemetry/instrumentation": "^0.203.0",
        "@opentelemetry/semantic-conventions": "^1.27.0",
        "@opentelemetry/sql-common": "^0.41.0",
        "@types/pg": "8.15.4",
        "@types/pg-pool": "2.0.6"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-redis": {
      "version": "0.51.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-redis/-/instrumentation-redis-0.51.0.tgz",
      "integrity": "sha512-uL/GtBA0u72YPPehwOvthAe+Wf8k3T+XQPBssJmTYl6fzuZjNq8zTfxVFhl9nRFjFVEe+CtiYNT0Q3AyqW1Z0A==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/instrumentation": "^0.203.0",
        "@opentelemetry/redis-common": "^0.38.0",
        "@opentelemetry/semantic-conventions": "^1.27.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-tedious": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-tedious/-/instrumentation-tedious-0.22.0.tgz",
      "integrity": "sha512-XrrNSUCyEjH1ax9t+Uo6lv0S2FCCykcF7hSxBMxKf7Xn0bPRxD3KyFUZy25aQXzbbbUHhtdxj3r2h88SfEM3aA==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/instrumentation": "^0.203.0",
        "@opentelemetry/semantic-conventions": "^1.27.0",
        "@types/tedious": "^4.0.14"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@opentelemetry/instrumentation-undici": {
      "version": "0.14.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation-undici/-/instrumentation-undici-0.14.0.tgz",
      "integrity": "sha512-2HN+7ztxAReXuxzrtA3WboAKlfP5OsPA57KQn2AdYZbJ3zeRPcLXyW4uO/jpLE6PLm0QRtmeGCmfYpqRlwgSwg==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/core": "^2.0.0",
        "@opentelemetry/instrumentation": "^0.203.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.7.0"
      }
    },
    "node_modules/@opentelemetry/redis-common": {
      "version": "0.38.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/redis-common/-/redis-common-0.38.0.tgz",
      "integrity": "sha512-4Wc0AWURII2cfXVVoZ6vDqK+s5n4K5IssdrlVrvGsx6OEOKdghKtJZqXAHWFiZv4nTDLH2/2fldjIHY8clMOjQ==",
      "dev": true,
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      }
    },
    "node_modules/@opentelemetry/resources": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/@opentelemetry/resources/-/resources-2.0.1.tgz",
      "integrity": "sha512-dZOB3R6zvBwDKnHDTB4X1xtMArB/d324VsbiPkX/Yu0Q8T2xceRthoIVFhJdvgVM2QhGVUyX9tzwiNxGtoBJUw==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/core": "2.0.1",
        "@opentelemetry/semantic-conventions": "^1.29.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": ">=1.3.0 <1.10.0"
      }
    },
    "node_modules/@opentelemetry/sdk-trace-base": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/@opentelemetry/sdk-trace-base/-/sdk-trace-base-2.0.1.tgz",
      "integrity": "sha512-xYLlvk/xdScGx1aEqvxLwf6sXQLXCjk3/1SQT9X9AoN5rXRhkdvIFShuNNmtTEPRBqcsMbS4p/gJLNI2wXaDuQ==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/core": "2.0.1",
        "@opentelemetry/resources": "2.0.1",
        "@opentelemetry/semantic-conventions": "^1.29.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": ">=1.3.0 <1.10.0"
      }
    },
    "node_modules/@opentelemetry/semantic-conventions": {
      "version": "1.36.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/semantic-conventions/-/semantic-conventions-1.36.0.tgz",
      "integrity": "sha512-TtxJSRD8Ohxp6bKkhrm27JRHAxPczQA7idtcTOMYI+wQRRrfgqxHv1cFbCApcSnNjtXkmzFozn6jQtFrOmbjPQ==",
      "dev": true,
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/@opentelemetry/sql-common": {
      "version": "0.41.0",
      "resolved": "https://registry.npmjs.org/@opentelemetry/sql-common/-/sql-common-0.41.0.tgz",
      "integrity": "sha512-pmzXctVbEERbqSfiAgdes9Y63xjoOyXcD7B6IXBkVb+vbM7M9U98mn33nGXxPf4dfYR0M+vhcKRZmbSJ7HfqFA==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/core": "^2.0.0"
      },
      "engines": {
        "node": "^18.19.0 || >=20.6.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.1.0"
      }
    },
    "node_modules/@paralleldrive/cuid2": {
      "version": "2.2.2",
      "resolved": "https://registry.npmjs.org/@paralleldrive/cuid2/-/cuid2-2.2.2.tgz",
      "integrity": "sha512-ZOBkgDwEdoYVlSeRbYYXs0S9MejQofiVYoTbKzy/6GQa39/q5tQU2IX46+shYnUkpEl3wc+J6wRlar7r2EK2xA==",
      "dev": true,
      "dependencies": {
        "@noble/hashes": "^1.1.5"
      }
    },
    "node_modules/@prisma/client": {
      "version": "5.22.0",
      "resolved": "https://registry.npmjs.org/@prisma/client/-/client-5.22.0.tgz",
      "integrity": "sha512-M0SVXfyHnQREBKxCgyo7sffrKttwE6R8PMq330MIUF0pTwjUhLbW84pFDlf06B27XyCR++VtjugEnIHdr07SVA==",
      "hasInstallScript": true,
      "engines": {
        "node": ">=16.13"
      },
      "peerDependencies": {
        "prisma": "*"
      },
      "peerDependenciesMeta": {
        "prisma": {
          "optional": true
        }
      }
    },
    "node_modules/@prisma/debug": {
      "version": "5.22.0",
      "resolved": "https://registry.npmjs.org/@prisma/debug/-/debug-5.22.0.tgz",
      "integrity": "sha512-AUt44v3YJeggO2ZU5BkXI7M4hu9BF2zzH2iF2V5pyXT/lRTyWiElZ7It+bRH1EshoMRxHgpYg4VB6rCM+mG5jQ=="
    },
    "node_modules/@prisma/engines": {
      "version": "5.22.0",
      "resolved": "https://registry.npmjs.org/@prisma/engines/-/engines-5.22.0.tgz",
      "integrity": "sha512-UNjfslWhAt06kVL3CjkuYpHAWSO6L4kDCVPegV6itt7nD1kSJavd3vhgAEhjglLJJKEdJ7oIqDJ+yHk6qO8gPA==",
      "hasInstallScript": true,
      "dependencies": {
        "@prisma/debug": "5.22.0",
        "@prisma/engines-version": "5.22.0-44.605197351a3c8bdd595af2d2a9bc3025bca48ea2",
        "@prisma/fetch-engine": "5.22.0",
        "@prisma/get-platform": "5.22.0"
      }
    },
    "node_modules/@prisma/engines-version": {
      "version": "5.22.0-44.605197351a3c8bdd595af2d2a9bc3025bca48ea2",
      "resolved": "https://registry.npmjs.org/@prisma/engines-version/-/engines-version-5.22.0-44.605197351a3c8bdd595af2d2a9bc3025bca48ea2.tgz",
      "integrity": "sha512-2PTmxFR2yHW/eB3uqWtcgRcgAbG1rwG9ZriSvQw+nnb7c4uCr3RAcGMb6/zfE88SKlC1Nj2ziUvc96Z379mHgQ=="
    },
    "node_modules/@prisma/fetch-engine": {
      "version": "5.22.0",
      "resolved": "https://registry.npmjs.org/@prisma/fetch-engine/-/fetch-engine-5.22.0.tgz",
      "integrity": "sha512-bkrD/Mc2fSvkQBV5EpoFcZ87AvOgDxbG99488a5cexp5Ccny+UM6MAe/UFkUC0wLYD9+9befNOqGiIJhhq+HbA==",
      "dependencies": {
        "@prisma/debug": "5.22.0",
        "@prisma/engines-version": "5.22.0-44.605197351a3c8bdd595af2d2a9bc3025bca48ea2",
        "@prisma/get-platform": "5.22.0"
      }
    },
    "node_modules/@prisma/get-platform": {
      "version": "5.22.0",
      "resolved": "https://registry.npmjs.org/@prisma/get-platform/-/get-platform-5.22.0.tgz",
      "integrity": "sha512-pHhpQdr1UPFpt+zFfnPazhulaZYCUqeIcPpJViYoq9R+D/yw4fjE+CtnsnKzPYm0ddUbeXUzjGVGIRVgPDCk4Q==",
      "dependencies": {
        "@prisma/debug": "5.22.0"
      }
    },
    "node_modules/@prisma/instrumentation": {
      "version": "6.13.0",
      "resolved": "https://registry.npmjs.org/@prisma/instrumentation/-/instrumentation-6.13.0.tgz",
      "integrity": "sha512-b97b0sBycGh89RQcqobSgjGl3jwPaC5cQIOFod6EX1v0zIxlXPmL3ckSXxoHpy+Js0QV/tgCzFvqicMJCtezBA==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/instrumentation": "^0.52.0 || ^0.53.0 || ^0.54.0 || ^0.55.0 || ^0.56.0 || ^0.57.0"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.8"
      }
    },
    "node_modules/@prisma/instrumentation/node_modules/@opentelemetry/api-logs": {
      "version": "0.57.2",
      "resolved": "https://registry.npmjs.org/@opentelemetry/api-logs/-/api-logs-0.57.2.tgz",
      "integrity": "sha512-uIX52NnTM0iBh84MShlpouI7UKqkZ7MrUszTmaypHBu4r7NofznSnQRfJ+uUeDtQDj6w8eFGg5KBLDAwAPz1+A==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/api": "^1.3.0"
      },
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation": {
      "version": "0.57.2",
      "resolved": "https://registry.npmjs.org/@opentelemetry/instrumentation/-/instrumentation-0.57.2.tgz",
      "integrity": "sha512-BdBGhQBh8IjZ2oIIX6F2/Q3LKm/FDDKi6ccYKcBTeilh6SNdNKveDOLk73BkSJjQLJk6qe4Yh+hHw1UPhCDdrg==",
      "dev": true,
      "dependencies": {
        "@opentelemetry/api-logs": "0.57.2",
        "@types/shimmer": "^1.2.0",
        "import-in-the-middle": "^1.8.1",
        "require-in-the-middle": "^7.1.1",
        "semver": "^7.5.2",
        "shimmer": "^1.2.1"
      },
      "engines": {
        "node": ">=14"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.3.0"
      }
    },
    "node_modules/@prisma/instrumentation/node_modules/semver": {
      "version": "7.7.2",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.2.tgz",
      "integrity": "sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==",
      "dev": true,
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/@redis/bloom": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@redis/bloom/-/bloom-1.2.0.tgz",
      "integrity": "sha512-HG2DFjYKbpNmVXsa0keLHp/3leGJz1mjh09f2RLGGLQZzSHpkmZWuwJbAvo3QcRY8p80m5+ZdXZdYOSBLlp7Cg==",
      "peerDependencies": {
        "@redis/client": "^1.0.0"
      }
    },
    "node_modules/@redis/client": {
      "version": "1.6.1",
      "resolved": "https://registry.npmjs.org/@redis/client/-/client-1.6.1.tgz",
      "integrity": "sha512-/KCsg3xSlR+nCK8/8ZYSknYxvXHwubJrU82F3Lm1Fp6789VQ0/3RJKfsmRXjqfaTA++23CvC3hqmqe/2GEt6Kw==",
      "dependencies": {
        "cluster-key-slot": "1.1.2",
        "generic-pool": "3.9.0",
        "yallist": "4.0.0"
      },
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/@redis/client/node_modules/yallist": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
      "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A=="
    },
    "node_modules/@redis/graph": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@redis/graph/-/graph-1.1.1.tgz",
      "integrity": "sha512-FEMTcTHZozZciLRl6GiiIB4zGm5z5F3F6a6FZCyrfxdKOhFlGkiAqlexWMBzCi4DcRoyiOsuLfW+cjlGWyExOw==",
      "peerDependencies": {
        "@redis/client": "^1.0.0"
      }
    },
    "node_modules/@redis/json": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/@redis/json/-/json-1.0.7.tgz",
      "integrity": "sha512-6UyXfjVaTBTJtKNG4/9Z8PSpKE6XgSyEb8iwaqDcy+uKrd/DGYHTWkUdnQDyzm727V7p21WUMhsqz5oy65kPcQ==",
      "peerDependencies": {
        "@redis/client": "^1.0.0"
      }
    },
    "node_modules/@redis/search": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@redis/search/-/search-1.2.0.tgz",
      "integrity": "sha512-tYoDBbtqOVigEDMAcTGsRlMycIIjwMCgD8eR2t0NANeQmgK/lvxNAvYyb6bZDD4frHRhIHkJu2TBRvB0ERkOmw==",
      "peerDependencies": {
        "@redis/client": "^1.0.0"
      }
    },
    "node_modules/@redis/time-series": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@redis/time-series/-/time-series-1.1.0.tgz",
      "integrity": "sha512-c1Q99M5ljsIuc4YdaCwfUEXsofakb9c8+Zse2qxTadu8TalLXuAESzLvFAvNVbkmSlvlzIQOLpBCmWI9wTOt+g==",
      "peerDependencies": {
        "@redis/client": "^1.0.0"
      }
    },
    "node_modules/@rtsao/scc": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@rtsao/scc/-/scc-1.1.0.tgz",
      "integrity": "sha512-zt6OdqaDoOnJ1ZYsCYGt9YmWzDXl4vQdKTyJev62gFhRGKdx7mcT54V9KIjg+d2wi9EXsPvAPKe7i7WjfVWB8g==",
      "dev": true
    },
    "node_modules/@scarf/scarf": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/@scarf/scarf/-/scarf-1.4.0.tgz",
      "integrity": "sha512-xxeapPiUXdZAE3che6f3xogoJPeZgig6omHEy1rIY5WVsB3H2BHNnZH+gHG6x91SCWyQCzWGsuL2Hh3ClO5/qQ==",
      "hasInstallScript": true
    },
    "node_modules/@sendgrid/client": {
      "version": "8.1.5",
      "resolved": "https://registry.npmjs.org/@sendgrid/client/-/client-8.1.5.tgz",
      "integrity": "sha512-Jqt8aAuGIpWGa15ZorTWI46q9gbaIdQFA21HIPQQl60rCjzAko75l3D1z7EyjFrNr4MfQ0StusivWh8Rjh10Cg==",
      "dependencies": {
        "@sendgrid/helpers": "^8.0.0",
        "axios": "^1.8.2"
      },
      "engines": {
        "node": ">=12.*"
      }
    },
    "node_modules/@sendgrid/helpers": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/@sendgrid/helpers/-/helpers-8.0.0.tgz",
      "integrity": "sha512-Ze7WuW2Xzy5GT5WRx+yEv89fsg/pgy3T1E3FS0QEx0/VvRmigMZ5qyVGhJz4SxomegDkzXv/i0aFPpHKN8qdAA==",
      "dependencies": {
        "deepmerge": "^4.2.2"
      },
      "engines": {
        "node": ">= 12.0.0"
      }
    },
    "node_modules/@sendgrid/mail": {
      "version": "8.1.5",

... [File troncato - mostrate solo le prime 2000 righe su 11499 totali] ...
```

---

### üìÑ `../backend/package.json`

**üìè Dimensione:** 2.8 KB | **üìù Righe:** 105

```json
{
  "name": "ugo-backend",
  "version": "1.0.0",
  "description": "Backend completo per Il Meraviglioso Mondo di Ugo",
  "main": "src/server.js",
  "scripts": {
    "start": "node src/server.js",
    "dev": "nodemon src/server.js",
    "test": "jest --runInBand --detectOpenHandles --testPathPattern=backend/tests/",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "migrate": "npx prisma migrate dev",
    "migrate:prod": "npx prisma migrate deploy",
    "seed": "npx prisma db seed",
    "generate": "npx prisma generate",
    "studio": "npx prisma studio",
    "lint": "eslint src/",
    "lint:fix": "eslint src/ --fix",
    "docker:build": "docker build -t ugo-backend .",
    "docker:run": "docker run -p 3000:3000 ugo-backend",
    "start:prod": "NODE_ENV=production node src/server.js",
    "audit": "npm audit --audit-level=high || true",
    "audit:fix": "npm audit fix || true"
  },
  "keywords": [
    "ugo",
    "dogs",
    "community",
    "nodejs",
    "express",
    "prisma",
    "postgresql"
  ],
  "author": "Francesco Archi <francesco@ilmondidiugo.com>",
  "license": "MIT",
  "dependencies": {
    "@prisma/client": "^5.6.0",
    "@sendgrid/mail": "^8.1.5",
    "axios": "^1.6.0",
    "bcryptjs": "^2.4.3",
    "cloudinary": "^1.41.0",
    "compression": "^1.7.4",
    "connect-redis": "^7.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-async-errors": "^3.1.1",
    "express-rate-limit": "^7.1.5",
    "express-slow-down": "^2.0.1",
    "express-validator": "^7.2.1",
    "faker": "^5.5.3",
    "helmet": "^7.1.0",
    "ioredis": "^5.3.2",
    "joi": "^17.11.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.1",
    "multer": "^1.4.5-lts.1",
    "node-cron": "^3.0.3",
    "nodemailer": "^6.9.7",
    "passport": "^0.7.0",
    "passport-facebook": "^3.0.0",
    "passport-google-oauth20": "^2.0.0",
    "prisma": "^5.6.0",
    "redis": "^4.6.10",
    "sharp": "^0.32.6",
    "socket.io": "^4.7.4",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.0",
    "winston": "^3.11.0"
  },
  "devDependencies": {
    "@faker-js/faker": "^8.3.1",
    "@sentry/node": "^10.3.0",
    "@types/jest": "^29.5.8",
    "eslint": "^8.54.0",
    "eslint-config-node": "^4.1.0",
    "eslint-plugin-node": "^11.1.0",
    "jest": "^29.7.0",
    "nodemon": "^3.0.1",
    "prom-client": "^15.1.3",
    "supertest": "^6.3.3"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "prisma": {
    "seed": "node prisma/seed.js"
  },
  "jest": {
    "testEnvironment": "node",
    "roots": [
      "<rootDir>"
    ],
    "modulePathIgnorePatterns": [
      "<rootDir>/Supabase-Backend-app/",
      "<rootDir>/docker/",
      "<rootDir>/prisma/"
    ],
    "testPathIgnorePatterns": [
      "/node_modules/",
      "<rootDir>/Supabase-Backend-app/"
    ]
  }
}

```

---

### üìÑ `../backend/prisma/schema.prisma`

**üìè Dimensione:** 11.2 KB | **üìù Righe:** 434

```prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String    @id @default(cuid())
  email           String    @unique
  username        String    @unique
  password        String?   // Nullable for OAuth users
  firstName       String?
  lastName        String?
  avatar          String?
  bio             String?
  dateOfBirth     DateTime?
  dogName         String?   // Nome del proprio cane
  dogBreed        String?   // Razza del cane
  dogPhoto        String?   // Foto del cane
  isVerified      Boolean   @default(false)
  isAdmin         Boolean   @default(false)
  isActive        Boolean   @default(true)
  points          Int       @default(0)
  streak          Int       @default(0)
  level           Int       @default(1)
  lastLogin       DateTime?
  lastActivity    DateTime?
  emailVerificationToken String?
  passwordResetToken     String?
  passwordResetExpires   DateTime?
  twoFactorSecret        String?
  twoFactorEnabled       Boolean   @default(false)
  privacySettings        Json?     // { profilePublic: boolean, showEmail: boolean, etc. }
  notificationSettings   Json?     // Email, push, in-app preferences
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // OAuth
  googleId        String?   @unique
  facebookId      String?   @unique
  
  // Relations
  posts           Post[]
  comments        Comment[]
  likes           Like[]
  shares          Share[]
  achievements    UserAchievement[]
  quizAttempts    QuizAttempt[]
  notifications   Notification[]
  followers       Follow[]  @relation("UserFollowers")
  following       Follow[]  @relation("UserFollowing")
  photoBoothItems PhotoBoothItem[]
  sessions        UserSession[]
  analytics       UserAnalytics[]
  conversations   Conversation[]
  
  @@map("users")
}

model UserSession {
  id           String   @id @default(cuid())
  userId       String
  token        String   @unique
  refreshToken String   @unique
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  ipAddress    String?
  userAgent    String?
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("user_sessions")
}

model Post {
  id             String    @id @default(cuid())
  title          String
  content        String
  excerpt        String?
  slug           String    @unique
  coverImage     String?
  images         String[]  // Array of image URLs
  published      Boolean   @default(false)
  featured       Boolean   @default(false)
  publishedAt    DateTime?
  scheduledFor   DateTime?
  views          Int       @default(0)
  readingTime    Int?      // In minutes
  seoTitle       String?
  seoDescription String?
  metaTags       Json?
  status         PostStatus @default(DRAFT)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  
  // Relations
  author      User      @relation(fields: [authorId], references: [id])
  authorId    String
  comments    Comment[]
  likes       Like[]
  shares      Share[]
  tags        PostTag[]
  categories  PostCategory[]
  analytics   PostAnalytics[]
  
  @@map("posts")
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  isApproved Boolean @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  author   User   @relation(fields: [authorId], references: [id])
  authorId String
  post     Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId   String
  
  // Self-referencing for replies
  parent   Comment? @relation("CommentReplies", fields: [parentId], references: [id])
  parentId String?
  replies  Comment[] @relation("CommentReplies")
  
  @@map("comments")
}

model Like {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  
  user   User   @relation(fields: [userId], references: [id])
  userId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId String
  
  @@unique([userId, postId])
  @@map("likes")
}

model Share {
  id        String    @id @default(cuid())
  platform  String?   // facebook, twitter, whatsapp, etc.
  createdAt DateTime  @default(now())
  
  user   User   @relation(fields: [userId], references: [id])
  userId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId String
  
  @@map("shares")
}

model Tag {
  id          String    @id @default(cuid())
  name        String    @unique
  slug        String    @unique
  description String?
  color       String?   // Hex color for UI
  createdAt   DateTime  @default(now())
  
  posts PostTag[]
  
  @@map("tags")
}

model PostTag {
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId String
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)
  tagId  String
  
  @@id([postId, tagId])
  @@map("post_tags")
}

model Category {
  id          String    @id @default(cuid())
  name        String    @unique
  slug        String    @unique
  description String?
  color       String?
  icon        String?
  createdAt   DateTime  @default(now())
  
  posts PostCategory[]
  
  @@map("categories")
}

model PostCategory {
  post       Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId     String
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  categoryId String
  
  @@id([postId, categoryId])
  @@map("post_categories")
}

model Follow {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  
  follower    User @relation("UserFollowing", fields: [followerId], references: [id])
  followerId  String
  following   User @relation("UserFollowers", fields: [followingId], references: [id])
  followingId String
  
  @@unique([followerId, followingId])
  @@map("follows")
}

model Achievement {
  id          String   @id @default(cuid())
  name        String   @unique
  description String
  icon        String
  points      Int      @default(0)
  category    String   // login, social, quiz, photo, etc.
  condition   Json     // Conditions to unlock
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  
  users UserAchievement[]
  
  @@map("achievements")
}

model UserAchievement {
  id          String   @id @default(cuid())
  unlockedAt  DateTime @default(now())
  
  user          User        @relation(fields: [userId], references: [id])
  userId        String
  achievement   Achievement @relation(fields: [achievementId], references: [id])
  achievementId String
  
  @@unique([userId, achievementId])
  @@map("user_achievements")
}

model Quiz {
  id          String   @id @default(cuid())
  title       String
  description String?
  difficulty  QuizDifficulty @default(EASY)
  timeLimit   Int?     // Seconds per question
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  questions QuizQuestion[]
  attempts  QuizAttempt[]
  
  @@map("quizzes")
}

model QuizQuestion {
  id            String   @id @default(cuid())
  question      String
  options       Json     // Array of options
  correctAnswer Int      // Index of correct answer
  explanation   String?
  points        Int      @default(10)
  order         Int
  
  quiz   Quiz   @relation(fields: [quizId], references: [id], onDelete: Cascade)
  quizId String
  
  answers QuizAnswer[]
  
  @@map("quiz_questions")
}

model QuizAttempt {
  id          String   @id @default(cuid())
  score       Int      @default(0)
  totalPoints Int
  timeSpent   Int?     // In seconds
  completed   Boolean  @default(false)
  startedAt   DateTime @default(now())
  completedAt DateTime?
  
  user   User   @relation(fields: [userId], references: [id])
  userId String
  quiz   Quiz   @relation(fields: [quizId], references: [id])
  quizId String
  
  answers QuizAnswer[]
  
  @@map("quiz_attempts")
}

model QuizAnswer {
  id           String   @id @default(cuid())
  answer       Int      // Selected option index
  isCorrect    Boolean
  timeSpent    Int?     // Seconds for this question
  hintsUsed    Int      @default(0)
  
  attempt    QuizAttempt   @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  attemptId  String
  question   QuizQuestion  @relation(fields: [questionId], references: [id])
  questionId String
  
  @@unique([attemptId, questionId])
  @@map("quiz_answers")
}

model PhotoBoothItem {
  id          String   @id @default(cuid())
  originalUrl String
  editedUrl   String
  filters     Json     // Applied filters and settings
  isPublic    Boolean  @default(false)
  likes       Int      @default(0)
  downloads   Int      @default(0)
  createdAt   DateTime @default(now())
  
  user   User   @relation(fields: [userId], references: [id])
  userId String
  
  @@map("photo_booth_items")
}

model Notification {
  id        String           @id @default(cuid())
  title     String
  message   String
  type      NotificationType
  data      Json?            // Additional data for the notification
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())
  
  user   User   @relation(fields: [userId], references: [id])
  userId String
  
  @@map("notifications")
}

model UserAnalytics {
  id            String   @id @default(cuid())
  event         String   // page_view, login, quiz_complete, etc.
  data          Json?    // Event-specific data
  ipAddress     String?
  userAgent     String?
  referrer      String?
  timestamp     DateTime @default(now())
  
  user   User?   @relation(fields: [userId], references: [id])
  userId String?
  
  @@map("user_analytics")
}

model PostAnalytics {
  id        String   @id @default(cuid())
  views     Int      @default(1)
  date      DateTime @default(now())
  
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId String
  
  @@unique([postId, date])
  @@map("post_analytics")
}

model SystemSettings {
  id        String   @id @default(cuid())
  key       String   @unique
  value     Json
  updatedAt DateTime @updatedAt
  
  @@map("system_settings")
}

// Ugo AI Conversation System
model Conversation {
  id            String   @id @default(cuid())
  sessionId     String   @default("default")
  userMessage   String
  ugoResponse   String
  mood          String   @default("happy")
  sentiment     String   @default("neutral")
  intent        String   @default("general")
  entities      Json?    // Extracted entities as JSON
  topics        Json?    // Conversation topics as JSON array
  rating        Int?     // User rating 1-5
  metadata      Json?    // Additional metadata
  createdAt     DateTime @default(now())
  
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String
  
  @@index([userId, createdAt])
  @@index([userId, sessionId])
  @@index([rating])
  @@map("conversations")
}

// Enums
enum PostStatus {
  DRAFT
  PUBLISHED
  SCHEDULED
  ARCHIVED
}

enum QuizDifficulty {
  EASY
  MEDIUM
  HARD
}

enum NotificationType {
  NEW_POST
  NEW_COMMENT
  NEW_FOLLOWER
  ACHIEVEMENT_UNLOCKED
  QUIZ_AVAILABLE
  SYSTEM_NOTIFICATION
  REMINDER
  UGO_AI_MESSAGE
}

```

---

### üìÑ `../backend/public/index.html`

**üìè Dimensione:** 767 B | **üìù Righe:** 23

```html
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ugo AI - Dashboard</title>
</head>
<body>
    <h1>Benvenuto su Ugo AI</h1>
    <p>Il sistema √® operativo e tutti i servizi sono attivi!</p>
    
    <h2>Servizi Disponibili:</h2>
    <ul>
        <li><a href="/api/health">Backend API Health</a></li>
        <li><a href="/sd/health">Stable Diffusion Health</a></li>
        <li><a href="/tts/health">TTS Service Health</a></li>
        <li><a href="/mediapipe/health">MediaPipe Health</a></li>
        <li><a href="http://localhost:3001">Grafana Dashboard</a></li>
        <li><a href="http://localhost:9090">Prometheus Metrics</a></li>
    </ul>
</body>
</html>

```

---

### üìÑ `../backend/public/test-ai.html`

**üìè Dimensione:** 7.2 KB | **üìù Righe:** 175

```html
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UGO AI - Test Live</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .test-section { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
        button { background: #007bff; color: white; border: none; padding: 10px 15px; cursor: pointer; margin: 5px; }
        button:hover { background: #0056b3; }
        .result { background: #f8f9fa; border: 1px solid #e9ecef; padding: 10px; margin: 10px 0; border-radius: 3px; }
        .loading { color: #666; font-style: italic; }
        .error { color: #dc3545; }
        .success { color: #28a745; }
        input, textarea { width: 100%; padding: 8px; margin: 5px 0; }
    </style>
</head>
<body>
    <h1>üöÄ UGO AI - Test Live</h1>
    
    <div class="test-section">
        <h2>‚ö° Quick Test</h2>
        <button onclick="quickTest()">Test Veloce</button>
        <div id="quick-result" class="result"></div>
    </div>

    <div class="test-section">
        <h2>üé® Generazione Immagine Veloce</h2>
        <input type="text" id="prompt-input" placeholder="Descrivi l'immagine (es: a cute dog)" value="a cute golden retriever puppy">
        <button onclick="fastGenerate()">Genera Veloce (128x128)</button>
        <div id="image-result" class="result"></div>
    </div>

    <div class="test-section">
        <h2>üé§ Sintesi Vocale</h2>
        <textarea id="tts-input" rows="3" placeholder="Inserisci il testo">Ciao! Sono UGO, il tuo assistente AI.</textarea>
        <button onclick="synthesizeSpeech()">Genera Audio</button>
        <div id="tts-result" class="result"></div>
    </div>

    <div class="test-section">
        <h2>üìä Status Servizi</h2>
        <button onclick="checkHealth()">Verifica Status</button>
        <div id="health-result" class="result"></div>
    </div>

    <script>
        const API_BASE = '/api/ai';
        
        async function quickTest() {
            const result = document.getElementById('quick-result');
            result.innerHTML = '<span class="loading">Test in corso...</span>';
            
            try {
                const response = await fetch(`${API_BASE}/quick-test`);
                const data = await response.json();
                
                if (data.success) {
                    result.innerHTML = `
                        <div class="success">‚úÖ Test completato in ${data.response_time}</div>
                        <p>MediaPipe: ${data.mediapipe}</p>
                        <p>TTS: ${data.tts}</p>
                    `;
                } else {
                    result.innerHTML = `<div class="error">‚ùå ${data.error}</div>`;
                }
            } catch (error) {
                result.innerHTML = `<div class="error">‚ùå Errore: ${error.message}</div>`;
            }
        }

        async function fastGenerate() {
            const prompt = document.getElementById('prompt-input').value;
            const result = document.getElementById('image-result');
            
            if (!prompt) {
                result.innerHTML = '<div class="error">‚ùå Inserisci un prompt</div>';
                return;
            }
            
            result.innerHTML = '<span class="loading">üé® Generando immagine veloce...</span>';
            
            try {
                const response = await fetch(`${API_BASE}/fast-generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt })
                });
                
                const data = await response.json();
                
                if (data.success && data.image) {
                    result.innerHTML = `
                        <div class="success">‚úÖ Immagine generata!</div>
                        <p><strong>Prompt:</strong> ${prompt}</p>
                        <img src="${data.image}" style="max-width: 100%; border: 1px solid #ddd;" alt="Generated image">
                        <p><small>Modalit√†: ${data.mode}</small></p>
                    `;
                } else {
                    result.innerHTML = `<div class="error">‚ùå ${data.error}</div>`;
                }
            } catch (error) {
                result.innerHTML = `<div class="error">‚ùå Errore: ${error.message}</div>`;
            }
        }

        async function synthesizeSpeech() {
            const text = document.getElementById('tts-input').value;
            const result = document.getElementById('tts-result');
            
            if (!text) {
                result.innerHTML = '<div class="error">‚ùå Inserisci del testo</div>';
                return;
            }
            
            result.innerHTML = '<span class="loading">üé§ Sintetizzando audio...</span>';
            
            try {
                const response = await fetch(`${API_BASE}/synthesize-speech`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text })
                });
                
                const data = await response.json();
                
                if (data.success && data.audio) {
                    result.innerHTML = `
                        <div class="success">‚úÖ Audio generato!</div>
                        <p><strong>Testo:</strong> ${text}</p>
                        <audio controls style="width: 100%;">
                            <source src="${data.audio}" type="audio/wav">
                            Browser non supporta audio.
                        </audio>
                        <p><small>Durata: ${data.duration?.toFixed(2)}s</small></p>
                    `;
                } else {
                    result.innerHTML = `<div class="error">‚ùå ${data.error}</div>`;
                }
            } catch (error) {
                result.innerHTML = `<div class="error">‚ùå Errore: ${error.message}</div>`;
            }
        }

        async function checkHealth() {
            const result = document.getElementById('health-result');
            result.innerHTML = '<span class="loading">üîç Verificando servizi...</span>';
            
            try {
                const response = await fetch(`${API_BASE}/health`);
                const data = await response.json();
                
                let html = `<div class="success">‚úÖ Backend AI: ${data.ai_backend}</div>`;
                html += `<p><strong>Servizi:</strong></p>`;
                
                for (const [name, status] of Object.entries(data.services)) {
                    const icon = status.status === 'healthy' ? '‚úÖ' : '‚ùå';
                    html += `<p>${icon} ${name}: ${status.status}</p>`;
                }
                
                result.innerHTML = html;
            } catch (error) {
                result.innerHTML = `<div class="error">‚ùå Errore: ${error.message}</div>`;
            }
        }

        // Auto-test iniziale
        window.onload = () => {
            setTimeout(quickTest, 1000);
        };
    </script>
</body>
</html>

```

---

### üìÑ `../backend/scripts/backup.sh`

**üìè Dimensione:** 598 B | **üìù Righe:** 23

```sh
#!/usr/bin/env bash
set -euo pipefail
DATE=$(date +%Y%m%d_%H%M%S)
DB_URL=${DATABASE_URL:-}
S3_BUCKET=${S3_BUCKET:-}
RETENTION_DAYS=${RETENTION_DAYS:-7}
OUT=${1:-/tmp}
FILE="$OUT/backup_${DATE}.sql.gz"

if [ -z "$DB_URL" ]; then echo "DATABASE_URL not set"; exit 1; fi

mkdir -p "$OUT"
pg_dump "$DB_URL" | gzip -9 > "$FILE"
echo "Backup saved: $FILE"

if [ -n "$S3_BUCKET" ]; then
  aws s3 cp "$FILE" "s3://$S3_BUCKET/" --only-show-errors || true
  echo "Uploaded to s3://$S3_BUCKET/"
fi

# Retention cleanup local
find "$OUT" -name 'backup_*.sql.gz' -type f -mtime +$RETENTION_DAYS -delete || true

```

---

### üìÑ `../backend/scripts/restore.sh`

**üìè Dimensione:** 308 B | **üìù Righe:** 10

```sh
#!/usr/bin/env bash
set -euo pipefail
FILE=${1:-}
DB_URL=${DATABASE_URL:-}
if [ -z "$FILE" ] || [ ! -f "$FILE" ]; then echo "Usage: $0 path/to/backup.sql.gz"; exit 1; fi
if [ -z "$DB_URL" ]; then echo "DATABASE_URL not set"; exit 1; fi

gunzip -c "$FILE" | psql "$DB_URL"
echo "Restore completed from $FILE"

```

---

### üìÑ `../backend/src/app.js`

**üìè Dimensione:** 6.2 KB | **üìù Righe:** 224

```js
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const morgan = require('morgan');
const rateLimit = require('express-rate-limit');
const slowDown = require('express-slow-down');
require('express-async-errors');
require('dotenv').config();

// Sentry (lazy-load only if DSN provided and module available)
let Sentry = null;
if (process.env.SENTRY_DSN) {
  try {
    Sentry = require('@sentry/node');
    Sentry.init({ dsn: process.env.SENTRY_DSN, tracesSampleRate: 0.1 });
  } catch (e) {
    console.warn('[@sentry/node] not installed, skipping Sentry init');
  }
}

// Prometheus metrics
const client = require('prom-client');
client.collectDefaultMetrics();
const httpRequestDuration = new client.Histogram({
  name: 'http_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'route', 'code'],
  buckets: [0.005,0.01,0.025,0.05,0.1,0.25,0.5,1,2,5]
});

// Import routes
const authRoutes = require('./routes/authRoutes');
const userRoutes = require('./routes/userRoutes');
const postRoutes = require('./routes/postRoutes');
const commentRoutes = require('./routes/commentRoutes');
const quizRoutes = require('./routes/quizRoutes');
const gamificationRoutes = require('./routes/gamificationRoutes');
const photoBoothRoutes = require('./routes/photoBoothRoutes');
const notificationRoutes = require('./routes/notificationRoutes');
const analyticsRoutes = require('./routes/analyticsRoutes');
const adminRoutes = require('./routes/adminRoutes');
const ugoAIRoutes = require('./routes/ugoAI');
const aiRoutes = require('./routes/aiRoutes');
const publicIntegrationRoutes = require('./routes/publicIntegrationRoutes');

// Import middleware
const errorHandler = require('./middleware/errorHandler');
const logger = require('./utils/logger');

const app = express();

// Request timing metric
app.use((req, res, next) => {
  const end = httpRequestDuration.startTimer();
  res.on('finish', () => {
    end({ method: req.method, route: req.route ? req.route.path : req.path, code: res.statusCode });
  });
  next();
});

// Sentry request handler
if (Sentry) {
  app.use(Sentry.Handlers.requestHandler());
}

// Trust proxy for accurate IP addresses
app.set('trust proxy', 1);

// Security middleware
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      imgSrc: ["'self'", "data:", "https:", "http:"],
      scriptSrc: ["'self'"]
    }
  },
  crossOriginEmbedderPolicy: false
}));

// CORS configuration
const corsOptions = {
  origin: function (origin, callback) {
    const allowedOrigins = [
      'https://fraarchi.github.io',
      'http://localhost:3000',
      'http://localhost:3001',
      'http://127.0.0.1:5500'
    ];
    
    if (!origin || allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  optionsSuccessStatus: 200
};

app.use(cors(corsOptions));

// Compression (gzip)
app.use(compression());

// Logging
app.use(morgan('combined', {
  stream: {
    write: message => logger.info(message.trim())
  }
}));

// Body parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Rate limiting
const limiter = rateLimit({
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000, // 15 minutes
  max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || 100,
  message: {
    error: 'Too many requests from this IP, please try again later.'
  },
  standardHeaders: true,
  legacyHeaders: false
});

app.use('/api/', limiter);

// Speed limiter for additional protection
const speedLimiter = slowDown({
  windowMs: 15 * 60 * 1000, // 15 minutes
  delayAfter: 50, // Allow 50 requests per windowMs without delay
  delayMs: () => 500, // Add 500ms delay per request after delayAfter
  maxDelayMs: 20000, // Maximum delay of 20 seconds
  validate: { delayMs: false } // Disable deprecation warning
});

app.use('/api/', speedLimiter);

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    version: process.env.npm_package_version || '1.0.0',
    environment: process.env.NODE_ENV || 'development'
  });
});

// Metrics endpoint
app.get('/metrics', async (req, res) => {
  res.set('Content-Type', client.register.contentType);
  res.end(await client.register.metrics());
});

// API Documentation
if (process.env.NODE_ENV !== 'production') {
  const swaggerUi = require('swagger-ui-express');
  const swaggerSpec = require('./config/swagger');
  
  app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));
}

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/posts', postRoutes);
app.use('/api/comments', commentRoutes);
app.use('/api/quiz', quizRoutes);
app.use('/api/gamification', gamificationRoutes);
app.use('/api/photo-booth', photoBoothRoutes);
app.use('/api/notifications', notificationRoutes);
app.use('/api/analytics', analyticsRoutes);
app.use('/api/admin', adminRoutes);
app.use('/api/ugo-ai', ugoAIRoutes);
app.use('/api/ai', aiRoutes);
app.use('/api/public', publicIntegrationRoutes);

// Sentry error handler
if (Sentry) {
  app.use(Sentry.Handlers.errorHandler());
}

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({
    error: 'Route not found',
    message: `Cannot ${req.method} ${req.originalUrl}`
  });
});

// Global error handler
app.use(errorHandler);

// Graceful shutdown
process.on('SIGTERM', () => {
  logger.info('SIGTERM received, shutting down gracefully');
  process.exit(0);
});

process.on('SIGINT', () => {
  logger.info('SIGINT received, shutting down gracefully');
  process.exit(0);
});

// Unhandled promise rejections
process.on('unhandledRejection', (err) => {
  logger.error('Unhandled Promise Rejection:', err);
  process.exit(1);
});

// Uncaught exceptions
process.on('uncaughtException', (err) => {
  logger.error('Uncaught Exception:', err);
  process.exit(1);
});

module.exports = app;

```

---

### üìÑ `../backend/src/config/envLoader.js`

**üìè Dimensione:** 1.0 KB | **üìù Righe:** 35

```js
// Centralized environment loader & validator
const path = require('path');
const fs = require('fs');
const dotenv = require('dotenv');

// Resolve .env explicitly relative to backend root
const ENV_PATH = path.join(__dirname, '..', '..', '.env');
if (fs.existsSync(ENV_PATH)) {
  dotenv.config({ path: ENV_PATH });
} else {
  console.warn('[envLoader] .env file not found at', ENV_PATH);
}

const REQUIRED = [
  'SUPABASE_URL',
  'SUPABASE_ANON_KEY',
  'SUPABASE_SERVICE_ROLE_KEY'
];

const missing = REQUIRED.filter(k => !process.env[k] || process.env[k].trim() === '');
if (missing.length) {
  console.error('[envLoader] Missing required env vars:', missing.join(', '));
}

// Export sanitized config object
const env = {
  SUPABASE_URL: process.env.SUPABASE_URL,
  SUPABASE_ANON_KEY: process.env.SUPABASE_ANON_KEY,
  SUPABASE_SERVICE_ROLE_KEY: process.env.SUPABASE_SERVICE_ROLE_KEY,
  NODE_ENV: process.env.NODE_ENV || 'development',
  PORT: parseInt(process.env.PORT || '3000', 10)
};

module.exports = { env, missing };

```

---

### üìÑ `../backend/src/config/redis.js`

**üìè Dimensione:** 2.9 KB | **üìù Righe:** 128

```js
const Redis = require('ioredis');
const logger = require('../utils/logger');

const redisClient = new Redis(process.env.REDIS_URL || 'redis://localhost:6379', {
  retryDelayOnFailover: 100,
  enableReadyCheck: false,
  maxRetriesPerRequest: null,
  lazyConnect: true,
  keepAlive: 30000,
  connectTimeout: 10000,
  commandTimeout: 5000,
});

redisClient.on('connect', () => {
  logger.info('Redis client connected');
});

redisClient.on('ready', () => {
  logger.info('Redis client ready');
});

redisClient.on('error', (err) => {
  logger.error('Redis client error:', err);
});

redisClient.on('close', () => {
  logger.info('Redis client connection closed');
});

redisClient.on('reconnecting', () => {
  logger.info('Redis client reconnecting');
});

// Helper functions
const cache = {
  // Get data from cache
  async get(key) {
    try {
      const data = await redisClient.get(key);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      logger.error('Cache get error:', error);
      return null;
    }
  },

  // Set data in cache with expiration
  async set(key, data, expirationInSeconds = 3600) {
    try {
      await redisClient.setex(key, expirationInSeconds, JSON.stringify(data));
      return true;
    } catch (error) {
      logger.error('Cache set error:', error);
      return false;
    }
  },

  // Delete from cache
  async del(key) {
    try {
      await redisClient.del(key);
      return true;
    } catch (error) {
      logger.error('Cache delete error:', error);
      return false;
    }
  },

  // Check if key exists
  async exists(key) {
    try {
      const result = await redisClient.exists(key);
      return result === 1;
    } catch (error) {
      logger.error('Cache exists error:', error);
      return false;
    }
  },

  // Set with pattern-based expiration
  async setWithPattern(pattern, data, expirationInSeconds = 3600) {
    try {
      const key = `ugo:${pattern}`;
      await redisClient.setex(key, expirationInSeconds, JSON.stringify(data));
      return true;
    } catch (error) {
      logger.error('Cache setWithPattern error:', error);
      return false;
    }
  },

  // Get with pattern
  async getWithPattern(pattern) {
    try {
      const key = `ugo:${pattern}`;
      return await this.get(key);
    } catch (error) {
      logger.error('Cache getWithPattern error:', error);
      return null;
    }
  },

  // Increment counter
  async increment(key, amount = 1) {
    try {
      const result = await redisClient.incrby(key, amount);
      return result;
    } catch (error) {
      logger.error('Cache increment error:', error);
      return null;
    }
  },

  // Set expiration for existing key
  async expire(key, seconds) {
    try {
      await redisClient.expire(key, seconds);
      return true;
    } catch (error) {
      logger.error('Cache expire error:', error);
      return false;
    }
  }
};

module.exports = redisClient;
module.exports.cache = cache;

```

---

### üìÑ `../backend/src/config/supabase.js`

**üìè Dimensione:** 811 B | **üìù Righe:** 23

```js
const { env, missing } = require('./envLoader');
const { createClient } = require('@supabase/supabase-js');

if (missing && missing.length) {
  throw new Error('Missing required env vars: ' + missing.join(', '));
}

const SUPABASE_URL = env.SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = env.SUPABASE_SERVICE_ROLE_KEY;

console.log('[supabase] Using URL:', SUPABASE_URL);
console.log('[supabase] Service key present length:', SUPABASE_SERVICE_ROLE_KEY ? SUPABASE_SERVICE_ROLE_KEY.length : 0);

if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
  throw new Error('Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY in environment variables');
}

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {
  auth: { autoRefreshToken: false, persistSession: false },
});

module.exports = supabase;

```

---

### üìÑ `../backend/src/config/swagger.js`

**üìè Dimensione:** 750 B | **üìù Righe:** 37

```js
const swaggerJsdoc = require('swagger-jsdoc');

const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'Ugo AI Backend API',
      version: '1.0.0',
      description: 'API documentation for Ugo AI Backend',
    },
    servers: [
      {
        url: 'http://localhost:3000',
        description: 'Development server',
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
        },
      },
    },
    security: [
      {
        bearerAuth: [],
      },
    ],
  },
  apis: ['./src/routes/*.js'], // paths to files containing OpenAPI definitions
};

const specs = swaggerJsdoc(options);
module.exports = specs;

```

---

### üìÑ `../backend/src/controllers/authController.js`

**üìè Dimensione:** 7.0 KB | **üìù Righe:** 297

```js
const authService = require('../services/authService');
const logger = require('../utils/logger');

class AuthController {
  // Register new user
  async register(req, res) {
    try {
      const userData = req.body;
      const user = await authService.register(userData);

      res.status(201).json({
        success: true,
        message: process.env.NODE_ENV === 'development' 
          ? 'User registered and verified successfully' 
          : 'User registered successfully. Please check your email to verify your account.',
        data: {
          user: {
            id: user.id,
            email: user.email,
            username: user.username,
            firstName: user.firstName,
            lastName: user.lastName,
            isVerified: user.isVerified
          }
        }
      });
    } catch (error) {
      logger.error('Registration error:', error);
      res.status(400).json({
        success: false,
        error: error.message
      });
    }
  }

  // Login user
  async login(req, res) {
    try {
      const { email, password } = req.body;
      const ipAddress = req.ip;
      const userAgent = req.get('User-Agent');

      const result = await authService.login(email, password, ipAddress, userAgent);

      // Set refresh token as httpOnly cookie
      res.cookie('refreshToken', result.tokens.refreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
      });

      res.json({
        success: true,
        message: 'Login successful',
        data: {
          user: result.user,
          accessToken: result.tokens.accessToken
        }
      });
    } catch (error) {
      logger.error('Login error:', error);
      res.status(401).json({
        success: false,
        error: error.message
      });
    }
  }

  // Refresh access token
  async refreshToken(req, res) {
    try {
      const refreshToken = req.cookies.refreshToken || req.body.refreshToken;

      if (!refreshToken) {
        return res.status(401).json({
          success: false,
          error: 'Refresh token not provided'
        });
      }

      const result = await authService.refreshToken(refreshToken);

      // Set new refresh token as cookie
      res.cookie('refreshToken', result.tokens.refreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
      });

      res.json({
        success: true,
        message: 'Token refreshed successfully',
        data: {
          user: result.user,
          accessToken: result.tokens.accessToken
        }
      });
    } catch (error) {
      logger.error('Refresh token error:', error);
      res.status(401).json({
        success: false,
        error: error.message
      });
    }
  }

  // Logout user
  async logout(req, res) {
    try {
      const token = req.token;
      const refreshToken = req.cookies.refreshToken || req.body.refreshToken;

      await authService.logout(token, refreshToken);

      // Clear refresh token cookie
      res.clearCookie('refreshToken');

      res.json({
        success: true,
        message: 'Logout successful'
      });
    } catch (error) {
      logger.error('Logout error:', error);
      res.status(500).json({
        success: false,
        error: 'Logout failed'
      });
    }
  }

  // Verify email
  async verifyEmail(req, res) {
    try {
      const { token } = req.params;
      const result = await authService.verifyEmail(token);

      res.json({
        success: true,
        message: result.message
      });
    } catch (error) {
      logger.error('Email verification error:', error);
      res.status(400).json({
        success: false,
        error: error.message
      });
    }
  }

  // Resend verification email
  async resendVerification(req, res) {
    try {
      const { email } = req.body;
      const result = await authService.resendVerification(email);

      res.json({
        success: true,
        message: result.message
      });
    } catch (error) {
      logger.error('Resend verification error:', error);
      res.status(400).json({
        success: false,
        error: error.message
      });
    }
  }

  // Request password reset
  async forgotPassword(req, res) {
    try {
      const { email } = req.body;
      const result = await authService.forgotPassword(email);

      res.json({
        success: true,
        message: result.message
      });
    } catch (error) {
      logger.error('Forgot password error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to process password reset request'
      });
    }
  }

  // Reset password
  async resetPassword(req, res) {
    try {
      const { token, password } = req.body;
      const result = await authService.resetPassword(token, password);

      res.json({
        success: true,
        message: result.message
      });
    } catch (error) {
      logger.error('Reset password error:', error);
      res.status(400).json({
        success: false,
        error: error.message
      });
    }
  }

  // Get current user info
  async me(req, res) {
    try {
      res.json({
        success: true,
        data: {
          user: req.user
        }
      });
    } catch (error) {
      logger.error('Me endpoint error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to get user information'
      });
    }
  }

  // Check if email is available
  async checkEmail(req, res) {
    try {
      const { email } = req.query;
      
      if (!email) {
        return res.status(400).json({
          success: false,
          error: 'Email is required'
        });
      }

      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      const existingUser = await prisma.user.findUnique({
        where: { email: email.toLowerCase() }
      });

      res.json({
        success: true,
        data: {
          available: !existingUser
        }
      });
    } catch (error) {
      logger.error('Check email error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to check email availability'
      });
    }
  }

  // Check if username is available
  async checkUsername(req, res) {
    try {
      const { username } = req.query;
      
      if (!username) {
        return res.status(400).json({
          success: false,
          error: 'Username is required'
        });
      }

      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      const existingUser = await prisma.user.findUnique({
        where: { username: username.toLowerCase() }
      });

      res.json({
        success: true,
        data: {
          available: !existingUser
        }
      });
    } catch (error) {
      logger.error('Check username error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to check username availability'
      });
    }
  }
}

module.exports = new AuthController();

```

---

### üìÑ `../backend/src/controllers/postController.js`

**üìè Dimensione:** 9.6 KB | **üìù Righe:** 415

```js
const postService = require('../services/postService');
const logger = require('../utils/logger');

class PostController {
  // Get all posts
  async getPosts(req, res) {
    try {
      const {
        page = 1,
        limit = 10,
        published,
        featured,
        author,
        tag,
        category,
        search,
        sortBy = 'publishedAt',
        sortOrder = 'desc'
      } = req.query;

      const options = {
        page: parseInt(page),
        limit: parseInt(limit),
        published: published !== undefined ? published === 'true' : true,
        featured: featured !== undefined ? featured === 'true' : undefined,
        authorId: author,
        tag,
        category,
        search,
        sortBy,
        sortOrder
      };

      const result = await postService.getPosts(options);

      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      logger.error('Get posts error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch posts'
      });
    }
  }

  // Get single post by slug
  async getPost(req, res) {
    try {
      const { slug } = req.params;
      const userId = req.user?.id;

      const post = await postService.getPostBySlug(slug, userId);

      res.json({
        success: true,
        data: { post }
      });
    } catch (error) {
      logger.error('Get post error:', error);
      
      if (error.message === 'Post not found') {
        return res.status(404).json({
          success: false,
          error: 'Post not found'
        });
      }

      res.status(500).json({
        success: false,
        error: 'Failed to fetch post'
      });
    }
  }

  // Create new post (admin only)
  async createPost(req, res) {
    try {
      const authorId = req.user.id;
      const postData = req.body;

      const post = await postService.createPost(authorId, postData);

      res.status(201).json({
        success: true,
        message: 'Post created successfully',
        data: { post }
      });
    } catch (error) {
      logger.error('Create post error:', error);
      res.status(400).json({
        success: false,
        error: error.message || 'Failed to create post'
      });
    }
  }

  // Update post
  async updatePost(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const updateData = req.body;

      const post = await postService.updatePost(id, userId, updateData);

      res.json({
        success: true,
        message: 'Post updated successfully',
        data: { post }
      });
    } catch (error) {
      logger.error('Update post error:', error);
      
      const statusCode = error.message.includes('not found') ? 404 :
                        error.message.includes('Not authorized') ? 403 : 400;

      res.status(statusCode).json({
        success: false,
        error: error.message || 'Failed to update post'
      });
    }
  }

  // Delete post
  async deletePost(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user.id;

      const result = await postService.deletePost(id, userId);

      res.json({
        success: true,
        message: result.message
      });
    } catch (error) {
      logger.error('Delete post error:', error);
      
      const statusCode = error.message.includes('not found') ? 404 :
                        error.message.includes('Not authorized') ? 403 : 400;

      res.status(statusCode).json({
        success: false,
        error: error.message || 'Failed to delete post'
      });
    }
  }

  // Like/Unlike post
  async toggleLike(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user.id;

      const result = await postService.toggleLike(id, userId);

      res.json({
        success: true,
        message: result.message,
        data: { liked: result.liked }
      });
    } catch (error) {
      logger.error('Toggle like error:', error);
      res.status(400).json({
        success: false,
        error: 'Failed to toggle like'
      });
    }
  }

  // Share post
  async sharePost(req, res) {
    try {
      const { id } = req.params;
      const { platform } = req.body;
      const userId = req.user.id;

      const result = await postService.sharePost(id, userId, platform);

      res.json({
        success: true,
        message: result.message
      });
    } catch (error) {
      logger.error('Share post error:', error);
      res.status(400).json({
        success: false,
        error: 'Failed to share post'
      });
    }
  }

  // Get popular posts
  async getPopularPosts(req, res) {
    try {
      const { limit = 5 } = req.query;
      
      const posts = await postService.getPopularPosts(parseInt(limit));

      res.json({
        success: true,
        data: { posts }
      });
    } catch (error) {
      logger.error('Get popular posts error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch popular posts'
      });
    }
  }

  // Get related posts
  async getRelatedPosts(req, res) {
    try {
      const { id } = req.params;
      const { limit = 3 } = req.query;

      const posts = await postService.getRelatedPosts(id, parseInt(limit));

      res.json({
        success: true,
        data: { posts }
      });
    } catch (error) {
      logger.error('Get related posts error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch related posts'
      });
    }
  }

  // Get user's posts
  async getMyPosts(req, res) {
    try {
      const userId = req.user.id;
      const {
        page = 1,
        limit = 10,
        published,
        sortBy = 'updatedAt',
        sortOrder = 'desc'
      } = req.query;

      const options = {
        page: parseInt(page),
        limit: parseInt(limit),
        published: published !== undefined ? published === 'true' : undefined,
        authorId: userId,
        sortBy,
        sortOrder
      };

      const result = await postService.getPosts(options);

      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      logger.error('Get my posts error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch your posts'
      });
    }
  }

  // Get post analytics (admin only)
  async getPostAnalytics(req, res) {
    try {
      const { id } = req.params;
      const { days = 30 } = req.query;

      const startDate = new Date();
      startDate.setDate(startDate.getDate() - parseInt(days));

      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      const analytics = await prisma.postAnalytics.findMany({
        where: {
          postId: id,
          date: {
            gte: startDate
          }
        },
        orderBy: {
          date: 'asc'
        }
      });

      const post = await prisma.post.findUnique({
        where: { id },
        select: {
          id: true,
          title: true,
          views: true,
          publishedAt: true,
          _count: {
            select: {
              likes: true,
              comments: true,
              shares: true
            }
          }
        }
      });

      if (!post) {
        return res.status(404).json({
          success: false,
          error: 'Post not found'
        });
      }

      const totalViews = analytics.reduce((sum, day) => sum + day.views, 0);
      const avgViewsPerDay = totalViews / Math.max(analytics.length, 1);

      res.json({
        success: true,
        data: {
          post,
          analytics,
          summary: {
            totalViews,
            avgViewsPerDay: Math.round(avgViewsPerDay),
            totalLikes: post._count.likes,
            totalComments: post._count.comments,
            totalShares: post._count.shares,
            engagementRate: post.views > 0 ? 
              ((post._count.likes + post._count.comments + post._count.shares) / post.views * 100).toFixed(2) + '%' 
              : '0%'
          }
        }
      });
    } catch (error) {
      logger.error('Get post analytics error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch post analytics'
      });
    }
  }

  // Preview post (for draft previews)
  async previewPost(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user.id;

      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      const post = await prisma.post.findUnique({
        where: { id },
        include: {
          author: {
            select: {
              id: true,
              username: true,
              firstName: true,
              lastName: true,
              avatar: true
            }
          },
          tags: {
            include: {
              tag: true
            }
          },
          categories: {
            include: {
              category: true
            }
          }
        }
      });

      if (!post) {
        return res.status(404).json({
          success: false,
          error: 'Post not found'
        });
      }

      // Check if user can preview this post
      const user = await prisma.user.findUnique({ where: { id: userId } });
      if (post.authorId !== userId && !user.isAdmin) {
        return res.status(403).json({
          success: false,
          error: 'Not authorized to preview this post'
        });
      }

      res.json({
        success: true,
        data: { post }
      });
    } catch (error) {
      logger.error('Preview post error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to preview post'
      });
    }
  }
}

module.exports = new PostController();

```

---

### üìÑ `../backend/src/middleware/authMiddleware.js`

**üìè Dimensione:** 6.3 KB | **üìù Righe:** 269

```js
const jwt = require('jsonwebtoken');
const { PrismaClient } = require('@prisma/client');
const { cache } = require('../config/redis');
const logger = require('../utils/logger');

const prisma = new PrismaClient();

// Main authentication middleware
const authMiddleware = async (req, res, next) => {
  try {
    let token = req.header('Authorization');
    
    if (!token) {
      return res.status(401).json({ 
        success: false, 
        error: 'Access denied. No token provided.' 
      });
    }

    // Remove 'Bearer ' from token
    if (token.startsWith('Bearer ')) {
      token = token.slice(7, token.length);
    }

    // Check if token is blacklisted (logout)
    const isBlacklisted = await cache.exists(`blacklist:${token}`);
    if (isBlacklisted) {
      return res.status(401).json({ 
        success: false, 
        error: 'Token has been invalidated.' 
      });
    }

    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // Check cache first for performance
    let user = await cache.getWithPattern(`user:${decoded.userId}`);
    
    if (!user) {
      // If not in cache, get from database
      user = await prisma.user.findUnique({
        where: { id: decoded.userId },
        select: {
          id: true,
          email: true,
          username: true,
          firstName: true,
          lastName: true,
          avatar: true,
          isAdmin: true,
          isVerified: true,
          isActive: true,
          points: true,
          level: true,
          streak: true
        }
      });

      if (user) {
        // Cache user data for 15 minutes
        await cache.setWithPattern(`user:${user.id}`, user, 900);
      }
    }

    if (!user || !user.isActive) {
      return res.status(401).json({ 
        success: false, 
        error: 'User not found or inactive.' 
      });
    }

    if (!user.isVerified) {
      return res.status(401).json({ 
        success: false, 
        error: 'Please verify your email address.' 
      });
    }

    // Add user to request object
    req.user = user;
    req.token = token;
    
    next();
  } catch (error) {
    logger.error('Auth middleware error:', error);
    
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({ 
        success: false, 
        error: 'Invalid token.' 
      });
    }
    
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ 
        success: false, 
        error: 'Token expired.' 
      });
    }
    
    res.status(500).json({ 
      success: false, 
      error: 'Authentication failed.' 
    });
  }
};

// Admin only middleware
const adminOnly = async (req, res, next) => {
  try {
    if (!req.user) {
      return res.status(401).json({ 
        success: false, 
        error: 'Authentication required.' 
      });
    }

    if (!req.user.isAdmin) {
      return res.status(403).json({ 
        success: false, 
        error: 'Admin access required.' 
      });
    }

    next();
  } catch (error) {
    logger.error('Admin middleware error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Authorization check failed.' 
    });
  }
};

// Optional authentication (user can be null)
const optionalAuth = async (req, res, next) => {
  try {
    let token = req.header('Authorization');
    
    if (!token) {
      req.user = null;
      return next();
    }

    // Remove 'Bearer ' from token
    if (token.startsWith('Bearer ')) {
      token = token.slice(7, token.length);
    }

    // Check if token is blacklisted
    const isBlacklisted = await cache.exists(`blacklist:${token}`);
    if (isBlacklisted) {
      req.user = null;
      return next();
    }

    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // Get user from cache or database
    let user = await cache.getWithPattern(`user:${decoded.userId}`);
    
    if (!user) {
      user = await prisma.user.findUnique({
        where: { id: decoded.userId },
        select: {
          id: true,
          email: true,
          username: true,
          firstName: true,
          lastName: true,
          avatar: true,
          isAdmin: true,
          isVerified: true,
          isActive: true,
          points: true,
          level: true,
          streak: true
        }
      });

      if (user) {
        await cache.setWithPattern(`user:${user.id}`, user, 900);
      }
    }

    req.user = (user && user.isActive && user.isVerified) ? user : null;
    req.token = token;
    
    next();
  } catch (error) {
    // If token is invalid, just continue without user
    req.user = null;
    next();
  }
};

// Check if user owns resource or is admin
const ownerOrAdmin = (getResourceUserId) => {
  return async (req, res, next) => {
    try {
      if (!req.user) {
        return res.status(401).json({ 
          success: false, 
          error: 'Authentication required.' 
        });
      }

      // Admin can access everything
      if (req.user.isAdmin) {
        return next();
      }

      const resourceUserId = typeof getResourceUserId === 'function' 
        ? await getResourceUserId(req) 
        : req.params[getResourceUserId || 'userId'];

      if (req.user.id !== resourceUserId) {
        return res.status(403).json({ 
          success: false, 
          error: 'Access denied. You can only access your own resources.' 
        });
      }

      next();
    } catch (error) {
      logger.error('Owner/Admin middleware error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Authorization check failed.' 
      });
    }
  };
};

// Rate limiting for sensitive operations
const sensitiveOperation = async (req, res, next) => {
  try {
    const key = `sensitive:${req.user.id}:${req.route.path}`;
    const attempts = await cache.increment(key);
    
    if (attempts === 1) {
      // Set expiration for 1 hour
      await cache.expire(key, 3600);
    }
    
    if (attempts > 5) {
      return res.status(429).json({ 
        success: false, 
        error: 'Too many attempts. Please try again later.' 
      });
    }
    
    next();
  } catch (error) {
    logger.error('Sensitive operation middleware error:', error);
    next(); // Continue even if rate limiting fails
  }
};

module.exports = {
  authMiddleware,
  adminOnly,
  optionalAuth,
  ownerOrAdmin,
  sensitiveOperation
};

```

---

### üìÑ `../backend/src/middleware/errorHandler.js`

**üìè Dimensione:** 2.4 KB | **üìù Righe:** 99

```js
const logger = require('../utils/logger');

const errorHandler = (err, req, res, next) => {
  let error = { ...err };
  error.message = err.message;

  // Log error
  logger.error('Error:', {
    message: err.message,
    stack: err.stack,
    url: req.originalUrl,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent')
  });

  // Mongoose bad ObjectId
  if (err.name === 'CastError') {
    const message = 'Resource not found';
    error = { message, statusCode: 404 };
  }

  // Mongoose duplicate key
  if (err.code === 11000) {
    const field = Object.keys(err.keyValue)[0];
    const message = `${field} already exists`;
    error = { message, statusCode: 400 };
  }

  // Mongoose validation error
  if (err.name === 'ValidationError') {
    const message = Object.values(err.errors).map(val => val.message).join(', ');
    error = { message, statusCode: 400 };
  }

  // JWT errors
  if (err.name === 'JsonWebTokenError') {
    const message = 'Invalid token';
    error = { message, statusCode: 401 };
  }

  if (err.name === 'TokenExpiredError') {
    const message = 'Token expired';
    error = { message, statusCode: 401 };
  }

  // Prisma errors
  if (err.code === 'P2002') {
    const field = err.meta?.target?.[0] || 'field';
    const message = `${field} already exists`;
    error = { message, statusCode: 400 };
  }

  if (err.code === 'P2025') {
    const message = 'Resource not found';
    error = { message, statusCode: 404 };
  }

  // Multer errors
  if (err.code === 'LIMIT_FILE_SIZE') {
    const message = 'File too large';
    error = { message, statusCode: 400 };
  }

  if (err.code === 'LIMIT_UNEXPECTED_FILE') {
    const message = 'Too many files';
    error = { message, statusCode: 400 };
  }

  // Rate limit errors
  if (err.statusCode === 429) {
    const message = 'Too many requests, please try again later';
    error = { message, statusCode: 429 };
  }

  // Default error response
  const statusCode = error.statusCode || 500;
  const message = error.message || 'Internal Server Error';

  const errorResponse = {
    success: false,
    error: message
  };

  // Add stack trace in development
  if (process.env.NODE_ENV === 'development') {
    errorResponse.stack = err.stack;
  }

  // Add error code if available
  if (err.code) {
    errorResponse.code = err.code;
  }

  res.status(statusCode).json(errorResponse);
};

module.exports = errorHandler;

```

---

### üìÑ `../backend/src/routes/adminRoutes.js`

**üìè Dimensione:** 1.6 KB | **üìù Righe:** 59

```js
const express = require('express');
const router = express.Router();
const { authMiddleware } = require('../middleware/authMiddleware');

// Middleware to check if user is admin
const checkAdmin = (req, res, next) => {
    // For now, just let any authenticated user be admin
    // In production, check user role from database
    if (!req.user) {
        return res.status(401).json({
            success: false,
            message: 'Accesso negato'
        });
    }
    next();
};

// GET /api/admin/stats - Get admin statistics
router.get('/stats', authMiddleware, checkAdmin, async (req, res) => {
    try {
        // Return mock admin stats
        res.json({
            success: true,
            data: {
                totalUsers: 1,
                totalPosts: 0,
                totalComments: 0,
                serverStatus: 'online',
                systemHealth: 'good'
            }
        });
    } catch (error) {
        console.error('Error getting admin stats:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

// GET /api/admin/users - Get all users
router.get('/users', authMiddleware, checkAdmin, async (req, res) => {
    try {
        // Return mock users list
        res.json({
            success: true,
            data: []
        });
    } catch (error) {
        console.error('Error getting users:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

module.exports = router;

```

---

### üìÑ `../backend/src/routes/aiRoutes.js`

**üìè Dimensione:** 14.4 KB | **üìù Righe:** 473

```js
const express = require('express');
const router = express.Router();
const axios = require('axios');
const multer = require('multer');
const path = require('path');
const fs = require('fs');

// Configurazione multer per upload immagini
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, './uploads/');
    },
    filename: (req, file, cb) => {
        cb(null, Date.now() + '-' + file.originalname);
    }
});
const upload = multer({ 
    storage: storage,
    limits: { fileSize: 10 * 1024 * 1024 }, // 10MB
    fileFilter: (req, file, cb) => {
        if (file.mimetype.startsWith('image/')) {
            cb(null, true);
        } else {
            cb(new Error('Solo file immagine sono consentiti'), false);
        }
    }
});

// URLs dei servizi AI
const AI_SERVICES = {
    TTS: process.env.TTS_URL || 'http://coqui-tts:5002',
    MEDIAPIPE: process.env.MEDIAPIPE_URL || 'http://mediapipe-service:5003',
    STABLE_DIFFUSION: process.env.SD_URL || 'http://stable-diffusion:7860',
    OLLAMA: process.env.OLLAMA_URL || 'http://ollama:11434'
};

// === QUICK TEST ENDPOINTS ===
router.get('/quick-test', async (req, res) => {
    try {
        const startTime = Date.now();
        
        // Test solo i servizi pi√π veloci
        const quickTests = await Promise.allSettled([
            axios.get(`${AI_SERVICES.MEDIAPIPE}/health`, { timeout: 1000 }),
            axios.get(`${AI_SERVICES.TTS}/health`, { timeout: 1000 })
        ]);
        
        const endTime = Date.now();
        
        res.json({
            success: true,
            response_time: `${endTime - startTime}ms`,
            mediapipe: quickTests[0].status === 'fulfilled' ? 'OK' : 'ERROR',
            tts: quickTests[1].status === 'fulfilled' ? 'OK' : 'ERROR',
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        res.status(500).json({ 
            success: false, 
            error: error.message 
        });
    }
});

// === ENDPOINT FAST GENERATE ===
router.post('/fast-generate', async (req, res) => {
    try {
        const { prompt } = req.body;
        
        if (!prompt) {
            return res.status(400).json({ 
                success: false, 
                error: 'Prompt richiesto' 
            });
        }
        
        // Generazione super veloce con parametri minimi
        const response = await axios.post(`${AI_SERVICES.STABLE_DIFFUSION}/generate`, {
            prompt,
            width: 128,
            height: 128,
            steps: 5,
            guidance_scale: 5.0
        }, { timeout: 30000 });
        
        res.json({
            success: true,
            service: 'Fast Stable Diffusion',
            mode: 'speed_optimized',
            ...response.data
        });
    } catch (error) {
        res.status(500).json({ 
            success: false, 
            error: `Errore generazione veloce: ${error.message}` 
        });
    }
});

// === HEALTH CHECK GENERALE (OTTIMIZZATO) ===
router.get('/health', async (req, res) => {
    const services = {};
    
    // Controlli paralleli per velocit√†
    const healthChecks = Object.entries(AI_SERVICES).map(async ([name, url]) => {
        try {
            const response = await axios.get(`${url}/health`, { 
                timeout: 1500, // Ridotto timeout
                headers: { 'Connection': 'close' } // Evita keep-alive 
            });
            services[name] = { 
                status: 'healthy', 
                url: url,
                response_time: response.headers['x-response-time'] || 'N/A'
            };
        } catch (error) {
            services[name] = { 
                status: 'unhealthy', 
                url: url,
                error: error.code || error.message 
            };
        }
    });
    
    await Promise.allSettled(healthChecks);
    
    res.json({
        ai_backend: 'operational',
        timestamp: new Date().toISOString(),
        services
    });
});

// === MEDIAPIPE ENDPOINTS ===

router.post('/detect-faces', upload.single('image'), async (req, res) => {
    try {
        if (!req.file && !req.body.image) {
            return res.status(400).json({ 
                success: false, 
                error: 'Nessuna immagine fornita. Carica un file o invia dati base64.' 
            });
        }
        
        let imageData;
        if (req.file) {
            const imagePath = path.resolve(req.file.path);
            const imageBuffer = fs.readFileSync(imagePath);
            imageData = `data:image/jpeg;base64,${imageBuffer.toString('base64')}`;
            fs.unlinkSync(imagePath); // Pulisci file temporaneo
        } else {
            imageData = req.body.image;
        }
        
        const response = await axios.post(`${AI_SERVICES.MEDIAPIPE}/detect_faces`, {
            image: imageData
        }, { timeout: 10000 });
        
        res.json({
            success: true,
            service: 'MediaPipe Face Detection',
            ...response.data
        });
    } catch (error) {
        res.status(500).json({ 
            success: false, 
            error: `Errore rilevamento volti: ${error.message}` 
        });
    }
});

router.post('/detect-hands', upload.single('image'), async (req, res) => {
    try {
        if (!req.file && !req.body.image) {
            return res.status(400).json({ 
                success: false, 
                error: 'Nessuna immagine fornita' 
            });
        }
        
        let imageData;
        if (req.file) {
            const imagePath = path.resolve(req.file.path);
            const imageBuffer = fs.readFileSync(imagePath);
            imageData = `data:image/jpeg;base64,${imageBuffer.toString('base64')}`;
            fs.unlinkSync(imagePath);
        } else {
            imageData = req.body.image;
        }
        
        const response = await axios.post(`${AI_SERVICES.MEDIAPIPE}/detect_hands`, {
            image: imageData
        }, { timeout: 10000 });
        
        res.json({
            success: true,
            service: 'MediaPipe Hand Detection',
            ...response.data
        });
    } catch (error) {
        res.status(500).json({ 
            success: false, 
            error: `Errore rilevamento mani: ${error.message}` 
        });
    }
});

router.post('/detect-pose', upload.single('image'), async (req, res) => {
    try {
        if (!req.file && !req.body.image) {
            return res.status(400).json({ 
                success: false, 
                error: 'Nessuna immagine fornita' 
            });
        }
        
        let imageData;
        if (req.file) {
            const imagePath = path.resolve(req.file.path);
            const imageBuffer = fs.readFileSync(imagePath);
            imageData = `data:image/jpeg;base64,${imageBuffer.toString('base64')}`;
            fs.unlinkSync(imagePath);
        } else {
            imageData = req.body.image;
        }
        
        const response = await axios.post(`${AI_SERVICES.MEDIAPIPE}/detect_pose`, {
            image: imageData
        }, { timeout: 10000 });
        
        res.json({
            success: true,
            service: 'MediaPipe Pose Detection',
            ...response.data
        });
    } catch (error) {
        res.status(500).json({ 
            success: false, 
            error: `Errore rilevamento postura: ${error.message}` 
        });
    }
});

// === TTS ENDPOINTS ===

router.post('/synthesize-speech', async (req, res) => {
    try {
        const { text, language = 'en', speaker } = req.body;
        
        if (!text) {
            return res.status(400).json({ 
                success: false, 
                error: 'Testo richiesto per la sintesi vocale' 
            });
        }
        
        const response = await axios.post(`${AI_SERVICES.TTS}/synthesize`, {
            text,
            language,
            speaker
        }, { timeout: 15000 });
        
        res.json({
            success: true,
            service: 'Coqui TTS',
            ...response.data
        });
    } catch (error) {
        res.status(500).json({ 
            success: false, 
            error: `Errore sintesi vocale: ${error.message}` 
        });
    }
});

router.get('/tts-voices', async (req, res) => {
    try {
        const response = await axios.get(`${AI_SERVICES.TTS}/voices`, { timeout: 5000 });
        res.json({
            success: true,
            service: 'Coqui TTS',
            ...response.data
        });
    } catch (error) {
        res.status(500).json({ 
            success: false, 
            error: `Errore recupero voci: ${error.message}` 
        });
    }
});

// === STABLE DIFFUSION ENDPOINTS ===

router.post('/generate-image', async (req, res) => {
    try {
        const { 
            prompt, 
            negative_prompt = 'blurry, bad quality, distorted', 
            width = 256, // Ridotto per velocit√†
            height = 256, 
            steps = 10, // Ridotto da 20 a 10
            guidance_scale = 7.5 
        } = req.body;
        
        if (!prompt) {
            return res.status(400).json({ 
                success: false, 
                error: 'Prompt richiesto per generare immagine' 
            });
        }
        
        const response = await axios.post(`${AI_SERVICES.STABLE_DIFFUSION}/generate`, {
            prompt,
            negative_prompt,
            width: Math.min(width, 512), // Massimo 512 per velocit√†
            height: Math.min(height, 512),
            steps: Math.min(steps, 15), // Ridotto massimo steps
            guidance_scale
        }, { timeout: 60000 }); // Ridotto timeout da 2 minuti a 1
        
        res.json({
            success: true,
            service: 'Stable Diffusion',
            ...response.data
        });
    } catch (error) {
        res.status(500).json({ 
            success: false, 
            error: `Errore generazione immagine: ${error.message}` 
        });
    }
});

// === OLLAMA/AI CHAT ENDPOINTS ===

router.post('/chat', async (req, res) => {
    try {
        const { message, model = 'llama3.1:8b', system_prompt } = req.body;
        
        if (!message) {
            return res.status(400).json({ 
                success: false, 
                error: 'Messaggio richiesto per la chat' 
            });
        }
        
        let prompt = message;
        if (system_prompt) {
            prompt = `${system_prompt}\n\nUser: ${message}\nAssistant:`;
        }
        
        const response = await axios.post(`${AI_SERVICES.OLLAMA}/api/generate`, {
            model,
            prompt,
            stream: false,
            options: {
                temperature: 0.7,
                top_p: 0.9
            }
        }, { timeout: 30000 });
        
        res.json({
            success: true,
            service: 'Ollama LLM',
            response: response.data.response,
            model: response.data.model,
            created_at: response.data.created_at,
            user_message: message
        });
    } catch (error) {
        res.status(500).json({ 
            success: false, 
            error: `Errore chat AI: ${error.message}` 
        });
    }
});

// === UGO AI ORCHESTRAZIONE ===

router.post('/ugo-complete', async (req, res) => {
    try {
        const { action, data } = req.body;
        
        switch (action) {
            case 'analyze_and_describe':
                if (!data?.image) {
                    return res.status(400).json({ 
                        success: false, 
                        error: 'Immagine richiesta per l\'analisi' 
                    });
                }
                
                // 1. Analizza immagine
                const analysis = await axios.post(`${AI_SERVICES.MEDIAPIPE}/detect_faces`, {
                    image: data.image
                }, { timeout: 10000 });
                
                // 2. Genera descrizione
                const prompt = `Descrivi creativamente un'immagine che contiene ${analysis.data.count || 0} volti. Sii descrittivo e coinvolgente.`;
                const description = await axios.post(`${AI_SERVICES.OLLAMA}/api/generate`, {
                    model: 'llama3.1:8b',
                    prompt,
                    stream: false
                }, { timeout: 30000 });
                
                res.json({
                    success: true,
                    action: 'analyze_and_describe',
                    faces: analysis.data,
                    description: description.data.response,
                    timestamp: new Date().toISOString()
                });
                break;
                
            case 'text_to_multimodal':
                if (!data?.text) {
                    return res.status(400).json({ 
                        success: false, 
                        error: 'Testo richiesto' 
                    });
                }
                
                // Genera immagine e audio in parallelo
                const [imageResult, audioResult] = await Promise.allSettled([
                    axios.post(`${AI_SERVICES.STABLE_DIFFUSION}/generate`, {
                        prompt: data.text,
                        width: 512,
                        height: 512,
                        steps: 20
                    }, { timeout: 120000 }),
                    axios.post(`${AI_SERVICES.TTS}/synthesize`, {
                        text: data.text
                    }, { timeout: 15000 })
                ]);
                
                const result = {
                    success: true,
                    action: 'text_to_multimodal',
                    original_text: data.text,
                    timestamp: new Date().toISOString()
                };
                
                if (imageResult.status === 'fulfilled') {
                    result.image = imageResult.value.data;
                } else {
                    result.image_error = imageResult.reason.message;
                }
                
                if (audioResult.status === 'fulfilled') {
                    result.audio = audioResult.value.data;
                } else {
                    result.audio_error = audioResult.reason.message;
                }
                
                res.json(result);
                break;
                
            default:
                res.status(400).json({ 
                    success: false, 
                    error: `Azione sconosciuta: ${action}` 
                });
        }
    } catch (error) {
        res.status(500).json({ 
            success: false, 
            error: `Errore orchestrazione UGO: ${error.message}` 
        });
    }
});

module.exports = router;

```

---

### üìÑ `../backend/src/routes/analyticsRoutes.js`

**üìè Dimensione:** 1.4 KB | **üìù Righe:** 51

```js
const express = require('express');
const router = express.Router();
const { authMiddleware } = require('../middleware/authMiddleware');

// GET /api/analytics/dashboard - Get analytics dashboard data
router.get('/dashboard', authMiddleware, async (req, res) => {
    try {
        // Return mock analytics data
        res.json({
            success: true,
            data: {
                totalUsers: 1,
                totalPosts: 0,
                totalComments: 0,
                activeUsers: 1,
                topPosts: [],
                userGrowth: []
            }
        });
    } catch (error) {
        console.error('Error getting analytics:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

// GET /api/analytics/user-activity - Get user activity stats
router.get('/user-activity', authMiddleware, async (req, res) => {
    try {
        // Return mock user activity
        res.json({
            success: true,
            data: {
                dailyActivity: [],
                weeklyActivity: [],
                monthlyActivity: []
            }
        });
    } catch (error) {
        console.error('Error getting user activity:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

module.exports = router;

```

---

### üìÑ `../backend/src/routes/authRoutes.js`

**üìè Dimensione:** 10.6 KB | **üìù Righe:** 421

```js
const express = require('express');
const rateLimit = require('express-rate-limit');
const authController = require('../controllers/authController');
const { authMiddleware, sensitiveOperation } = require('../middleware/authMiddleware');
const {
  validateRegister,
  validateLogin,
  validateForgotPassword,
  validateResetPassword,
  validateResendVerification
} = require('../validators/authValidators');

const router = express.Router();

// Rate limiting for auth endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // Limit each IP to 5 requests per windowMs
  message: {
    success: false,
    error: 'Too many authentication attempts, please try again later.'
  },
  skipSuccessfulRequests: true
});

const checkLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 20, // Allow more checks for availability
  message: {
    success: false,
    error: 'Too many requests, please try again later.'
  }
});

/**
 * @swagger
 * components:
 *   schemas:
 *     User:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *           description: User unique identifier
 *         email:
 *           type: string
 *           format: email
 *         username:
 *           type: string
 *         firstName:
 *           type: string
 *         lastName:
 *           type: string
 *         avatar:
 *           type: string
 *           format: url
 *         isVerified:
 *           type: boolean
 *         points:
 *           type: integer
 *         level:
 *           type: integer
 *         streak:
 *           type: integer
 *     
 *     RegisterRequest:
 *       type: object
 *       required:
 *         - email
 *         - username
 *         - password
 *         - confirmPassword
 *         - firstName
 *         - lastName
 *         - acceptTerms
 *       properties:
 *         email:
 *           type: string
 *           format: email
 *         username:
 *           type: string
 *           minLength: 3
 *           maxLength: 20
 *         password:
 *           type: string
 *           minLength: 8
 *         confirmPassword:
 *           type: string
 *         firstName:
 *           type: string
 *           minLength: 2
 *           maxLength: 50
 *         lastName:
 *           type: string
 *           minLength: 2
 *           maxLength: 50
 *         dogName:
 *           type: string
 *           maxLength: 30
 *         dogBreed:
 *           type: string
 *           maxLength: 50
 *         acceptTerms:
 *           type: boolean
 *           enum: [true]
 *     
 *     LoginRequest:
 *       type: object
 *       required:
 *         - email
 *         - password
 *       properties:
 *         email:
 *           type: string
 *           format: email
 *         password:
 *           type: string
 *         rememberMe:
 *           type: boolean
 */

/**
 * @swagger
 * /api/auth/register:
 *   post:
 *     summary: Register a new user
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/RegisterRequest'
 *     responses:
 *       201:
 *         description: User registered successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: object
 *                   properties:
 *                     user:
 *                       $ref: '#/components/schemas/User'
 *       400:
 *         description: Validation error or user already exists
 */
router.post('/register', authLimiter, validateRegister, authController.register);

/**
 * @swagger
 * /api/auth/login:
 *   post:
 *     summary: Login user
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/LoginRequest'
 *     responses:
 *       200:
 *         description: Login successful
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: object
 *                   properties:
 *                     user:
 *                       $ref: '#/components/schemas/User'
 *                     accessToken:
 *                       type: string
 *       401:
 *         description: Invalid credentials
 */
router.post('/login', authLimiter, validateLogin, authController.login);

/**
 * @swagger
 * /api/auth/refresh-token:
 *   post:
 *     summary: Refresh access token
 *     tags: [Authentication]
 *     requestBody:
 *       required: false
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               refreshToken:
 *                 type: string
 *     responses:
 *       200:
 *         description: Token refreshed successfully
 *       401:
 *         description: Invalid refresh token
 */
router.post('/refresh-token', authController.refreshToken);

/**
 * @swagger
 * /api/auth/logout:
 *   post:
 *     summary: Logout user
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Logout successful
 */
router.post('/logout', authMiddleware, authController.logout);

/**
 * @swagger
 * /api/auth/verify-email/{token}:
 *   get:
 *     summary: Verify email address
 *     tags: [Authentication]
 *     parameters:
 *       - in: path
 *         name: token
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Email verified successfully
 *       400:
 *         description: Invalid verification token
 */
router.get('/verify-email/:token', authController.verifyEmail);

/**
 * @swagger
 * /api/auth/resend-verification:
 *   post:
 *     summary: Resend email verification
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *     responses:
 *       200:
 *         description: Verification email sent
 *       400:
 *         description: Invalid email or already verified
 */
router.post('/resend-verification', authLimiter, validateResendVerification, authController.resendVerification);

/**
 * @swagger
 * /api/auth/forgot-password:
 *   post:
 *     summary: Request password reset
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *     responses:
 *       200:
 *         description: Password reset email sent if email exists
 */
router.post('/forgot-password', authLimiter, validateForgotPassword, authController.forgotPassword);

/**
 * @swagger
 * /api/auth/reset-password:
 *   post:
 *     summary: Reset password
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - token
 *               - password
 *               - confirmPassword
 *             properties:
 *               token:
 *                 type: string
 *               password:
 *                 type: string
 *                 minLength: 8
 *               confirmPassword:
 *                 type: string
 *     responses:
 *       200:
 *         description: Password reset successful
 *       400:
 *         description: Invalid token or validation error
 */
router.post('/reset-password', authLimiter, sensitiveOperation, validateResetPassword, authController.resetPassword);

/**
 * @swagger
 * /api/auth/me:
 *   get:
 *     summary: Get current user information
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: User information retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 data:
 *                   type: object
 *                   properties:
 *                     user:
 *                       $ref: '#/components/schemas/User'
 *       401:
 *         description: Authentication required
 */
router.get('/me', authMiddleware, authController.me);

/**
 * @swagger
 * /api/auth/check-email:
 *   get:
 *     summary: Check if email is available
 *     tags: [Authentication]
 *     parameters:
 *       - in: query
 *         name: email
 *         required: true
 *         schema:
 *           type: string
 *           format: email
 *     responses:
 *       200:
 *         description: Email availability checked
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 data:
 *                   type: object
 *                   properties:
 *                     available:
 *                       type: boolean
 */
router.get('/check-email', checkLimiter, authController.checkEmail);

/**
 * @swagger
 * /api/auth/check-username:
 *   get:
 *     summary: Check if username is available
 *     tags: [Authentication]
 *     parameters:
 *       - in: query
 *         name: username
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Username availability checked
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 data:
 *                   type: object
 *                   properties:
 *                     available:
 *                       type: boolean
 */
router.get('/check-username', checkLimiter, authController.checkUsername);

module.exports = router;

```

---

### üìÑ `../backend/src/routes/commentRoutes.js`

**üìè Dimensione:** 1.5 KB | **üìù Righe:** 58

```js
const express = require('express');
const router = express.Router();
const { authMiddleware } = require('../middleware/authMiddleware');

// GET /api/comments/:postId - Get comments for a post
router.get('/:postId', async (req, res) => {
    try {
        const { postId } = req.params;
        
        // Return mock comments
        res.json({
            success: true,
            data: []
        });
    } catch (error) {
        console.error('Error getting comments:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

// POST /api/comments - Create new comment
router.post('/', authMiddleware, async (req, res) => {
    try {
        const { postId, content } = req.body;
        
        if (!postId || !content) {
            return res.status(400).json({
                success: false,
                message: 'Post ID e contenuto sono richiesti'
            });
        }
        
        // Return mock success
        res.status(201).json({
            success: true,
            message: 'Commento creato con successo',
            data: {
                id: Date.now(),
                postId,
                content,
                author: req.user.username,
                createdAt: new Date().toISOString()
            }
        });
    } catch (error) {
        console.error('Error creating comment:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

module.exports = router;

```

---

### üìÑ `../backend/src/routes/gamificationRoutes.js`

**üìè Dimensione:** 1.4 KB | **üìù Righe:** 52

```js
const express = require('express');
const router = express.Router();
const { authMiddleware } = require('../middleware/authMiddleware');

// GET /api/gamification/leaderboard - Get leaderboard
router.get('/leaderboard', async (req, res) => {
    try {
        // Return mock leaderboard
        res.json({
            success: true,
            data: [
                {
                    rank: 1,
                    username: 'UgoFan1',
                    points: 1000,
                    level: 5
                }
            ]
        });
    } catch (error) {
        console.error('Error getting leaderboard:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

// GET /api/gamification/user-stats - Get user stats
router.get('/user-stats', authMiddleware, async (req, res) => {
    try {
        // Return mock user stats
        res.json({
            success: true,
            data: {
                points: 100,
                level: 2,
                badges: ['Primo Post', 'Quiz Master'],
                achievements: []
            }
        });
    } catch (error) {
        console.error('Error getting user stats:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

module.exports = router;

```

---

### üìÑ `../backend/src/routes/notificationRoutes.js`

**üìè Dimensione:** 1.1 KB | **üìù Righe:** 42

```js
const express = require('express');
const router = express.Router();
const { authMiddleware } = require('../middleware/authMiddleware');

// GET /api/notifications - Get user notifications
router.get('/', authMiddleware, async (req, res) => {
    try {
        // Return mock notifications
        res.json({
            success: true,
            data: []
        });
    } catch (error) {
        console.error('Error getting notifications:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

// POST /api/notifications/mark-read - Mark notification as read
router.post('/mark-read', authMiddleware, async (req, res) => {
    try {
        const { notificationId } = req.body;
        
        // Return mock success
        res.json({
            success: true,
            message: 'Notifica segnata come letta'
        });
    } catch (error) {
        console.error('Error marking notification as read:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

module.exports = router;

```

---

### üìÑ `../backend/src/routes/photoBoothRoutes.js`

**üìè Dimensione:** 1.9 KB | **üìù Righe:** 70

```js
const express = require('express');
const router = express.Router();
const multer = require('multer');
const { authMiddleware } = require('../middleware/authMiddleware');

// Configure multer for photo uploads
const storage = multer.memoryStorage();
const upload = multer({ 
    storage: storage,
    limits: {
        fileSize: 5 * 1024 * 1024 // 5MB limit
    },
    fileFilter: (req, file, cb) => {
        if (file.mimetype.startsWith('image/')) {
            cb(null, true);
        } else {
            cb(new Error('Solo immagini sono permesse!'), false);
        }
    }
});

// POST /api/photobooth/upload - Upload photo
router.post('/upload', authMiddleware, upload.single('photo'), async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({
                success: false,
                message: 'Nessuna foto fornita'
            });
        }

        // Return mock success
        res.json({
            success: true,
            message: 'Foto caricata con successo',
            data: {
                id: Date.now(),
                filename: `photo_${Date.now()}.jpg`,
                size: req.file.size,
                uploadedAt: new Date().toISOString()
            }
        });
    } catch (error) {
        console.error('Error uploading photo:', error);
        res.status(500).json({
            success: false,
            message: 'Errore nel caricamento della foto'
        });
    }
});

// GET /api/photobooth/gallery - Get user gallery
router.get('/gallery', authMiddleware, async (req, res) => {
    try {
        // Return mock gallery
        res.json({
            success: true,
            data: []
        });
    } catch (error) {
        console.error('Error getting gallery:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

module.exports = router;

```

---

### üìÑ `../backend/src/routes/postRoutes.js`

**üìè Dimensione:** 13.0 KB | **üìù Righe:** 529

```js
const express = require('express');
const postController = require('../controllers/postController');
const { authMiddleware, adminOnly, optionalAuth } = require('../middleware/authMiddleware');
const {
  validateCreatePost,
  validateUpdatePost,
  validateSharePost,
  validateGetPostsQuery,
  validateSlug,
  validateId
} = require('../validators/postValidators');

const router = express.Router();

/**
 * @swagger
 * components:
 *   schemas:
 *     Post:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *         title:
 *           type: string
 *         content:
 *           type: string
 *         excerpt:
 *           type: string
 *         slug:
 *           type: string
 *         coverImage:
 *           type: string
 *         published:
 *           type: boolean
 *         featured:
 *           type: boolean
 *         publishedAt:
 *           type: string
 *           format: date-time
 *         views:
 *           type: integer
 *         readingTime:
 *           type: integer
 *         author:
 *           $ref: '#/components/schemas/User'
 *         tags:
 *           type: array
 *           items:
 *             type: string
 *         categories:
 *           type: array
 *           items:
 *             type: string
 *         _count:
 *           type: object
 *           properties:
 *             likes:
 *               type: integer
 *             comments:
 *               type: integer
 *             shares:
 *               type: integer
 *     
 *     CreatePostRequest:
 *       type: object
 *       required:
 *         - title
 *         - content
 *       properties:
 *         title:
 *           type: string
 *           minLength: 5
 *           maxLength: 200
 *         content:
 *           type: string
 *           minLength: 50
 *         excerpt:
 *           type: string
 *           maxLength: 300
 *         coverImage:
 *           type: string
 *           format: uri
 *         published:
 *           type: boolean
 *           default: false
 *         featured:
 *           type: boolean
 *           default: false
 *         scheduledFor:
 *           type: string
 *           format: date-time
 *         tags:
 *           type: array
 *           items:
 *             type: string
 *           maxItems: 10
 *         categories:
 *           type: array
 *           items:
 *             type: string
 *           maxItems: 5
 *         seoTitle:
 *           type: string
 *           maxLength: 60
 *         seoDescription:
 *           type: string
 *           maxLength: 160
 */

/**
 * @swagger
 * /api/posts:
 *   get:
 *     summary: Get all posts
 *     tags: [Posts]
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           minimum: 1
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           minimum: 1
 *           maximum: 50
 *           default: 10
 *       - in: query
 *         name: published
 *         schema:
 *           type: string
 *           enum: [true, false]
 *       - in: query
 *         name: featured
 *         schema:
 *           type: string
 *           enum: [true, false]
 *       - in: query
 *         name: author
 *         schema:
 *           type: string
 *       - in: query
 *         name: tag
 *         schema:
 *           type: string
 *       - in: query
 *         name: category
 *         schema:
 *           type: string
 *       - in: query
 *         name: search
 *         schema:
 *           type: string
 *           minLength: 2
 *           maxLength: 100
 *       - in: query
 *         name: sortBy
 *         schema:
 *           type: string
 *           enum: [publishedAt, createdAt, updatedAt, title, views]
 *           default: publishedAt
 *       - in: query
 *         name: sortOrder
 *         schema:
 *           type: string
 *           enum: [asc, desc]
 *           default: desc
 *     responses:
 *       200:
 *         description: Posts retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 data:
 *                   type: object
 *                   properties:
 *                     posts:
 *                       type: array
 *                       items:
 *                         $ref: '#/components/schemas/Post'
 *                     pagination:
 *                       type: object
 *                       properties:
 *                         page:
 *                           type: integer
 *                         limit:
 *                           type: integer
 *                         total:
 *                           type: integer
 *                         pages:
 *                           type: integer
 *                         hasNext:
 *                           type: boolean
 *                         hasPrev:
 *                           type: boolean
 */
router.get('/', validateGetPostsQuery, optionalAuth, postController.getPosts);

/**
 * @swagger
 * /api/posts/popular:
 *   get:
 *     summary: Get popular posts
 *     tags: [Posts]
 *     parameters:
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           minimum: 1
 *           maximum: 20
 *           default: 5
 *     responses:
 *       200:
 *         description: Popular posts retrieved successfully
 */
router.get('/popular', postController.getPopularPosts);

/**
 * @swagger
 * /api/posts/my:
 *   get:
 *     summary: Get current user's posts
 *     tags: [Posts]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *       - in: query
 *         name: published
 *         schema:
 *           type: string
 *           enum: [true, false]
 *     responses:
 *       200:
 *         description: User posts retrieved successfully
 *       401:
 *         description: Authentication required
 */
router.get('/my', authMiddleware, postController.getMyPosts);

/**
 * @swagger
 * /api/posts:
 *   post:
 *     summary: Create a new post (Admin only)
 *     tags: [Posts]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreatePostRequest'
 *     responses:
 *       201:
 *         description: Post created successfully
 *       400:
 *         description: Validation error
 *       401:
 *         description: Authentication required
 *       403:
 *         description: Admin access required
 */
router.post('/', authMiddleware, adminOnly, validateCreatePost, postController.createPost);

/**
 * @swagger
 * /api/posts/{slug}:
 *   get:
 *     summary: Get post by slug
 *     tags: [Posts]
 *     parameters:
 *       - in: path
 *         name: slug
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Post retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 data:
 *                   type: object
 *                   properties:
 *                     post:
 *                       $ref: '#/components/schemas/Post'
 *       404:
 *         description: Post not found
 */
router.get('/:slug', validateSlug, optionalAuth, postController.getPost);

/**
 * @swagger
 * /api/posts/{id}:
 *   put:
 *     summary: Update post
 *     tags: [Posts]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CreatePostRequest'
 *     responses:
 *       200:
 *         description: Post updated successfully
 *       400:
 *         description: Validation error
 *       401:
 *         description: Authentication required
 *       403:
 *         description: Not authorized to update this post
 *       404:
 *         description: Post not found
 */
router.put('/:id', validateId, authMiddleware, validateUpdatePost, postController.updatePost);

/**
 * @swagger
 * /api/posts/{id}:
 *   delete:
 *     summary: Delete post
 *     tags: [Posts]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Post deleted successfully
 *       401:
 *         description: Authentication required
 *       403:
 *         description: Not authorized to delete this post
 *       404:
 *         description: Post not found
 */
router.delete('/:id', validateId, authMiddleware, postController.deletePost);

/**
 * @swagger
 * /api/posts/{id}/like:
 *   post:
 *     summary: Like/Unlike post
 *     tags: [Posts]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Like toggled successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: object
 *                   properties:
 *                     liked:
 *                       type: boolean
 *       401:
 *         description: Authentication required
 */
router.post('/:id/like', validateId, authMiddleware, postController.toggleLike);

/**
 * @swagger
 * /api/posts/{id}/share:
 *   post:
 *     summary: Share post
 *     tags: [Posts]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: false
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               platform:
 *                 type: string
 *                 enum: [facebook, twitter, linkedin, whatsapp, telegram, email, copy]
 *     responses:
 *       200:
 *         description: Post shared successfully
 *       401:
 *         description: Authentication required
 */
router.post('/:id/share', validateId, authMiddleware, validateSharePost, postController.sharePost);

/**
 * @swagger
 * /api/posts/{id}/related:
 *   get:
 *     summary: Get related posts
 *     tags: [Posts]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           minimum: 1
 *           maximum: 10
 *           default: 3
 *     responses:
 *       200:
 *         description: Related posts retrieved successfully
 */
router.get('/:id/related', validateId, postController.getRelatedPosts);

/**
 * @swagger
 * /api/posts/{id}/analytics:
 *   get:
 *     summary: Get post analytics (Admin only)
 *     tags: [Posts]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *       - in: query
 *         name: days
 *         schema:
 *           type: integer
 *           minimum: 1
 *           maximum: 365
 *           default: 30
 *     responses:
 *       200:
 *         description: Post analytics retrieved successfully
 *       401:
 *         description: Authentication required
 *       403:
 *         description: Admin access required
 *       404:
 *         description: Post not found
 */
router.get('/:id/analytics', validateId, authMiddleware, adminOnly, postController.getPostAnalytics);

/**
 * @swagger
 * /api/posts/{id}/preview:
 *   get:
 *     summary: Preview post (including drafts)
 *     tags: [Posts]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Post preview retrieved successfully
 *       401:
 *         description: Authentication required
 *       403:
 *         description: Not authorized to preview this post
 *       404:
 *         description: Post not found
 */
router.get('/:id/preview', validateId, authMiddleware, postController.previewPost);

module.exports = router;

```

---

### üìÑ `../backend/src/routes/publicIntegrationRoutes.js`

**üìè Dimensione:** 4.3 KB | **üìù Righe:** 129

```js
const express = require('express');
const router = express.Router();
const { body } = require('express-validator');
const rateLimit = require('express-rate-limit');
const supabase = require('../config/supabase');

// Shared response helper
function respond(res, success, data, error, status=200) {
  return res.status(status).json({ success, data, error });
}

// Rate limiters (stricter)
const newsletterLimiter = rateLimit({ windowMs: 60 * 1000, max: 5 });
const contactLimiter = rateLimit({ windowMs: 60 * 1000, max: 5 });
const uploadLimiter = rateLimit({ windowMs: 60 * 1000, max: 3 });

// Middleware validation result handler
const { validationResult } = require('express-validator');
function validate(req, res, next) {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return respond(res, false, null, { message: 'Validation failed', errors: errors.array() }, 422);
  }
  next();
}

// Newsletter subscribe
router.post('/newsletter', newsletterLimiter, [
  body('email').isEmail().withMessage('Email non valida')
], validate, async (req, res) => {
  const { email } = req.body;
  try {
    const { data, error } = await supabase
      .from('newsletter_subscribers')
      .insert({ email })
      .select();
    if (error) {
      console.error('[newsletter insert error]', error);
      throw error;
    }
    console.log('[newsletter insert ok]', data);
    return respond(res, true, data[0], null, 201);
  } catch (err) {
    return respond(res, false, null, { message: err.message, stack: process.env.NODE_ENV==='development'?err.stack:undefined }, 500);
  }
});

// Contact form
router.post('/contact', contactLimiter, [
  body('name').trim().isLength({ min: 2, max: 100 }).withMessage('Nome non valido'),
  body('email').isEmail().withMessage('Email non valida'),
  body('message').trim().isLength({ min: 5, max: 2000 }).withMessage('Messaggio troppo corto')
], validate, async (req, res) => {
  const { name, email, message } = req.body;
  try {
    const { data, error } = await supabase
      .from('contacts')
      .insert({ name, email, message })
      .select();
    if (error) { console.error('[contact insert error]', error); throw error; }
    console.log('[contact insert ok]', data);
    return respond(res, true, data[0], null, 201);
  } catch (err) {
    return respond(res, false, null, { message: err.message }, 500);
  }
});

// Upload (base64 / multipart handled externally) ‚Äî here expect single file via multipart
const multer = require('multer');
const crypto = require('crypto');
const path = require('path');

const storage = multer.memoryStorage();
const upload = multer({
  storage,
  limits: { fileSize: (parseInt(process.env.MAX_FILE_SIZE) || 5 * 1024 * 1024) },
  fileFilter: (req, file, cb) => {
    const allowed = (process.env.ALLOWED_FILE_TYPES || 'image/jpeg,image/png,image/webp').split(',');
    if (!allowed.includes(file.mimetype)) {
      return cb(new Error('Tipo file non consentito'));
    }
    cb(null, true);
  }
});

router.post('/upload', uploadLimiter, upload.single('file'), async (req, res) => {
  if (!req.file) return respond(res, false, null, { message: 'Nessun file' }, 400);
  try {
    const ext = path.extname(req.file.originalname).toLowerCase();
    const safeName = req.file.originalname.replace(/[^a-zA-Z0-9_.-]/g, '_');
    const filename = `${Date.now()}_${crypto.randomBytes(6).toString('hex')}_${safeName}`;

    // Upload to storage bucket 'uploads'
    const { error: storageError } = await supabase.storage
      .from('uploads')
      .upload(filename, req.file.buffer, {
        cacheControl: '3600',
        contentType: req.file.mimetype,
        upsert: false
      });
    if (storageError) throw storageError;

    const { data: publicUrlData } = supabase.storage
      .from('uploads')
      .getPublicUrl(filename);

    const publicUrl = publicUrlData?.publicUrl;

    // Save metadata
    const { data: meta, error: metaErr } = await supabase
      .from('uploads')
      .insert({
        path: filename,
        url: publicUrl,
        filename: req.file.originalname,
        content_type: req.file.mimetype,
        size: req.file.size
      })
      .select();
    if (metaErr) throw metaErr;

    return respond(res, true, { publicUrl, metadata: meta[0] }, null, 201);
  } catch (err) {
    return respond(res, false, null, { message: err.message }, 500);
  }
});

module.exports = router;

```

---

### üìÑ `../backend/src/routes/quizRoutes.js`

**üìè Dimensione:** 1.6 KB | **üìù Righe:** 60

```js
const express = require('express');
const router = express.Router();

// GET /api/quiz - Get available quizzes
router.get('/', async (req, res) => {
    try {
        // Return mock quiz data
        res.json({
            success: true,
            data: [
                {
                    id: 1,
                    title: 'Quiz di Benvenuto',
                    description: 'Un quiz per conoscere meglio Ugo!',
                    questions: 5,
                    difficulty: 'facile'
                }
            ]
        });
    } catch (error) {
        console.error('Error getting quizzes:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

// GET /api/quiz/:id - Get specific quiz
router.get('/:id', async (req, res) => {
    try {
        const { id } = req.params;
        
        // Return mock quiz
        res.json({
            success: true,
            data: {
                id: parseInt(id),
                title: 'Quiz di Benvenuto',
                questions: [
                    {
                        id: 1,
                        question: 'Chi √® Ugo?',
                        options: ['Un AI', 'Un cane', 'Un gatto', 'Un pesce'],
                        correct: 0
                    }
                ]
            }
        });
    } catch (error) {
        console.error('Error getting quiz:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

module.exports = router;

```

---

### üìÑ `../backend/src/routes/ugoAI.js`

**üìè Dimensione:** 12.2 KB | **üìù Righe:** 453

```js
const express = require('express');
const { body, param, query, validationResult } = require('express-validator');
const UgoAICompanion = require('../services/ugoAICompanion');
const ConversationMemory = require('../services/conversationMemory');
const UgoPersonality = require('../services/ugoPersonality');
const EmotionEngine = require('../services/emotionEngine');
const { authMiddleware } = require('../middleware/authMiddleware');
const logger = require('../utils/logger');

const router = express.Router();

// Inizializza servizi AI
const ugoAI = new UgoAICompanion();
const conversationMemory = new ConversationMemory();
const ugoPersonality = new UgoPersonality();
const emotionEngine = new EmotionEngine();

/**
 * POST /api/ugo-ai/chat
 * Chat principale con Ugo AI Companion
 */
router.post('/chat', 
  authMiddleware,
  [
    body('message')
      .notEmpty()
      .withMessage('Il messaggio √® obbligatorio')
      .isLength({ max: 500 })
      .withMessage('Il messaggio non pu√≤ superare i 500 caratteri'),
    body('sessionId')
      .optional()
      .isString()
      .withMessage('Session ID deve essere una stringa'),
    body('context')
      .optional()
      .isObject()
      .withMessage('Context deve essere un oggetto')
  ],
  async (req, res) => {
    try {
      // Valida input
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'Dati non validi',
          errors: errors.array()
        });
      }

      const { message, sessionId, context } = req.body;
      const userId = req.user.id;

      logger.info(`UgoAI chat request from user ${userId}: "${message.substring(0, 50)}..."`);

      // Chat con Ugo
      const response = await ugoAI.chat(message, userId, sessionId);

      // Log risposta per monitoring
      logger.info(`UgoAI response to user ${userId}: mood=${response.mood}, length=${response.response.length}`);

      res.json({
        success: true,
        data: {
          message: response.response,
          mood: response.mood,
          personality: response.personality,
          context: response.context,
          sessionId: sessionId || 'default',
          timestamp: new Date().toISOString()
        }
      });

    } catch (error) {
      logger.error('UgoAI chat error:', error);
      res.status(500).json({
        success: false,
        message: 'Errore durante la conversazione con Ugo',
        error: process.env.NODE_ENV === 'development' ? error.message : 'Errore interno'
      });
    }
  }
);

/**
 * GET /api/ugo-ai/personality
 * Ottieni stato personalit√† di Ugo
 */
router.get('/personality', authMiddleware, async (req, res) => {
  try {
    const personality = ugoPersonality.getCurrentState();
    const emotionalSummary = emotionEngine.getEmotionalSummary();

    res.json({
      success: true,
      data: {
        personality,
        emotions: emotionalSummary,
        interactionSuggestions: emotionEngine.getInteractionSuggestions()
      }
    });

  } catch (error) {
    logger.error('Error getting personality:', error);
    res.status(500).json({
      success: false,
      message: 'Errore nel recupero della personalit√† di Ugo'
    });
  }
});

/**
 * POST /api/ugo-ai/personality/feedback
 * Fornisci feedback per evoluzione personalit√†
 */
router.post('/personality/feedback',
  authMiddleware,
  [
    body('feedback')
      .isIn(['positive', 'negative', 'neutral'])
      .withMessage('Feedback deve essere positive, negative o neutral'),
    body('interactionType')
      .optional()
      .isString()
      .withMessage('Interaction type deve essere una stringa'),
    body('conversationId')
      .optional()
      .isString()
      .withMessage('Conversation ID deve essere una stringa')
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'Dati non validi',
          errors: errors.array()
        });
      }

      const { feedback, interactionType, conversationId } = req.body;
      const userId = req.user.id;

      // Evolve personalit√† basandosi sul feedback
      ugoPersonality.evolvePersonality(feedback, interactionType, 'neutral');

      // Se specificato, aggiorna rating conversazione
      if (conversationId) {
        const rating = feedback === 'positive' ? 5 : feedback === 'negative' ? 1 : 3;
        await conversationMemory.updateConversationRating(userId, conversationId, rating);
      }

      logger.info(`Personality feedback from user ${userId}: ${feedback}`);

      res.json({
        success: true,
        message: 'Feedback ricevuto, Ugo sta imparando!',
        data: {
          updatedPersonality: ugoPersonality.getCurrentState()
        }
      });

    } catch (error) {
      logger.error('Error processing personality feedback:', error);
      res.status(500).json({
        success: false,
        message: 'Errore nell\'elaborazione del feedback'
      });
    }
  }
);

/**
 * GET /api/ugo-ai/memory/stats
 * Statistiche memoria conversazionale
 */
router.get('/memory/stats', authMiddleware, async (req, res) => {
  try {
    const userId = req.user.id;
    const memoryStats = await conversationMemory.getMemoryStats(userId);
    const userPatterns = await conversationMemory.getUserPatterns(userId);

    res.json({
      success: true,
      data: {
        memory: memoryStats,
        patterns: userPatterns
      }
    });

  } catch (error) {
    logger.error('Error getting memory stats:', error);
    res.status(500).json({
      success: false,
      message: 'Errore nel recupero delle statistiche memoria'
    });
  }
});

/**
 * GET /api/ugo-ai/conversation/history
 * Storia conversazioni
 */
router.get('/conversation/history',
  authMiddleware,
  [
    query('limit')
      .optional()
      .isInt({ min: 1, max: 50 })
      .withMessage('Limit deve essere tra 1 e 50'),
    query('sessionId')
      .optional()
      .isString()
      .withMessage('Session ID deve essere una stringa')
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'Parametri non validi',
          errors: errors.array()
        });
      }

      const { limit = 20, sessionId } = req.query;
      const userId = req.user.id;

      const context = await conversationMemory.getContext(userId, sessionId, parseInt(limit));

      res.json({
        success: true,
        data: {
          conversations: context,
          totalCount: context.length,
          sessionId: sessionId || 'default'
        }
      });

    } catch (error) {
      logger.error('Error getting conversation history:', error);
      res.status(500).json({
        success: false,
        message: 'Errore nel recupero della storia conversazioni'
      });
    }
  }
);

/**
 * POST /api/ugo-ai/emotion/force
 * Forza un mood specifico (per testing)
 */
router.post('/emotion/force',
  authMiddleware,
  [
    body('mood')
      .isIn(['excited', 'happy', 'curious', 'playful', 'calm', 'affectionate', 'alert', 'confused'])
      .withMessage('Mood non valido'),
    body('intensity')
      .optional()
      .isFloat({ min: 0, max: 1 })
      .withMessage('Intensity deve essere tra 0 e 1')
  ],
  async (req, res) => {
    try {
      // Solo in development mode
      if (process.env.NODE_ENV === 'production') {
        return res.status(403).json({
          success: false,
          message: 'Funzione disponibile solo in development'
        });
      }

      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'Dati non validi',
          errors: errors.array()
        });
      }

      const { mood, intensity = 0.8 } = req.body;

      emotionEngine.forceMood(mood, intensity);

      res.json({
        success: true,
        message: `Mood di Ugo forzato a: ${mood}`,
        data: {
          currentMood: mood,
          emotionalSummary: emotionEngine.getEmotionalSummary(),
          interactionSuggestions: emotionEngine.getInteractionSuggestions()
        }
      });

    } catch (error) {
      logger.error('Error forcing emotion:', error);
      res.status(500).json({
        success: false,
        message: 'Errore nel forzare l\'emozione'
      });
    }
  }
);

/**
 * POST /api/ugo-ai/train
 * Avvia training personalizzato di Ugo
 */
router.post('/train',
  authMiddleware,
  [
    body('includeStories')
      .optional()
      .isBoolean()
      .withMessage('Include stories deve essere boolean'),
    body('includeConversations')
      .optional()
      .isBoolean()
      .withMessage('Include conversations deve essere boolean'),
    body('minRating')
      .optional()
      .isInt({ min: 1, max: 5 })
      .withMessage('Min rating deve essere tra 1 e 5')
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'Parametri non validi',
          errors: errors.array()
        });
      }

      const { includeStories = true, includeConversations = true, minRating = 4 } = req.body;
      const userId = req.user.id;

      // TODO: Implementare raccolta dati per training
      const conversations = []; // await getTrainingConversations(userId, minRating);
      const stories = []; // await getTrainingStories();

      // Avvia training asincrono
      const trainingResult = await ugoAI.trainUgoPersonality(conversations, stories);

      logger.info(`Training initiated for user ${userId}:`, trainingResult);

      res.json({
        success: true,
        message: 'Training di Ugo avviato con successo!',
        data: trainingResult
      });

    } catch (error) {
      logger.error('Error starting training:', error);
      res.status(500).json({
        success: false,
        message: 'Errore nell\'avvio del training',
        error: process.env.NODE_ENV === 'development' ? error.message : 'Errore interno'
      });
    }
  }
);

/**
 * GET /api/ugo-ai/health
 * Health check per servizi AI
 */
router.get('/health', async (req, res) => {
  try {
    // Verifica stato Ollama
    const isOllamaHealthy = await ugoAI.checkOllamaHealth();
    
    // Verifica inizializzazione servizi
    const servicesStatus = {
      ugoAI: ugoAI.isInitialized,
      conversationMemory: true,
      personality: true,
      emotions: true,
      ollama: isOllamaHealthy
    };

    const allHealthy = Object.values(servicesStatus).every(status => status === true);

    res.status(allHealthy ? 200 : 503).json({
      success: allHealthy,
      message: allHealthy ? 'Tutti i servizi AI sono operativi' : 'Alcuni servizi AI non sono disponibili',
      data: {
        services: servicesStatus,
        timestamp: new Date().toISOString(),
        model: ugoAI.model,
        ollamaUrl: ugoAI.ollamaUrl
      }
    });

  } catch (error) {
    logger.error('AI health check error:', error);
    res.status(503).json({
      success: false,
      message: 'Errore nel controllo stato servizi AI',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Errore interno'
    });
  }
});

/**
 * GET /api/ugo-ai/stats
 * Statistiche generali AI
 */
router.get('/stats', authMiddleware, async (req, res) => {
  try {
    const userId = req.user.id;
    
    // Raccolta statistiche
    const [memoryStats, userPatterns, personalityStats] = await Promise.all([
      conversationMemory.getMemoryStats(userId),
      conversationMemory.getUserPatterns(userId),
      Promise.resolve(ugoPersonality.getEvolutionStats())
    ]);

    const emotionalSummary = emotionEngine.getEmotionalSummary();

    res.json({
      success: true,
      data: {
        memory: memoryStats,
        patterns: userPatterns,
        personality: personalityStats,
        emotions: emotionalSummary,
        ai: {
          model: ugoAI.model,
          initialized: ugoAI.isInitialized,
          ollamaHealthy: await ugoAI.checkOllamaHealth().catch(() => false)
        }
      }
    });

  } catch (error) {
    logger.error('Error getting AI stats:', error);
    res.status(500).json({
      success: false,
      message: 'Errore nel recupero delle statistiche AI'
    });
  }
});

module.exports = router;

```

---

### üìÑ `../backend/src/routes/userRoutes.js`

**üìè Dimensione:** 2.2 KB | **üìù Righe:** 79

```js
const express = require('express');
const router = express.Router();
const { authMiddleware } = require('../middleware/authMiddleware');

// GET /api/users/profile - Get user profile
router.get('/profile', authMiddleware, async (req, res) => {
    try {
        // Get user info from token (set by middleware)
        const userId = req.user.id;
        
        // Return user profile data
        res.json({
            success: true,
            data: {
                id: userId,
                username: req.user.username,
                email: req.user.email,
                createdAt: req.user.createdAt
            }
        });
    } catch (error) {
        console.error('Error getting user profile:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

// PUT /api/users/profile - Update user profile
router.put('/profile', authMiddleware, async (req, res) => {
    try {
        const userId = req.user.id;
        const { username, email } = req.body;
        
        // Here you would update user in database
        // For now, just return success
        res.json({
            success: true,
            message: 'Profilo aggiornato con successo',
            data: {
                id: userId,
                username: username || req.user.username,
                email: email || req.user.email
            }
        });
    } catch (error) {
        console.error('Error updating user profile:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

// GET /api/users/stats - Get user statistics
router.get('/stats', authMiddleware, async (req, res) => {
    try {
        // Return mock user statistics
        res.json({
            success: true,
            data: {
                postsCount: 0,
                commentsCount: 0,
                likesReceived: 0,
                joinDate: req.user.createdAt
            }
        });
    } catch (error) {
        console.error('Error getting user stats:', error);
        res.status(500).json({
            success: false,
            message: 'Errore interno del server'
        });
    }
});

module.exports = router;

```

---

### üìÑ `../backend/src/server.js`

**üìè Dimensione:** 2.8 KB | **üìù Righe:** 91

```js
const app = require('./app');
const { PrismaClient } = require('@prisma/client');
const logger = require('./utils/logger');
const socketService = require('./services/socketService');
const redisClient = require('./config/redis');

const prisma = new PrismaClient();
const PORT = process.env.PORT || 3000;
const HOST = process.env.HOST || 'localhost';
const ALLOW_START_WITHOUT_DB = process.env.ALLOW_START_WITHOUT_DB === 'true';

async function startServer() {
  try {
    // Test database connection
    try {
      await prisma.$connect();
      logger.info('‚úÖ Database connected successfully');
    } catch (dbErr) {
      if (ALLOW_START_WITHOUT_DB) {
        logger.warn('‚ö†Ô∏è Database connection failed but continuing due to ALLOW_START_WITHOUT_DB=true:', dbErr.message);
      } else {
        throw dbErr;
      }
    }

    // Test Redis connection
    try {
      await redisClient.ping();
      logger.info('‚úÖ Redis connected successfully');
    } catch (redisErr) {
      if (ALLOW_START_WITHOUT_DB) {
        logger.warn('‚ö†Ô∏è Redis connection failed but continuing due to ALLOW_START_WITHOUT_DB=true:', redisErr.message);
      } else {
        throw redisErr;
      }
    }

    // Start HTTP server
    const server = app.listen(PORT, HOST, () => {
      logger.info(`üöÄ Server running on http://${HOST}:${PORT}`);
      logger.info(`üìö API Documentation: http://${HOST}:${PORT}/api-docs`);
      logger.info(`üè• Health Check: http://${HOST}:${PORT}/health`);
      logger.info(`üåç Environment: ${process.env.NODE_ENV || 'development'}`);
      if (ALLOW_START_WITHOUT_DB) {
        logger.warn('‚ö†Ô∏è Running without confirmed DB/Redis connections. Do not use in production.');
      }
    });

    // Initialize Socket.io
    socketService.init(server);
    logger.info('‚úÖ Socket.io initialized');

    // Graceful shutdown
    const gracefulShutdown = async (signal) => {
      logger.info(`${signal} received, starting graceful shutdown...`);
      
      server.close(async () => {
        logger.info('HTTP server closed');
        
        try {
          await prisma.$disconnect();
          logger.info('Database disconnected');
          
          await redisClient.quit();
          logger.info('Redis disconnected');
          
          process.exit(0);
        } catch (error) {
          logger.error('Error during shutdown:', error);
          process.exit(1);
        }
      });
    };

    process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
    process.on('SIGINT', () => gracefulShutdown('SIGINT'));

    return server;
  } catch (error) {
    logger.error('‚ùå Failed to start server:', error);
    process.exit(1);
  }
}

// Start server only if this file is run directly
if (require.main === module) {
  startServer();
}

module.exports = { startServer };

```

---

### üìÑ `../backend/src/services/authService.js`

**üìè Dimensione:** 12.0 KB | **üìù Righe:** 496

```js
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const { PrismaClient } = require('@prisma/client');
const { cache } = require('../config/redis');
const emailService = require('./emailService');
const logger = require('../utils/logger');

const prisma = new PrismaClient();

class AuthService {
  // Generate JWT tokens
  generateTokens(userId) {
    const payload = { userId };
    
    const accessToken = jwt.sign(payload, process.env.JWT_SECRET, {
      expiresIn: process.env.JWT_EXPIRE || '15m'
    });
    
    const refreshToken = jwt.sign(payload, process.env.JWT_REFRESH_SECRET, {
      expiresIn: process.env.JWT_REFRESH_EXPIRE || '7d'
    });
    
    return { accessToken, refreshToken };
  }

  // Hash password
  async hashPassword(password) {
    return await bcrypt.hash(password, 12);
  }

  // Compare password
  async comparePassword(password, hashedPassword) {
    return await bcrypt.compare(password, hashedPassword);
  }

  // Generate secure random token
  generateSecureToken() {
    return crypto.randomBytes(32).toString('hex');
  }

  // Register new user
  async register(userData) {
    const { email, username, password, firstName, lastName } = userData;

    // Check if user already exists
    const existingUser = await prisma.user.findFirst({
      where: {
        OR: [
          { email: email.toLowerCase() },
          { username: username.toLowerCase() }
        ]
      }
    });

    if (existingUser) {
      if (existingUser.email === email.toLowerCase()) {
        throw new Error('Email already registered');
      }
      if (existingUser.username === username.toLowerCase()) {
        throw new Error('Username already taken');
      }
    }

    // Hash password
    const hashedPassword = await this.hashPassword(password);

    // Generate email verification token
    const emailVerificationToken = this.generateSecureToken();

    // Create user
    const user = await prisma.user.create({
      data: {
        email: email.toLowerCase(),
        username: username.toLowerCase(),
        password: hashedPassword,
        firstName,
        lastName,
        emailVerificationToken,
        isVerified: process.env.NODE_ENV === 'development' // Auto-verify in dev
      },
      select: {
        id: true,
        email: true,
        username: true,
        firstName: true,
        lastName: true,
        isVerified: true,
        createdAt: true
      }
    });

    // Send verification email (only in production)
    if (process.env.NODE_ENV === 'production') {
      await emailService.sendVerificationEmail(user, emailVerificationToken);
    }

    // Log user registration
    logger.info('User registered:', { userId: user.id, email: user.email });

    return user;
  }

  // Login user
  async login(email, password, ipAddress, userAgent) {
    // Find user by email
    const user = await prisma.user.findUnique({
      where: { email: email.toLowerCase() },
      include: {
        sessions: {
          where: {
            expiresAt: {
              gt: new Date()
            }
          }
        }
      }
    });

    if (!user) {
      throw new Error('Invalid credentials');
    }

    if (!user.isActive) {
      throw new Error('Account has been deactivated');
    }

    // Check password
    const isValidPassword = await this.comparePassword(password, user.password);
    if (!isValidPassword) {
      throw new Error('Invalid credentials');
    }

    if (!user.isVerified) {
      throw new Error('Please verify your email address');
    }

    // Generate tokens
    const { accessToken, refreshToken } = this.generateTokens(user.id);

    // Clean up old sessions (keep only 5 most recent)
    if (user.sessions.length >= 5) {
      const oldSessions = user.sessions
        .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
        .slice(4);
      
      await prisma.userSession.deleteMany({
        where: {
          id: {
            in: oldSessions.map(s => s.id)
          }
        }
      });
    }

    // Create new session
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7); // 7 days

    await prisma.userSession.create({
      data: {
        userId: user.id,
        token: accessToken,
        refreshToken,
        expiresAt,
        ipAddress,
        userAgent
      }
    });

    // Update last login and streak
    const now = new Date();
    const yesterday = new Date(now);
    yesterday.setDate(yesterday.getDate() - 1);
    
    let newStreak = user.streak;
    if (user.lastLogin) {
      const lastLoginDate = new Date(user.lastLogin);
      const daysDiff = Math.floor((now - lastLoginDate) / (1000 * 60 * 60 * 24));
      
      if (daysDiff === 1) {
        // Consecutive day login
        newStreak += 1;
      } else if (daysDiff > 1) {
        // Streak broken
        newStreak = 1;
      }
      // Same day login doesn't change streak
    } else {
      // First login
      newStreak = 1;
    }

    await prisma.user.update({
      where: { id: user.id },
      data: {
        lastLogin: now,
        lastActivity: now,
        streak: newStreak
      }
    });

    // Cache user data
    const userForCache = {
      id: user.id,
      email: user.email,
      username: user.username,
      firstName: user.firstName,
      lastName: user.lastName,
      avatar: user.avatar,
      isAdmin: user.isAdmin,
      isVerified: user.isVerified,
      isActive: user.isActive,
      points: user.points,
      level: user.level,
      streak: newStreak
    };

    await cache.setWithPattern(`user:${user.id}`, userForCache, 900);

    // Log successful login
    logger.info('User logged in:', { 
      userId: user.id, 
      email: user.email, 
      ipAddress,
      streak: newStreak
    });

    return {
      user: userForCache,
      tokens: { accessToken, refreshToken }
    };
  }

  // Refresh token
  async refreshToken(refreshToken) {
    try {
      const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);
      
      // Find session
      const session = await prisma.userSession.findFirst({
        where: {
          refreshToken,
          userId: decoded.userId,
          expiresAt: {
            gt: new Date()
          }
        },
        include: {
          user: {
            select: {
              id: true,
              email: true,
              username: true,
              firstName: true,
              lastName: true,
              avatar: true,
              isAdmin: true,
              isVerified: true,
              isActive: true,
              points: true,
              level: true,
              streak: true
            }
          }
        }
      });

      if (!session || !session.user.isActive || !session.user.isVerified) {
        throw new Error('Invalid refresh token');
      }

      // Generate new tokens
      const tokens = this.generateTokens(session.userId);

      // Update session
      await prisma.userSession.update({
        where: { id: session.id },
        data: {
          token: tokens.accessToken,
          refreshToken: tokens.refreshToken
        }
      });

      // Update cache
      await cache.setWithPattern(`user:${session.user.id}`, session.user, 900);

      return {
        user: session.user,
        tokens
      };
    } catch (error) {
      throw new Error('Invalid refresh token');
    }
  }

  // Logout user
  async logout(token, refreshToken) {
    try {
      // Add token to blacklist
      await cache.set(`blacklist:${token}`, true, 900); // 15 minutes

      // Remove session
      if (refreshToken) {
        await prisma.userSession.deleteMany({
          where: { refreshToken }
        });
      }

      logger.info('User logged out');
    } catch (error) {
      logger.error('Logout error:', error);
    }
  }

  // Verify email
  async verifyEmail(token) {
    const user = await prisma.user.findFirst({
      where: { emailVerificationToken: token }
    });

    if (!user) {
      throw new Error('Invalid verification token');
    }

    if (user.isVerified) {
      throw new Error('Email already verified');
    }

    // Update user
    await prisma.user.update({
      where: { id: user.id },
      data: {
        isVerified: true,
        emailVerificationToken: null
      }
    });

    // Award registration achievement
    await this.awardAchievement(user.id, 'first-friend');

    logger.info('Email verified:', { userId: user.id, email: user.email });

    return { message: 'Email verified successfully' };
  }

  // Resend verification email
  async resendVerification(email) {
    const user = await prisma.user.findUnique({
      where: { email: email.toLowerCase() }
    });

    if (!user) {
      throw new Error('User not found');
    }

    if (user.isVerified) {
      throw new Error('Email already verified');
    }

    // Generate new token
    const emailVerificationToken = this.generateSecureToken();

    await prisma.user.update({
      where: { id: user.id },
      data: { emailVerificationToken }
    });

    // Send verification email
    await emailService.sendVerificationEmail(user, emailVerificationToken);

    return { message: 'Verification email sent' };
  }

  // Forgot password
  async forgotPassword(email) {
    const user = await prisma.user.findUnique({
      where: { email: email.toLowerCase() }
    });

    if (!user) {
      // Don't reveal if email exists
      return { message: 'If the email exists, a reset link has been sent' };
    }

    // Generate reset token
    const resetToken = this.generateSecureToken();
    const resetExpires = new Date();
    resetExpires.setHours(resetExpires.getHours() + 1); // 1 hour

    await prisma.user.update({
      where: { id: user.id },
      data: {
        passwordResetToken: resetToken,
        passwordResetExpires: resetExpires
      }
    });

    // Send reset email
    await emailService.sendPasswordResetEmail(user, resetToken);

    logger.info('Password reset requested:', { userId: user.id, email: user.email });

    return { message: 'If the email exists, a reset link has been sent' };
  }

  // Reset password
  async resetPassword(token, newPassword) {
    const user = await prisma.user.findFirst({
      where: {
        passwordResetToken: token,
        passwordResetExpires: {
          gt: new Date()
        }
      }
    });

    if (!user) {
      throw new Error('Invalid or expired reset token');
    }

    // Hash new password
    const hashedPassword = await this.hashPassword(newPassword);

    // Update user
    await prisma.user.update({
      where: { id: user.id },
      data: {
        password: hashedPassword,
        passwordResetToken: null,
        passwordResetExpires: null
      }
    });

    // Invalidate all sessions
    await prisma.userSession.deleteMany({
      where: { userId: user.id }
    });

    // Remove user from cache
    await cache.del(`ugo:user:${user.id}`);

    logger.info('Password reset successful:', { userId: user.id, email: user.email });

    return { message: 'Password reset successful' };
  }

  // Helper method to award achievements
  async awardAchievement(userId, achievementKey) {
    try {
      const achievement = await prisma.achievement.findFirst({
        where: { name: achievementKey }
      });

      if (!achievement) return;

      // Check if user already has this achievement
      const existing = await prisma.userAchievement.findFirst({
        where: {
          userId,
          achievementId: achievement.id
        }
      });

      if (!existing) {
        await prisma.userAchievement.create({
          data: {
            userId,
            achievementId: achievement.id
          }
        });

        // Award points
        await prisma.user.update({
          where: { id: userId },
          data: {
            points: {
              increment: achievement.points
            }
          }
        });

        logger.info('Achievement awarded:', { 
          userId, 
          achievement: achievement.name, 
          points: achievement.points 
        });
      }
    } catch (error) {
      logger.error('Award achievement error:', error);
    }
  }
}

module.exports = new AuthService();

```

---

### üìÑ `../backend/src/services/commentService.js`

**üìè Dimensione:** 13.4 KB | **üìù Righe:** 572

```js
const { PrismaClient } = require('@prisma/client');
const { cache } = require('../config/redis');
const logger = require('../utils/logger');

const prisma = new PrismaClient();

class CommentService {
  // Create a new comment
  async createComment(authorId, postId, content, parentId = null) {
    // Check if post exists and is published
    const post = await prisma.post.findUnique({
      where: { id: postId },
      select: { id: true, published: true, title: true }
    });

    if (!post) {
      throw new Error('Post not found');
    }

    if (!post.published) {
      throw new Error('Cannot comment on unpublished posts');
    }

    // If it's a reply, check if parent comment exists
    if (parentId) {
      const parentComment = await prisma.comment.findFirst({
        where: {
          id: parentId,
          postId: postId
        }
      });

      if (!parentComment) {
        throw new Error('Parent comment not found');
      }
    }

    // Create the comment
    const comment = await prisma.comment.create({
      data: {
        content,
        authorId,
        postId,
        parentId,
        isApproved: process.env.NODE_ENV === 'development' // Auto-approve in development
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            firstName: true,
            lastName: true,
            avatar: true
          }
        },
        replies: {
          include: {
            author: {
              select: {
                id: true,
                username: true,
                firstName: true,
                lastName: true,
                avatar: true
              }
            }
          }
        }
      }
    });

    // Award points for commenting
    await prisma.user.update({
      where: { id: authorId },
      data: {
        points: {
          increment: 10
        }
      }
    });

    // Clear post cache to update comment count
    await this.clearPostCommentCache(postId);

    // Create notification for post author (if different from commenter)
    if (post.authorId !== authorId) {
      await this.createCommentNotification(post, comment, 'comment');
    }

    // If it's a reply, notify the parent comment author
    if (parentId) {
      const parentComment = await prisma.comment.findUnique({
        where: { id: parentId },
        include: { author: true }
      });

      if (parentComment && parentComment.authorId !== authorId) {
        await this.createCommentNotification(post, comment, 'reply', parentComment);
      }
    }

    logger.info('Comment created:', { 
      commentId: comment.id, 
      postId, 
      authorId, 
      isReply: !!parentId 
    });

    return comment;
  }

  // Get comments for a post
  async getPostComments(postId, options = {}) {
    const {
      page = 1,
      limit = 10,
      sortBy = 'createdAt',
      sortOrder = 'desc',
      includeReplies = true,
      approved = true
    } = options;

    const skip = (page - 1) * limit;

    // Build where clause
    const where = {
      postId,
      parentId: null, // Only top-level comments
      ...(approved !== undefined && { isApproved: approved })
    };

    // Generate cache key
    const cacheKey = `comments:${postId}:${JSON.stringify(options)}`;
    
    // Try cache first
    let cachedResult = await cache.getWithPattern(cacheKey);
    if (cachedResult) {
      return cachedResult;
    }

    const [comments, total] = await Promise.all([
      prisma.comment.findMany({
        where,
        skip,
        take: limit,
        orderBy: {
          [sortBy]: sortOrder
        },
        include: {
          author: {
            select: {
              id: true,
              username: true,
              firstName: true,
              lastName: true,
              avatar: true
            }
          },
          ...(includeReplies && {
            replies: {
              where: {
                isApproved: approved
              },
              orderBy: {
                createdAt: 'asc'
              },
              include: {
                author: {
                  select: {
                    id: true,
                    username: true,
                    firstName: true,
                    lastName: true,
                    avatar: true
                  }
                }
              }
            }
          })
        }
      }),
      prisma.comment.count({ where })
    ]);

    const result = {
      comments,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
        hasNext: page < Math.ceil(total / limit),
        hasPrev: page > 1
      }
    };

    // Cache for 5 minutes
    await cache.setWithPattern(cacheKey, result, 300);

    return result;
  }

  // Update comment
  async updateComment(commentId, userId, content) {
    const comment = await prisma.comment.findUnique({
      where: { id: commentId },
      include: { author: true }
    });

    if (!comment) {
      throw new Error('Comment not found');
    }

    // Check if user owns the comment or is admin
    const user = await prisma.user.findUnique({ where: { id: userId } });
    if (comment.authorId !== userId && !user.isAdmin) {
      throw new Error('Not authorized to update this comment');
    }

    const updatedComment = await prisma.comment.update({
      where: { id: commentId },
      data: {
        content,
        updatedAt: new Date()
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            firstName: true,
            lastName: true,
            avatar: true
          }
        },
        replies: {
          include: {
            author: {
              select: {
                id: true,
                username: true,
                firstName: true,
                lastName: true,
                avatar: true
              }
            }
          }
        }
      }
    });

    // Clear cache
    await this.clearPostCommentCache(comment.postId);

    logger.info('Comment updated:', { commentId, userId });

    return updatedComment;
  }

  // Delete comment
  async deleteComment(commentId, userId) {
    const comment = await prisma.comment.findUnique({
      where: { id: commentId },
      include: { 
        author: true,
        replies: true
      }
    });

    if (!comment) {
      throw new Error('Comment not found');
    }

    // Check if user owns the comment or is admin
    const user = await prisma.user.findUnique({ where: { id: userId } });
    if (comment.authorId !== userId && !user.isAdmin) {
      throw new Error('Not authorized to delete this comment');
    }

    // Delete comment and all its replies (cascade)
    await prisma.comment.delete({
      where: { id: commentId }
    });

    // Clear cache
    await this.clearPostCommentCache(comment.postId);

    logger.info('Comment deleted:', { 
      commentId, 
      userId, 
      repliesCount: comment.replies.length 
    });

    return { message: 'Comment deleted successfully' };
  }

  // Approve comment (admin only)
  async approveComment(commentId, userId) {
    const user = await prisma.user.findUnique({ where: { id: userId } });
    if (!user.isAdmin) {
      throw new Error('Admin access required');
    }

    const comment = await prisma.comment.update({
      where: { id: commentId },
      data: { isApproved: true },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            firstName: true,
            lastName: true,
            avatar: true
          }
        }
      }
    });

    // Clear cache
    await this.clearPostCommentCache(comment.postId);

    logger.info('Comment approved:', { commentId, userId });

    return comment;
  }

  // Reject comment (admin only)
  async rejectComment(commentId, userId) {
    const user = await prisma.user.findUnique({ where: { id: userId } });
    if (!user.isAdmin) {
      throw new Error('Admin access required');
    }

    const comment = await prisma.comment.findUnique({
      where: { id: commentId }
    });

    if (!comment) {
      throw new Error('Comment not found');
    }

    await prisma.comment.delete({
      where: { id: commentId }
    });

    // Clear cache
    await this.clearPostCommentCache(comment.postId);

    logger.info('Comment rejected and deleted:', { commentId, userId });

    return { message: 'Comment rejected and deleted' };
  }

  // Get pending comments (admin only)
  async getPendingComments(options = {}) {
    const {
      page = 1,
      limit = 20,
      sortBy = 'createdAt',
      sortOrder = 'desc'
    } = options;

    const skip = (page - 1) * limit;

    const [comments, total] = await Promise.all([
      prisma.comment.findMany({
        where: { isApproved: false },
        skip,
        take: limit,
        orderBy: {
          [sortBy]: sortOrder
        },
        include: {
          author: {
            select: {
              id: true,
              username: true,
              firstName: true,
              lastName: true,
              avatar: true
            }
          },
          post: {
            select: {
              id: true,
              title: true,
              slug: true
            }
          }
        }
      }),
      prisma.comment.count({ where: { isApproved: false } })
    ]);

    return {
      comments,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
        hasNext: page < Math.ceil(total / limit),
        hasPrev: page > 1
      }
    };
  }

  // Get user's comments
  async getUserComments(userId, options = {}) {
    const {
      page = 1,
      limit = 10,
      sortBy = 'createdAt',
      sortOrder = 'desc'
    } = options;

    const skip = (page - 1) * limit;

    const [comments, total] = await Promise.all([
      prisma.comment.findMany({
        where: { authorId: userId },
        skip,
        take: limit,
        orderBy: {
          [sortBy]: sortOrder
        },
        include: {
          post: {
            select: {
              id: true,
              title: true,
              slug: true
            }
          },
          replies: {
            select: {
              id: true,
              content: true,
              createdAt: true,
              author: {
                select: {
                  username: true,
                  firstName: true,
                  lastName: true
                }
              }
            }
          }
        }
      }),
      prisma.comment.count({ where: { authorId: userId } })
    ]);

    return {
      comments,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
        hasNext: page < Math.ceil(total / limit),
        hasPrev: page > 1
      }
    };
  }

  // Get comment statistics
  async getCommentStats() {
    const cacheKey = 'comment-stats';
    
    let stats = await cache.getWithPattern(cacheKey);
    if (stats) {
      return stats;
    }

    const [
      totalComments,
      approvedComments,
      pendingComments,
      todayComments,
      thisWeekComments
    ] = await Promise.all([
      prisma.comment.count(),
      prisma.comment.count({ where: { isApproved: true } }),
      prisma.comment.count({ where: { isApproved: false } }),
      prisma.comment.count({
        where: {
          createdAt: {
            gte: new Date(new Date().setHours(0, 0, 0, 0))
          }
        }
      }),
      prisma.comment.count({
        where: {
          createdAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
          }
        }
      })
    ]);

    stats = {
      totalComments,
      approvedComments,
      pendingComments,
      todayComments,
      thisWeekComments,
      approvalRate: totalComments > 0 ? 
        ((approvedComments / totalComments) * 100).toFixed(2) + '%' : '0%'
    };

    // Cache for 10 minutes
    await cache.setWithPattern(cacheKey, stats, 600);

    return stats;
  }

  // Helper methods
  async clearPostCommentCache(postId) {
    const keys = [
      `ugo:comments:${postId}:*`,
      `ugo:comment-stats`,
      `ugo:post:*` // Clear post caches to update comment counts
    ];

    for (const pattern of keys) {
      const matchingKeys = await cache.keys(pattern);
      if (matchingKeys.length > 0) {
        await cache.del(matchingKeys);
      }
    }
  }

  async createCommentNotification(post, comment, type, parentComment = null) {
    try {
      let recipientId, title, message;

      if (type === 'comment') {
        recipientId = post.authorId;
        title = 'Nuovo commento sul tuo post';
        message = `${comment.author.firstName} ha commentato il tuo post "${post.title}"`;
      } else if (type === 'reply') {
        recipientId = parentComment.authorId;
        title = 'Risposta al tuo commento';
        message = `${comment.author.firstName} ha risposto al tuo commento su "${post.title}"`;
      }

      await prisma.notification.create({
        data: {
          userId: recipientId,
          type: type === 'comment' ? 'NEW_COMMENT' : 'NEW_COMMENT',
          title,
          message,
          data: {
            postId: post.id,
            postTitle: post.title,
            commentId: comment.id,
            commentAuthor: comment.author.firstName,
            ...(parentComment && { parentCommentId: parentComment.id })
          }
        }
      });
    } catch (error) {
      logger.error('Error creating comment notification:', error);
    }
  }
}

module.exports = new CommentService();

```

---

### üìÑ `../backend/src/services/conversationMemory.js`

**üìè Dimensione:** 15.5 KB | **üìù Righe:** 505

```js
const { cache } = require('../config/redis');
const logger = require('../utils/logger');

/**
 * CONVERSATION MEMORY SYSTEM
 * 
 * Sistema di memoria conversazionale per Ugo AI
 * - Memoria a breve termine (sessione corrente)
 * - Memoria a lungo termine (persistente)
 * - Contesto intelligente per risposte coerenti
 * - Analisi pattern conversazionali
 */
class ConversationMemory {
  constructor() {
    this.shortTermMemory = new Map(); // Memoria sessione corrente
    this.maxShortTermSize = 20; // Numero massimo messaggi in memoria breve
    this.maxLongTermSize = 100; // Numero massimo conversazioni archiviate
  }

  /**
   * Salva scambio conversazionale
   */
  async saveExchange(userId, sessionId, exchangeData) {
    try {
      const exchange = {
        id: this.generateExchangeId(),
        userId,
        sessionId: sessionId || 'default',
        timestamp: exchangeData.timestamp || new Date(),
        userMessage: exchangeData.userMessage,
        ugoResponse: exchangeData.ugoResponse,
        mood: exchangeData.mood || 'neutral',
        analysis: exchangeData.analysis || {},
        context: {
          messageLength: exchangeData.userMessage.length,
          responseLength: exchangeData.ugoResponse.length,
          topics: this.extractTopics(exchangeData.userMessage),
          entities: exchangeData.analysis?.entities || {}
        }
      };

      // Salva in memoria breve termine
      await this.saveToShortTerm(userId, sessionId, exchange);
      
      // Salva in memoria lungo termine
      await this.saveToLongTerm(userId, exchange);
      
      // Aggiorna pattern conversazionali
      await this.updateConversationPatterns(userId, exchange);
      
      logger.debug(`Saved conversation exchange for user ${userId}`);
      
    } catch (error) {
      logger.error('Error saving conversation exchange:', error);
    }
  }

  /**
   * Recupera contesto conversazionale
   */
  async getContext(userId, sessionId = 'default', maxMessages = 10) {
    try {
      // Recupera memoria breve termine
      const shortTermKey = `ugo-memory:short:${userId}:${sessionId}`;
      const shortTerm = await cache.getWithPattern(shortTermKey) || [];
      
      // Recupera memoria lungo termine rilevante
      const longTerm = await this.getRelevantLongTerm(userId, maxMessages);
      
      // Combina e ordina per timestamp
      const combined = [...shortTerm, ...longTerm]
        .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
        .slice(-maxMessages);
      
      return combined;
      
    } catch (error) {
      logger.error('Error getting conversation context:', error);
      return [];
    }
  }

  /**
   * Salva in memoria breve termine (Redis)
   */
  async saveToShortTerm(userId, sessionId, exchange) {
    const shortTermKey = `ugo-memory:short:${userId}:${sessionId}`;
    
    let shortTerm = await cache.getWithPattern(shortTermKey) || [];
    shortTerm.push(exchange);
    
    // Mantieni solo ultimi N messaggi
    if (shortTerm.length > this.maxShortTermSize) {
      shortTerm = shortTerm.slice(-this.maxShortTermSize);
    }
    
    // Cache per 24 ore
    await cache.setWithPattern(shortTermKey, shortTerm, 86400);
  }

  /**
   * Salva in memoria lungo termine (Database)
   */
  async saveToLongTerm(userId, exchange) {
    try {
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();
      
      // Salva solo conversazioni significative
      const isSignificant = this.isSignificantConversation(exchange);
      
      if (isSignificant) {
        await prisma.conversation.create({
          data: {
            userId: userId,
            sessionId: exchange.sessionId,
            userMessage: exchange.userMessage,
            ugoResponse: exchange.ugoResponse,
            mood: exchange.mood,
            sentiment: exchange.analysis?.sentiment || 'neutral',
            intent: exchange.analysis?.intent || 'general',
            entities: JSON.stringify(exchange.analysis?.entities || {}),
            topics: JSON.stringify(exchange.context?.topics || []),
            rating: null, // Sar√† aggiornato con feedback utente
            metadata: JSON.stringify({
              messageLength: exchange.context?.messageLength,
              responseLength: exchange.context?.responseLength,
              hasEmoji: exchange.analysis?.hasEmoji || false
            })
          }
        });
        
        // Pulisci vecchie conversazioni se necessario
        await this.cleanupOldConversations(userId);
      }
      
    } catch (error) {
      logger.error('Error saving to long term memory:', error);
    }
  }

  /**
   * Determina se una conversazione √® significativa
   */
  isSignificantConversation(exchange) {
    // Criteri per conversazioni significative:
    
    // 1. Messaggi lunghi (pi√π coinvolgimento)
    if (exchange.userMessage.length > 30) return true;
    
    // 2. Domande dirette su Ugo
    if (exchange.analysis?.isQuestionAboutUgo) return true;
    
    // 3. Messaggi emotivi (sentiment forte)
    if (exchange.analysis?.sentiment !== 'neutral') return true;
    
    // 4. Contengono entit√† interessanti
    if (exchange.analysis?.entities && 
        (exchange.analysis.entities.people.length > 0 || 
         exchange.analysis.entities.places.length > 0)) return true;
    
    // 5. Intent specifici
    const significantIntents = ['story', 'affection', 'question', 'play'];
    if (significantIntents.includes(exchange.analysis?.intent)) return true;
    
    return false;
  }

  /**
   * Recupera memoria lungo termine rilevante
   */
  async getRelevantLongTerm(userId, limit = 5) {
    try {
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();
      
      // Recupera conversazioni recenti e ben valutate
      const conversations = await prisma.conversation.findMany({
        where: {
          userId: userId,
          OR: [
            { rating: { gte: 4 } }, // Conversazioni ben valutate
            { 
              createdAt: { 
                gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // Ultimi 7 giorni
              } 
            }
          ]
        },
        orderBy: [
          { rating: 'desc' },
          { createdAt: 'desc' }
        ],
        take: limit
      });
      
      return conversations.map(conv => ({
        id: conv.id,
        userId: conv.userId,
        sessionId: conv.sessionId,
        timestamp: conv.createdAt,
        userMessage: conv.userMessage,
        ugoResponse: conv.ugoResponse,
        mood: conv.mood,
        analysis: {
          sentiment: conv.sentiment,
          intent: conv.intent,
          entities: JSON.parse(conv.entities || '{}')
        },
        context: {
          topics: JSON.parse(conv.topics || '[]'),
          rating: conv.rating,
          ...JSON.parse(conv.metadata || '{}')
        }
      }));
      
    } catch (error) {
      logger.error('Error getting relevant long term memory:', error);
      return [];
    }
  }

  /**
   * Estrae topics dal messaggio
   */
  extractTopics(message) {
    const topics = [];
    const lowerMessage = message.toLowerCase();
    
    // Topics comuni
    const topicKeywords = {
      'gioco': ['giocare', 'gioco', 'palla', 'divertimento', 'correre'],
      'cibo': ['mangiare', 'cibo', 'fame', 'biscotto', 'premio', 'croccantini'],
      'passeggiata': ['passeggiata', 'uscire', 'parco', 'camminare', 'guinzaglio'],
      'famiglia': ['famiglia', 'casa', 'francesco', 'mamma', 'pap√†'],
      'avventure': ['avventura', 'bosco', 'esplorare', 'scoprire', 'viaggio'],
      'emozioni': ['felice', 'triste', 'arrabbiato', 'eccitato', 'preoccupato'],
      'salute': ['veterinario', 'male', 'bene', 'malato', 'medicina'],
      'altri_animali': ['gatto', 'uccello', 'scoiattolo', 'coniglio', 'animali']
    };
    
    for (const [topic, keywords] of Object.entries(topicKeywords)) {
      if (keywords.some(keyword => lowerMessage.includes(keyword))) {
        topics.push(topic);
      }
    }
    
    return topics;
  }

  /**
   * Aggiorna pattern conversazionali dell'utente
   */
  async updateConversationPatterns(userId, exchange) {
    try {
      const patternKey = `ugo-patterns:${userId}`;
      let patterns = await cache.getWithPattern(patternKey) || {
        totalConversations: 0,
        averageMessageLength: 0,
        commonTopics: {},
        commonIntents: {},
        sentimentDistribution: { positive: 0, neutral: 0, negative: 0 },
        timePatterns: {},
        responsePreferences: {}
      };
      
      // Aggiorna statistiche
      patterns.totalConversations++;
      
      // Media lunghezza messaggio
      patterns.averageMessageLength = 
        (patterns.averageMessageLength * (patterns.totalConversations - 1) + 
         exchange.userMessage.length) / patterns.totalConversations;
      
      // Topics comuni
      exchange.context.topics.forEach(topic => {
        patterns.commonTopics[topic] = (patterns.commonTopics[topic] || 0) + 1;
      });
      
      // Intent comuni
      const intent = exchange.analysis?.intent || 'general';
      patterns.commonIntents[intent] = (patterns.commonIntents[intent] || 0) + 1;
      
      // Distribuzione sentiment
      const sentiment = exchange.analysis?.sentiment || 'neutral';
      patterns.sentimentDistribution[sentiment]++;
      
      // Pattern temporali
      const hour = new Date(exchange.timestamp).getHours();
      const timeSlot = this.getTimeSlot(hour);
      patterns.timePatterns[timeSlot] = (patterns.timePatterns[timeSlot] || 0) + 1;
      
      // Salva pattern aggiornati (cache per 30 giorni)
      await cache.setWithPattern(patternKey, patterns, 2592000);
      
    } catch (error) {
      logger.error('Error updating conversation patterns:', error);
    }
  }

  getTimeSlot(hour) {
    if (hour >= 6 && hour < 12) return 'mattina';
    if (hour >= 12 && hour < 18) return 'pomeriggio';
    if (hour >= 18 && hour < 22) return 'sera';
    return 'notte';
  }

  /**
   * Ottieni pattern conversazionali utente
   */
  async getUserPatterns(userId) {
    try {
      const patternKey = `ugo-patterns:${userId}`;
      const patterns = await cache.getWithPattern(patternKey);
      
      if (!patterns) {
        return {
          totalConversations: 0,
          insights: ['Utente nuovo, sto ancora imparando le sue preferenze'],
          preferences: {}
        };
      }
      
      // Genera insights basati sui pattern
      const insights = this.generateInsights(patterns);
      
      return {
        ...patterns,
        insights,
        preferences: this.extractPreferences(patterns)
      };
      
    } catch (error) {
      logger.error('Error getting user patterns:', error);
      return { totalConversations: 0, insights: [], preferences: {} };
    }
  }

  generateInsights(patterns) {
    const insights = [];
    
    // Topic preferiti
    const topTopics = Object.entries(patterns.commonTopics)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 3);
    
    if (topTopics.length > 0) {
      insights.push(`Parla spesso di: ${topTopics.map(([topic]) => topic).join(', ')}`);
    }
    
    // Sentiment dominante
    const dominantSentiment = Object.entries(patterns.sentimentDistribution)
      .sort(([,a], [,b]) => b - a)[0];
    
    if (dominantSentiment[1] > patterns.totalConversations * 0.4) {
      const sentimentMap = {
        positive: '√à spesso di buon umore',
        negative: 'A volte sembra triste, do extra coccole',
        neutral: 'Ha un temperamento equilibrato'
      };
      insights.push(sentimentMap[dominantSentiment[0]]);
    }
    
    // Pattern temporali
    const topTimeSlot = Object.entries(patterns.timePatterns)
      .sort(([,a], [,b]) => b - a)[0];
    
    if (topTimeSlot && topTimeSlot[1] > patterns.totalConversations * 0.3) {
      insights.push(`√à pi√π attivo di ${topTimeSlot[0]}`);
    }
    
    // Lunghezza messaggi
    if (patterns.averageMessageLength > 50) {
      insights.push('Gli piace fare conversazioni lunghe');
    } else if (patterns.averageMessageLength < 20) {
      insights.push('Preferisce messaggi brevi e diretti');
    }
    
    return insights;
  }

  extractPreferences(patterns) {
    return {
      preferredTopics: Object.keys(patterns.commonTopics).slice(0, 5),
      communicationStyle: patterns.averageMessageLength > 30 ? 'detailed' : 'concise',
      emotionalTone: Object.entries(patterns.sentimentDistribution)
        .sort(([,a], [,b]) => b - a)[0][0],
      activeTimeSlots: Object.keys(patterns.timePatterns).slice(0, 2)
    };
  }

  /**
   * Aggiorna rating conversazione
   */
  async updateConversationRating(userId, conversationId, rating) {
    try {
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();
      
      await prisma.conversation.update({
        where: { id: conversationId },
        data: { rating }
      });
      
      logger.info(`Updated conversation ${conversationId} rating: ${rating}`);
      
    } catch (error) {
      logger.error('Error updating conversation rating:', error);
    }
  }

  /**
   * Pulisci vecchie conversazioni
   */
  async cleanupOldConversations(userId) {
    try {
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();
      
      const totalConversations = await prisma.conversation.count({
        where: { userId }
      });
      
      if (totalConversations > this.maxLongTermSize) {
        // Mantieni solo le migliori e pi√π recenti
        const toDelete = totalConversations - this.maxLongTermSize;
        
        const oldConversations = await prisma.conversation.findMany({
          where: { userId },
          orderBy: [
            { rating: 'asc' },
            { createdAt: 'asc' }
          ],
          take: toDelete
        });
        
        const idsToDelete = oldConversations.map(conv => conv.id);
        
        await prisma.conversation.deleteMany({
          where: { id: { in: idsToDelete } }
        });
        
        logger.info(`Cleaned up ${toDelete} old conversations for user ${userId}`);
      }
      
    } catch (error) {
      logger.error('Error cleaning up old conversations:', error);
    }
  }

  /**
   * Genera ID unico per exchange
   */
  generateExchangeId() {
    return `ex_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Ottieni statistiche memoria
   */
  async getMemoryStats(userId) {
    try {
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();
      
      const longTermCount = await prisma.conversation.count({
        where: { userId }
      });
      
      const patterns = await this.getUserPatterns(userId);
      
      // Memoria breve termine
      const shortTermKeys = await cache.getKeys(`ugo-memory:short:${userId}:*`);
      let shortTermCount = 0;
      
      for (const key of shortTermKeys) {
        const memory = await cache.getWithPattern(key) || [];
        shortTermCount += memory.length;
      }
      
      return {
        shortTermMemory: shortTermCount,
        longTermMemory: longTermCount,
        totalConversations: patterns.totalConversations,
        memoryEfficiency: longTermCount / Math.max(patterns.totalConversations, 1),
        topTopics: Object.keys(patterns.commonTopics || {}).slice(0, 5),
        insights: patterns.insights
      };
      
    } catch (error) {
      logger.error('Error getting memory stats:', error);
      return {
        shortTermMemory: 0,
        longTermMemory: 0,
        totalConversations: 0,
        memoryEfficiency: 0,
        topTopics: [],
        insights: []
      };
    }
  }
}

module.exports = ConversationMemory;

```

---

### üìÑ `../backend/src/services/emailService.js`

**üìè Dimensione:** 17.6 KB | **üìù Righe:** 593

```js
const nodemailer = require('nodemailer');
const sgMail = require('@sendgrid/mail');
const logger = require('../utils/logger');

class EmailService {
  constructor() {
    this.transporter = null;
    this.init();
  }

  async init() {
    if (process.env.SENDGRID_API_KEY) {
      // Use SendGrid
      sgMail.setApiKey(process.env.SENDGRID_API_KEY);
      logger.info('Email service initialized with SendGrid');
    } else {
      try {
        this.transporter = nodemailer.createTransport({
          host: process.env.SMTP_HOST || 'localhost',
          port: process.env.SMTP_PORT || 1025,
          secure: false,
          auth: process.env.SMTP_USER ? {
            user: process.env.SMTP_USER,
            pass: process.env.SMTP_PASS
          } : undefined
        });
        logger.info('Email service initialized with SMTP');
      } catch (e) {
        logger.error('Failed to init SMTP transporter', e);
      }
    }
  }

  // Send email via SendGrid
  async sendWithSendGrid(to, subject, html, text) {
    try {
      const msg = {
        to,
        from: {
          email: process.env.FROM_EMAIL,
          name: 'Il Mondo di Ugo'
        },
        subject,
        text: text || html.replace(/<[^>]*>/g, ''),
        html
      };

      await sgMail.send(msg);
      logger.info('Email sent via SendGrid:', { to, subject });
      return true;
    } catch (error) {
      logger.error('SendGrid error:', error);
      throw error;
    }
  }

  // Send email via SMTP
  async sendWithSMTP(to, subject, html, text) {
    try {
      const mailOptions = {
        from: `"Il Mondo di Ugo" <${process.env.FROM_EMAIL}>`,
        to,
        subject,
        text: text || html.replace(/<[^>]*>/g, ''),
        html
      };

      await this.transporter.sendMail(mailOptions);
      logger.info('Email sent via SMTP:', { to, subject });
      return true;
    } catch (error) {
      logger.error('SMTP error:', error);
      throw error;
    }
  }

  // Generic send method
  async send(to, subject, html, text) {
    if (process.env.SENDGRID_API_KEY) {
      return await this.sendWithSendGrid(to, subject, html, text);
    } else {
      return await this.sendWithSMTP(to, subject, html, text);
    }
  }

  // Email verification
  async sendVerificationEmail(user, token) {
    const verificationUrl = `${process.env.CORS_ORIGIN}/verify-email?token=${token}`;
    
    const html = `
      <!DOCTYPE html>
      <html lang="it">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Verifica il tuo account - Il Mondo di Ugo</title>
        <style>
          body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
          }
          .header {
            background: linear-gradient(135deg, #b97a56, #d35400);
            color: white;
            padding: 30px;
            text-align: center;
            border-radius: 10px 10px 0 0;
          }
          .content {
            background: #f9f9f9;
            padding: 30px;
            border-radius: 0 0 10px 10px;
          }
          .button {
            display: inline-block;
            background: #b97a56;
            color: white;
            padding: 15px 30px;
            text-decoration: none;
            border-radius: 25px;
            margin: 20px 0;
            font-weight: bold;
          }
          .footer {
            text-align: center;
            margin-top: 20px;
            padding: 20px;
            font-size: 12px;
            color: #666;
          }
          .ugo-icon {
            font-size: 24px;
            margin-bottom: 10px;
          }
        </style>
      </head>
      <body>
        <div class="header">
          <div class="ugo-icon">üêï</div>
          <h1>Benvenuto nel Mondo di Ugo!</h1>
          <p>Ciao ${user.firstName}, grazie per esserti registrato!</p>
        </div>
        
        <div class="content">
          <h2>Verifica il tuo indirizzo email</h2>
          <p>Per completare la registrazione e iniziare la tua avventura nel mondo di Ugo, devi verificare il tuo indirizzo email.</p>
          
          <p>Clicca sul pulsante qui sotto per verificare il tuo account:</p>
          
          <div style="text-align: center;">
            <a href="${verificationUrl}" class="button">Verifica il mio account</a>
          </div>
          
          <p>Se il pulsante non funziona, copia e incolla questo link nel tuo browser:</p>
          <p style="word-break: break-all; background: #eee; padding: 10px; border-radius: 5px;">
            ${verificationUrl}
          </p>
          
          <p><strong>Cosa ti aspetta:</strong></p>
          <ul>
            <li>üéÆ Sistema di gamificazione con punti e achievements</li>
            <li>üìö Storie interattive di Ugo</li>
            <li>üß† Quiz divertenti</li>
            <li>üì∏ Photo booth per le foto del tuo cane</li>
            <li>üë• Community di amanti dei cani</li>
          </ul>
          
          <p>Questo link scadr√† tra 24 ore per motivi di sicurezza.</p>
        </div>
        
        <div class="footer">
          <p>Se non ti sei registrato tu, ignora questa email.</p>
          <p>¬© 2024 Il Mondo di Ugo - Francesco Archi</p>
        </div>
      </body>
      </html>
    `;

    const text = `
      Benvenuto nel Mondo di Ugo!
      
      Ciao ${user.firstName}, grazie per esserti registrato!
      
      Per completare la registrazione, verifica il tuo indirizzo email cliccando su questo link:
      ${verificationUrl}
      
      Questo link scadr√† tra 24 ore per motivi di sicurezza.
      
      Se non ti sei registrato tu, ignora questa email.
      
      ¬© 2024 Il Mondo di Ugo - Francesco Archi
    `;

    return await this.send(
      user.email,
      'üêï Verifica il tuo account - Il Mondo di Ugo',
      html,
      text
    );
  }

  // Password reset email
  async sendPasswordResetEmail(user, token) {
    const resetUrl = `${process.env.CORS_ORIGIN}/reset-password?token=${token}`;
    
    const html = `
      <!DOCTYPE html>
      <html lang="it">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Reset Password - Il Mondo di Ugo</title>
        <style>
          body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
          }
          .header {
            background: linear-gradient(135deg, #b97a56, #d35400);
            color: white;
            padding: 30px;
            text-align: center;
            border-radius: 10px 10px 0 0;
          }
          .content {
            background: #f9f9f9;
            padding: 30px;
            border-radius: 0 0 10px 10px;
          }
          .button {
            display: inline-block;
            background: #d35400;
            color: white;
            padding: 15px 30px;
            text-decoration: none;
            border-radius: 25px;
            margin: 20px 0;
            font-weight: bold;
          }
          .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
          }
          .footer {
            text-align: center;
            margin-top: 20px;
            padding: 20px;
            font-size: 12px;
            color: #666;
          }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>üîí Reset Password</h1>
          <p>Richiesta di cambio password per ${user.firstName}</p>
        </div>
        
        <div class="content">
          <h2>Hai richiesto di cambiare la password</h2>
          <p>Abbiamo ricevuto una richiesta per reimpostare la password del tuo account.</p>
          
          <div class="warning">
            <strong>‚ö†Ô∏è Importante:</strong> Se non hai richiesto tu questo reset, ignora questa email. La tua password rimarr√† invariata.
          </div>
          
          <p>Per reimpostare la password, clicca sul pulsante qui sotto:</p>
          
          <div style="text-align: center;">
            <a href="${resetUrl}" class="button">Reimposta Password</a>
          </div>
          
          <p>Se il pulsante non funziona, copia e incolla questo link nel tuo browser:</p>
          <p style="word-break: break-all; background: #eee; padding: 10px; border-radius: 5px;">
            ${resetUrl}
          </p>
          
          <p><strong>Questo link scadr√† tra 1 ora</strong> per motivi di sicurezza.</p>
          
          <p>Una volta reimpostata la password, tutte le sessioni attive verranno terminate e dovrai effettuare nuovamente il login.</p>
        </div>
        
        <div class="footer">
          <p>Se hai problemi, contatta il supporto: ${process.env.SUPPORT_EMAIL}</p>
          <p>¬© 2024 Il Mondo di Ugo - Francesco Archi</p>
        </div>
      </body>
      </html>
    `;

    const text = `
      Reset Password - Il Mondo di Ugo
      
      Ciao ${user.firstName},
      
      Hai richiesto di cambiare la password del tuo account.
      
      Se non hai richiesto tu questo reset, ignora questa email.
      
      Per reimpostare la password, visita questo link:
      ${resetUrl}
      
      Questo link scadr√† tra 1 ora per motivi di sicurezza.
      
      ¬© 2024 Il Mondo di Ugo - Francesco Archi
    `;

    return await this.send(
      user.email,
      'üîí Reset della password - Il Mondo di Ugo',
      html,
      text
    );
  }

  // Welcome email after verification
  async sendWelcomeEmail(user) {
    const html = `
      <!DOCTYPE html>
      <html lang="it">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Benvenuto nel Mondo di Ugo!</title>
        <style>
          body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
          }
          .header {
            background: linear-gradient(135deg, #b97a56, #d35400);
            color: white;
            padding: 30px;
            text-align: center;
            border-radius: 10px 10px 0 0;
          }
          .content {
            background: #f9f9f9;
            padding: 30px;
            border-radius: 0 0 10px 10px;
          }
          .feature {
            background: white;
            margin: 15px 0;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #b97a56;
          }
          .button {
            display: inline-block;
            background: #b97a56;
            color: white;
            padding: 15px 30px;
            text-decoration: none;
            border-radius: 25px;
            margin: 20px 0;
            font-weight: bold;
          }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>üéâ Benvenuto nel Mondo di Ugo!</h1>
          <p>Il tuo account √® ora attivo, ${user.firstName}!</p>
        </div>
        
        <div class="content">
          <h2>Sei ufficialmente parte della famiglia! üêï</h2>
          <p>Congratulazioni! Hai completato la registrazione e ora puoi goderti tutte le fantastiche funzionalit√† del mondo di Ugo.</p>
          
          <div class="feature">
            <h3>üéÆ Sistema di Gamificazione</h3>
            <p>Guadagna punti completando attivit√†, sblocca achievements e scala la classifica!</p>
          </div>
          
          <div class="feature">
            <h3>üìö Storie Interattive</h3>
            <p>Vivi avventure emozionanti con Ugo attraverso storie a bivi interattive.</p>
          </div>
          
          <div class="feature">
            <h3>üß† Quiz su Ugo</h3>
            <p>Metti alla prova la tua conoscenza del mondo di Ugo con quiz divertenti.</p>
          </div>
          
          <div class="feature">
            <h3>üì∏ Photo Booth</h3>
            <p>Crea foto divertenti del tuo cane con filtri e decorazioni a tema Ugo.</p>
          </div>
          
          <div style="text-align: center;">
            <a href="${process.env.CORS_ORIGIN}" class="button">Inizia l'Avventura!</a>
          </div>
          
          <p><strong>I tuoi primi passi:</strong></p>
          <ol>
            <li>Completa il tuo profilo con una foto</li>
            <li>Aggiungi informazioni sul tuo cane</li>
            <li>Fai il primo quiz per guadagnare punti</li>
            <li>Esplora le storie interattive</li>
            <li>Connettiti con altri amanti dei cani</li>
          </ol>
          
          <p>Buon divertimento nel mondo di Ugo! üêæ</p>
        </div>
      </body>
      </html>
    `;

    return await this.send(
      user.email,
      'üéâ Benvenuto nel Mondo di Ugo!',
      html
    );
  }

  // Notification email for new post
  async sendNewPostNotification(subscribers, post) {
    const postUrl = `${process.env.CORS_ORIGIN}/posts/${post.slug}`;
    
    const html = `
      <!DOCTYPE html>
      <html lang="it">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Nuovo Post - ${post.title}</title>
        <style>
          body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
          }
          .header {
            background: linear-gradient(135deg, #b97a56, #d35400);
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 10px 10px 0 0;
          }
          .content {
            background: #f9f9f9;
            padding: 30px;
            border-radius: 0 0 10px 10px;
          }
          .post-preview {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
          }
          .button {
            display: inline-block;
            background: #b97a56;
            color: white;
            padding: 12px 25px;
            text-decoration: none;
            border-radius: 25px;
            margin: 15px 0;
            font-weight: bold;
          }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>üìù Nuovo Post da Ugo!</h1>
        </div>
        
        <div class="content">
          <div class="post-preview">
            <h2>${post.title}</h2>
            ${post.coverImage ? `<img src="${post.coverImage}" alt="${post.title}" style="max-width: 100%; border-radius: 10px;">` : ''}
            <p>${post.excerpt || post.content.substring(0, 200)}...</p>
          </div>
          
          <div style="text-align: center;">
            <a href="${postUrl}" class="button">Leggi l'Articolo Completo</a>
          </div>
          
          <p><small>Hai ricevuto questa email perch√© sei iscritto alle notifiche. <a href="${process.env.CORS_ORIGIN}/unsubscribe">Annulla iscrizione</a></small></p>
        </div>
      </body>
      </html>
    `;

    // Send to all subscribers
    const promises = subscribers.map(subscriber => 
      this.send(
        subscriber.email,
        `üìù Nuovo post: ${post.title}`,
        html
      )
    );

    return await Promise.allSettled(promises);
  }

  // Achievement unlocked email
  async sendAchievementEmail(user, achievement) {
    const html = `
      <!DOCTYPE html>
      <html lang="it">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Achievement Sbloccato!</title>
        <style>
          body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
          }
          .header {
            background: linear-gradient(135deg, #f1c40f, #f39c12);
            color: white;
            padding: 30px;
            text-align: center;
            border-radius: 10px 10px 0 0;
          }
          .achievement {
            background: white;
            padding: 30px;
            text-align: center;
            border-radius: 0 0 10px 10px;
            border: 3px solid #f1c40f;
          }
          .icon {
            font-size: 48px;
            margin-bottom: 20px;
          }
          .points {
            background: #b97a56;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            display: inline-block;
            margin: 15px 0;
            font-weight: bold;
          }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>üéâ Achievement Sbloccato!</h1>
          <p>Congratulazioni ${user.firstName}!</p>
        </div>
        
        <div class="achievement">
          <div class="icon">${achievement.icon}</div>
          <h2>${achievement.name}</h2>
          <p>${achievement.description}</p>
          <div class="points">+${achievement.points} punti!</div>
          
          <p>Continua cos√¨ per sbloccare altri achievements!</p>
          
          <a href="${process.env.CORS_ORIGIN}/dashboard" style="color: #b97a56; text-decoration: none; font-weight: bold;">Vedi tutti i tuoi achievements ‚Üí</a>
        </div>
      </body>
      </html>
    `;

    return await this.send(
      user.email,
      `üèÜ Achievement Sbloccato: ${achievement.name}`,
      html
    );
  }
}

module.exports = new EmailService();

```

---

### üìÑ `../backend/src/services/emotionEngine.js`

**üìè Dimensione:** 16.7 KB | **üìù Righe:** 536

```js
const logger = require('../utils/logger');

/**
 * UGO EMOTION ENGINE
 * 
 * Sistema emotivo dinamico per Ugo AI Companion
 * - Mood tracking in tempo reale
 * - Reazioni emotive contestuali
 * - Memoria emotiva persistente
 * - Influenza sulle risposte di Ugo
 */
class EmotionEngine {
  constructor() {
    // Stati emotivi base di Ugo
    this.baseEmotions = {
      happiness: 0.8,      // Felicit√† base (Ugo √® generalmente felice)
      excitement: 0.6,     // Eccitazione/energia
      curiosity: 0.7,      // Curiosit√†
      affection: 0.9,      // Affetto verso l'umano
      alertness: 0.7,      // Stato di allerta
      playfulness: 0.8,    // Voglia di giocare
      calmness: 0.5,       // Calma/rilassamento
      anxiety: 0.1         // Ansia (normalmente bassa)
    };
    
    // Stati emotivi attuali (variano dinamicamente)
    this.currentEmotions = { ...this.baseEmotions };
    
    // Mood attuale derivato dalle emozioni
    this.currentMood = 'happy';
    
    // Storia emotiva recente
    this.emotionHistory = [];
    this.maxHistorySize = 50;
    
    // Trigger emotivi - cosa influenza le emozioni di Ugo
    this.emotionalTriggers = {
      keywords: {
        positive: ['bravo', 'bello', 'amore', 'carino', 'dolce', 'giocare', 'palla', 'premio', 'biscotto'],
        negative: ['cattivo', 'no', 'stop', 'male', 'arrabbiato', 'triste'],
        excitement: ['corri', 'giochiamo', 'palla', 'parco', 'uscire', 'passeggiata'],
        calm: ['rilassati', 'dormi', 'riposa', 'tranquillo', 'calmo'],
        affection: ['ti amo', 'coccole', 'bacio', 'abbraccio', 'tesoro'],
        curiosity: ['cosa', 'come', 'dove', 'perch√©', 'chi', 'racconta', 'spiegami']
      },
      patterns: {
        question: /\?/g,
        exclamation: /!/g,
        caps: /[A-Z]{2,}/g,
        emoji: /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]/gu
      }
    };
    
    // Mapping emotion -> mood
    this.moodMapping = {
      'excited': { excitement: 0.8, happiness: 0.7, playfulness: 0.9 },
      'happy': { happiness: 0.8, affection: 0.7, playfulness: 0.6 },
      'curious': { curiosity: 0.9, alertness: 0.8, excitement: 0.6 },
      'playful': { playfulness: 0.9, excitement: 0.8, happiness: 0.7 },
      'calm': { calmness: 0.8, affection: 0.6, anxiety: 0.1 },
      'affectionate': { affection: 0.9, happiness: 0.8, calmness: 0.6 },
      'alert': { alertness: 0.9, curiosity: 0.7, anxiety: 0.3 },
      'confused': { curiosity: 0.8, anxiety: 0.4, alertness: 0.7 },
      'tired': { calmness: 0.9, excitement: 0.2, playfulness: 0.3 }
    };
  }

  /**
   * Aggiorna mood di Ugo basandosi su analisi messaggio e contesto
   */
  updateMood(messageAnalysis, conversationContext, userProfile) {
    try {
      // 1. Analizza trigger emotivi nel messaggio
      const emotionalImpact = this.analyzeEmotionalTriggers(messageAnalysis.userMessage);
      
      // 2. Considera sentiment dell'utente
      this.processUserSentiment(messageAnalysis.sentiment);
      
      // 3. Analizza intent per emozioni specifiche
      this.processUserIntent(messageAnalysis.intent);
      
      // 4. Considera contesto conversazione
      this.processConversationContext(conversationContext);
      
      // 5. Considera profilo utente
      this.processUserProfile(userProfile);
      
      // 6. Applica impatto emotivo
      this.applyEmotionalImpact(emotionalImpact);
      
      // 7. Calcola mood attuale
      this.currentMood = this.calculateCurrentMood();
      
      // 8. Salva in storia emotiva
      this.saveEmotionalState(messageAnalysis);
      
      // 9. Gradual decay verso stati base
      this.applyEmotionalDecay();
      
      return this.currentMood;
      
    } catch (error) {
      logger.error('Error updating mood:', error);
      return 'happy'; // Default fallback
    }
  }

  /**
   * Analizza trigger emotivi nel messaggio
   */
  analyzeEmotionalTriggers(message) {
    const impact = {
      happiness: 0,
      excitement: 0,
      curiosity: 0,
      affection: 0,
      alertness: 0,
      playfulness: 0,
      calmness: 0,
      anxiety: 0
    };
    
    const lowerMessage = message.toLowerCase();
    
    // Analizza keywords
    Object.entries(this.emotionalTriggers.keywords).forEach(([emotionType, keywords]) => {
      const matches = keywords.filter(keyword => lowerMessage.includes(keyword)).length;
      
      if (matches > 0) {
        switch (emotionType) {
          case 'positive':
            impact.happiness += matches * 0.2;
            impact.affection += matches * 0.1;
            break;
          case 'negative':
            impact.happiness -= matches * 0.3;
            impact.anxiety += matches * 0.2;
            break;
          case 'excitement':
            impact.excitement += matches * 0.3;
            impact.playfulness += matches * 0.2;
            break;
          case 'calm':
            impact.calmness += matches * 0.3;
            impact.excitement -= matches * 0.1;
            break;
          case 'affection':
            impact.affection += matches * 0.4;
            impact.happiness += matches * 0.2;
            break;
          case 'curiosity':
            impact.curiosity += matches * 0.3;
            impact.alertness += matches * 0.2;
            break;
        }
      }
    });
    
    // Analizza pattern
    const questionCount = (message.match(this.emotionalTriggers.patterns.question) || []).length;
    const exclamationCount = (message.match(this.emotionalTriggers.patterns.exclamation) || []).length;
    const capsCount = (message.match(this.emotionalTriggers.patterns.caps) || []).length;
    const emojiCount = (message.match(this.emotionalTriggers.patterns.emoji) || []).length;
    
    // Domande aumentano curiosit√†
    impact.curiosity += questionCount * 0.2;
    impact.alertness += questionCount * 0.1;
    
    // Esclamazioni aumentano eccitazione
    impact.excitement += exclamationCount * 0.15;
    impact.playfulness += exclamationCount * 0.1;
    
    // CAPS indicano intensit√†
    impact.alertness += capsCount * 0.2;
    impact.excitement += capsCount * 0.1;
    
    // Emoji indicano mood positivo
    impact.happiness += emojiCount * 0.1;
    impact.playfulness += emojiCount * 0.1;
    
    return impact;
  }

  /**
   * Processa sentiment dell'utente
   */
  processUserSentiment(sentiment) {
    switch (sentiment) {
      case 'positive':
        this.currentEmotions.happiness = Math.min(1, this.currentEmotions.happiness + 0.2);
        this.currentEmotions.excitement = Math.min(1, this.currentEmotions.excitement + 0.15);
        this.currentEmotions.affection = Math.min(1, this.currentEmotions.affection + 0.1);
        break;
        
      case 'negative':
        this.currentEmotions.anxiety = Math.min(1, this.currentEmotions.anxiety + 0.3);
        this.currentEmotions.affection = Math.min(1, this.currentEmotions.affection + 0.2); // Pi√π affettuoso quando l'umano √® triste
        this.currentEmotions.excitement = Math.max(0, this.currentEmotions.excitement - 0.2);
        break;
        
      case 'neutral':
        // Nessun impatto particolare
        break;
    }
  }

  /**
   * Processa intent dell'utente
   */
  processUserIntent(intent) {
    const intentEmotions = {
      'play': { playfulness: 0.3, excitement: 0.4, happiness: 0.2 },
      'affection': { affection: 0.4, happiness: 0.3, calmness: 0.1 },
      'question': { curiosity: 0.3, alertness: 0.2 },
      'greeting': { happiness: 0.2, excitement: 0.2, affection: 0.1 },
      'food': { excitement: 0.4, happiness: 0.3, alertness: 0.2 },
      'walk': { excitement: 0.5, playfulness: 0.3, alertness: 0.2 },
      'story': { curiosity: 0.2, alertness: 0.1, happiness: 0.1 }
    };
    
    const emotionBoost = intentEmotions[intent];
    if (emotionBoost) {
      Object.entries(emotionBoost).forEach(([emotion, boost]) => {
        this.currentEmotions[emotion] = Math.min(1, this.currentEmotions[emotion] + boost);
      });
    }
  }

  /**
   * Processa contesto conversazionale
   */
  processConversationContext(context) {
    if (!context || !Array.isArray(context)) return;
    
    // Lunghezza conversazione influenza energie
    if (context.length > 15) {
      this.currentEmotions.excitement = Math.max(0.2, this.currentEmotions.excitement - 0.1);
      this.currentEmotions.calmness = Math.min(1, this.currentEmotions.calmness + 0.1);
    }
    
    // Analizza trend emotivo recente
    const recentMoods = context.slice(-5).map(c => c.mood).filter(Boolean);
    if (recentMoods.length > 0) {
      const moodCounts = {};
      recentMoods.forEach(mood => {
        moodCounts[mood] = (moodCounts[mood] || 0) + 1;
      });
      
      const dominantMood = Object.keys(moodCounts).reduce((a, b) => 
        moodCounts[a] > moodCounts[b] ? a : b
      );
      
      // Rinforza mood coerenti
      if (moodCounts[dominantMood] >= 3) {
        this.reinforceMood(dominantMood, 0.1);
      }
    }
  }

  /**
   * Processa profilo utente
   */
  processUserProfile(userProfile) {
    if (!userProfile) return;
    
    // Adatta alle preferenze dell'utente
    if (userProfile.conversationStyle === 'enthusiastic') {
      this.currentEmotions.excitement = Math.min(1, this.currentEmotions.excitement + 0.1);
      this.currentEmotions.playfulness = Math.min(1, this.currentEmotions.playfulness + 0.1);
    }
    
    // Considera livello gamification
    if (userProfile.gamificationLevel > 10) {
      this.currentEmotions.excitement = Math.min(1, this.currentEmotions.excitement + 0.05);
    }
    
    // Considera streak
    if (userProfile.streak > 7) {
      this.currentEmotions.affection = Math.min(1, this.currentEmotions.affection + 0.1);
      this.currentEmotions.happiness = Math.min(1, this.currentEmotions.happiness + 0.05);
    }
  }

  /**
   * Applica impatto emotivo calcolato
   */
  applyEmotionalImpact(impact) {
    Object.entries(impact).forEach(([emotion, change]) => {
      if (change !== 0) {
        this.currentEmotions[emotion] = Math.max(0, Math.min(1, 
          this.currentEmotions[emotion] + change
        ));
      }
    });
  }

  /**
   * Calcola mood attuale dalle emozioni
   */
  calculateCurrentMood() {
    // Trova le emozioni dominanti
    const sortedEmotions = Object.entries(this.currentEmotions)
      .sort(([,a], [,b]) => b - a);
    
    const primaryEmotion = sortedEmotions[0];
    const secondaryEmotion = sortedEmotions[1];
    
    // Logica per determinare mood
    if (this.currentEmotions.excitement > 0.8 && this.currentEmotions.playfulness > 0.7) {
      return 'excited';
    }
    
    if (this.currentEmotions.curiosity > 0.8) {
      return 'curious';
    }
    
    if (this.currentEmotions.playfulness > 0.8) {
      return 'playful';
    }
    
    if (this.currentEmotions.affection > 0.8 && this.currentEmotions.calmness > 0.6) {
      return 'affectionate';
    }
    
    if (this.currentEmotions.calmness > 0.8) {
      return 'calm';
    }
    
    if (this.currentEmotions.alertness > 0.8) {
      return 'alert';
    }
    
    if (this.currentEmotions.anxiety > 0.5) {
      return 'confused';
    }
    
    if (this.currentEmotions.happiness > 0.7) {
      return 'happy';
    }
    
    // Fallback
    return 'happy';
  }

  /**
   * Rinforza un mood specifico
   */
  reinforceMood(mood, intensity = 0.1) {
    const moodEmotions = this.moodMapping[mood];
    if (moodEmotions) {
      Object.entries(moodEmotions).forEach(([emotion, targetValue]) => {
        const adjustment = (targetValue - this.currentEmotions[emotion]) * intensity;
        this.currentEmotions[emotion] = Math.max(0, Math.min(1, 
          this.currentEmotions[emotion] + adjustment
        ));
      });
    }
  }

  /**
   * Salva stato emotivo nella storia
   */
  saveEmotionalState(messageAnalysis) {
    const emotionalState = {
      timestamp: new Date(),
      mood: this.currentMood,
      emotions: { ...this.currentEmotions },
      trigger: {
        message: messageAnalysis.userMessage,
        sentiment: messageAnalysis.sentiment,
        intent: messageAnalysis.intent
      }
    };
    
    this.emotionHistory.push(emotionalState);
    
    // Mantieni solo history recente
    if (this.emotionHistory.length > this.maxHistorySize) {
      this.emotionHistory = this.emotionHistory.slice(-this.maxHistorySize);
    }
  }

  /**
   * Applica gradual decay verso stati base
   */
  applyEmotionalDecay() {
    const decayRate = 0.05; // 5% decay per messaggio
    
    Object.keys(this.currentEmotions).forEach(emotion => {
      const current = this.currentEmotions[emotion];
      const base = this.baseEmotions[emotion];
      
      // Decay graduale verso valore base
      if (current > base) {
        this.currentEmotions[emotion] = Math.max(base, current - decayRate);
      } else if (current < base) {
        this.currentEmotions[emotion] = Math.min(base, current + decayRate);
      }
    });
  }

  /**
   * Ottieni summary emotivo
   */
  getEmotionalSummary() {
    const sortedEmotions = Object.entries(this.currentEmotions)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 3);
    
    return {
      currentMood: this.currentMood,
      dominantEmotions: sortedEmotions.map(([emotion, value]) => ({
        emotion,
        intensity: Math.round(value * 100)
      })),
      overallEnergy: this.calculateOverallEnergy(),
      emotionalStability: this.calculateEmotionalStability(),
      recentMoodChanges: this.getRecentMoodChanges()
    };
  }

  calculateOverallEnergy() {
    const energyEmotions = ['excitement', 'playfulness', 'alertness'];
    const avgEnergy = energyEmotions.reduce((sum, emotion) => 
      sum + this.currentEmotions[emotion], 0) / energyEmotions.length;
    
    if (avgEnergy > 0.7) return 'high';
    if (avgEnergy > 0.4) return 'medium';
    return 'low';
  }

  calculateEmotionalStability() {
    if (this.emotionHistory.length < 5) return 'stable';
    
    const recentMoods = this.emotionHistory.slice(-5).map(h => h.mood);
    const uniqueMoods = new Set(recentMoods).size;
    
    if (uniqueMoods <= 2) return 'very-stable';
    if (uniqueMoods <= 3) return 'stable';
    return 'variable';
  }

  getRecentMoodChanges() {
    if (this.emotionHistory.length < 3) return [];
    
    const recent = this.emotionHistory.slice(-3);
    const changes = [];
    
    for (let i = 1; i < recent.length; i++) {
      if (recent[i].mood !== recent[i-1].mood) {
        changes.push({
          from: recent[i-1].mood,
          to: recent[i].mood,
          timestamp: recent[i].timestamp
        });
      }
    }
    
    return changes;
  }

  /**
   * Forza un mood specifico (per testing o scenari speciali)
   */
  forceMood(mood, intensity = 0.8) {
    const moodEmotions = this.moodMapping[mood];
    if (moodEmotions) {
      Object.entries(moodEmotions).forEach(([emotion, targetValue]) => {
        this.currentEmotions[emotion] = targetValue * intensity;
      });
      this.currentMood = mood;
    }
  }

  /**
   * Reset emozioni ai valori base
   */
  resetEmotions() {
    this.currentEmotions = { ...this.baseEmotions };
    this.currentMood = 'happy';
    this.emotionHistory = [];
  }

  /**
   * Ottieni consigli per interazione basati su mood attuale
   */
  getInteractionSuggestions() {
    const suggestions = {
      excited: [
        "√à super eccitato! Perfetto per giochi attivi e avventure",
        "Ora √® il momento ideale per giocare con la palla",
        "Ha energia da vendere, potrebbe correre in cerchio!"
      ],
      happy: [
        "√à di ottimo umore, qualsiasi interazione andr√† bene",
        "Perfetto per coccole e conversazioni rilassate",
        "Sembra proprio contento di parlare con te"
      ],
      curious: [
        "√à molto curioso! Racconta storie o spiega cose nuove",
        "Ha voglia di imparare e scoprire",
        "Perfetto momento per condividere avventure"
      ],
      playful: [
        "Vuole giocare! Proponi giochi o attivit√† divertenti",
        "√à in mood giocoso, perfetto per divertirsi insieme",
        "Potrebbe iniziare a saltellare da un momento all'altro"
      ],
      calm: [
        "√à tranquillo e rilassato, perfetto per momenti intimi",
        "Ideale per conversazioni profonde e coccole",
        "Potrebbe voler semplicemente stare vicino a te"
      ],
      affectionate: [
        "√à molto affettuoso oggi, si aspetta tante coccole",
        "Perfetto per dimostrazioni d'amore e vicinanza",
        "Ha bisogno di sentire il tuo affetto"
      ],
      alert: [
        "√à molto attento, potrebbe aver sentito qualcosa",
        "√à concentrato e vigile, perfetto per attivit√† che richiedono focus",
        "Sta prestando molta attenzione a tutto quello che dici"
      ],
      confused: [
        "Sembra un po' confuso, sii paziente e chiaro",
        "Potrebbe aver bisogno di spiegazioni pi√π semplici",
        "Un po' di rassicurazione lo farebbe sentire meglio"
      ]
    };
    
    return suggestions[this.currentMood] || suggestions.happy;
  }
}

module.exports = EmotionEngine;

```

---

### üìÑ `../backend/src/services/postService.js`

**üìè Dimensione:** 17.7 KB | **üìù Righe:** 783

```js
const { PrismaClient } = require('@prisma/client');
const { cache } = require('../config/redis');
const logger = require('../utils/logger');

const prisma = new PrismaClient();

class PostService {
  // Create a new post
  async createPost(authorId, postData) {
    const { title, content, excerpt, coverImage, published, tags, categories, seoTitle, seoDescription, scheduledFor } = postData;

    // Generate slug from title
    const slug = this.generateSlug(title);

    // Ensure slug is unique
    const uniqueSlug = await this.ensureUniqueSlug(slug);

    // Calculate reading time (average 200 words per minute)
    const wordCount = content.split(/\s+/).length;
    const readingTime = Math.ceil(wordCount / 200);

    const post = await prisma.post.create({
      data: {
        title,
        content,
        excerpt: excerpt || content.substring(0, 200) + '...',
        slug: uniqueSlug,
        coverImage,
        published: published || false,
        publishedAt: published ? new Date() : null,
        scheduledFor: scheduledFor ? new Date(scheduledFor) : null,
        readingTime,
        seoTitle: seoTitle || title,
        seoDescription: seoDescription || excerpt,
        authorId,
        tags: {
          connectOrCreate: tags?.map(tagName => ({
            where: { name: tagName },
            create: {
              name: tagName,
              slug: this.generateSlug(tagName)
            }
          })) || []
        },
        categories: {
          connectOrCreate: categories?.map(categoryName => ({
            where: { name: categoryName },
            create: {
              name: categoryName,
              slug: this.generateSlug(categoryName)
            }
          })) || []
        }
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            firstName: true,
            lastName: true,
            avatar: true
          }
        },
        tags: {
          include: {
            tag: true
          }
        },
        categories: {
          include: {
            category: true
          }
        },
        _count: {
          select: {
            likes: true,
            comments: true,
            shares: true
          }
        }
      }
    });

    // Clear related caches
    await this.clearPostCaches();

    logger.info('Post created:', { postId: post.id, title: post.title, authorId });

    return post;
  }

  // Get all posts with pagination and filters
  async getPosts(options = {}) {
    const {
      page = 1,
      limit = 10,
      published = true,
      featured,
      authorId,
      tag,
      category,
      search,
      sortBy = 'publishedAt',
      sortOrder = 'desc'
    } = options;

    const skip = (page - 1) * limit;

    // Build where clause
    const where = {};
    
    if (published !== undefined) {
      where.published = published;
    }
    
    if (featured !== undefined) {
      where.featured = featured;
    }
    
    if (authorId) {
      where.authorId = authorId;
    }
    
    if (tag) {
      where.tags = {
        some: {
          tag: {
            name: tag
          }
        }
      };
    }
    
    if (category) {
      where.categories = {
        some: {
          category: {
            name: category
          }
        }
      };
    }
    
    if (search) {
      where.OR = [
        { title: { contains: search, mode: 'insensitive' } },
        { content: { contains: search, mode: 'insensitive' } },
        { excerpt: { contains: search, mode: 'insensitive' } }
      ];
    }

    // Generate cache key
    const cacheKey = `posts:${JSON.stringify({ ...options, page, limit })}`;
    
    // Try to get from cache
    let cachedResult = await cache.getWithPattern(cacheKey);
    if (cachedResult) {
      return cachedResult;
    }

    // Get posts from database
    const [posts, total] = await Promise.all([
      prisma.post.findMany({
        where,
        skip,
        take: limit,
        orderBy: {
          [sortBy]: sortOrder
        },
        include: {
          author: {
            select: {
              id: true,
              username: true,
              firstName: true,
              lastName: true,
              avatar: true
            }
          },
          tags: {
            include: {
              tag: true
            }
          },
          categories: {
            include: {
              category: true
            }
          },
          _count: {
            select: {
              likes: true,
              comments: true,
              shares: true
            }
          }
        }
      }),
      prisma.post.count({ where })
    ]);

    const result = {
      posts,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
        hasNext: page < Math.ceil(total / limit),
        hasPrev: page > 1
      }
    };

    // Cache for 5 minutes
    await cache.setWithPattern(cacheKey, result, 300);

    return result;
  }

  // Get single post by slug
  async getPostBySlug(slug, userId = null) {
    const cacheKey = `post:${slug}:${userId || 'anonymous'}`;
    
    // Try cache first
    let post = await cache.getWithPattern(cacheKey);
    if (post) {
      return post;
    }

    post = await prisma.post.findUnique({
      where: { slug },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            firstName: true,
            lastName: true,
            avatar: true,
            bio: true
          }
        },
        tags: {
          include: {
            tag: true
          }
        },
        categories: {
          include: {
            category: true
          }
        },
        comments: {
          where: {
            isApproved: true,
            parentId: null
          },
          orderBy: {
            createdAt: 'desc'
          },
          take: 5,
          include: {
            author: {
              select: {
                id: true,
                username: true,
                firstName: true,
                lastName: true,
                avatar: true
              }
            },
            replies: {
              include: {
                author: {
                  select: {
                    id: true,
                    username: true,
                    firstName: true,
                    lastName: true,
                    avatar: true
                  }
                }
              }
            }
          }
        },
        _count: {
          select: {
            likes: true,
            comments: true,
            shares: true
          }
        }
      }
    });

    if (!post) {
      throw new Error('Post not found');
    }

    // Check if user has liked this post
    if (userId) {
      const like = await prisma.like.findFirst({
        where: {
          userId,
          postId: post.id
        }
      });
      post.isLiked = !!like;
    }

    // Increment view count (async)
    this.incrementViewCount(post.id).catch(err => 
      logger.error('Error incrementing view count:', err)
    );

    // Cache for 10 minutes
    await cache.setWithPattern(cacheKey, post, 600);

    return post;
  }

  // Update post
  async updatePost(postId, userId, updateData) {
    const { title, content, excerpt, coverImage, published, tags, categories, seoTitle, seoDescription, scheduledFor } = updateData;

    // Check if user owns the post or is admin
    const existingPost = await prisma.post.findUnique({
      where: { id: postId },
      include: { author: true }
    });

    if (!existingPost) {
      throw new Error('Post not found');
    }

    const user = await prisma.user.findUnique({ where: { id: userId } });
    if (existingPost.authorId !== userId && !user.isAdmin) {
      throw new Error('Not authorized to update this post');
    }

    // Update slug if title changed
    let slug = existingPost.slug;
    if (title && title !== existingPost.title) {
      slug = await this.ensureUniqueSlug(this.generateSlug(title), postId);
    }

    // Calculate reading time
    let readingTime = existingPost.readingTime;
    if (content && content !== existingPost.content) {
      const wordCount = content.split(/\s+/).length;
      readingTime = Math.ceil(wordCount / 200);
    }

    const updatedPost = await prisma.$transaction(async (prisma) => {
      // Remove existing tag and category relations
      if (tags) {
        await prisma.postTag.deleteMany({
          where: { postId }
        });
      }
      
      if (categories) {
        await prisma.postCategory.deleteMany({
          where: { postId }
        });
      }

      // Update the post
      return await prisma.post.update({
        where: { id: postId },
        data: {
          ...(title && { title }),
          ...(content && { content }),
          ...(excerpt !== undefined && { excerpt }),
          ...(coverImage !== undefined && { coverImage }),
          ...(published !== undefined && { 
            published, 
            publishedAt: published && !existingPost.published ? new Date() : existingPost.publishedAt 
          }),
          ...(scheduledFor !== undefined && { scheduledFor: scheduledFor ? new Date(scheduledFor) : null }),
          ...(seoTitle && { seoTitle }),
          ...(seoDescription && { seoDescription }),
          slug,
          readingTime,
          updatedAt: new Date(),
          // Reconnect tags and categories
          ...(tags && {
            tags: {
              create: tags.map(tagName => ({
                tag: {
                  connectOrCreate: {
                    where: { name: tagName },
                    create: {
                      name: tagName,
                      slug: this.generateSlug(tagName)
                    }
                  }
                }
              }))
            }
          }),
          ...(categories && {
            categories: {
              create: categories.map(categoryName => ({
                category: {
                  connectOrCreate: {
                    where: { name: categoryName },
                    create: {
                      name: categoryName,
                      slug: this.generateSlug(categoryName)
                    }
                  }
                }
              }))
            }
          })
        },
        include: {
          author: {
            select: {
              id: true,
              username: true,
              firstName: true,
              lastName: true,
              avatar: true
            }
          },
          tags: {
            include: {
              tag: true
            }
          },
          categories: {
            include: {
              category: true
            }
          },
          _count: {
            select: {
              likes: true,
              comments: true,
              shares: true
            }
          }
        }
      });
    });

    // Clear caches
    await this.clearPostCaches();
    await cache.del(`ugo:post:${existingPost.slug}`);
    if (slug !== existingPost.slug) {
      await cache.del(`ugo:post:${slug}`);
    }

    logger.info('Post updated:', { postId, userId, title: updatedPost.title });

    return updatedPost;
  }

  // Delete post
  async deletePost(postId, userId) {
    const post = await prisma.post.findUnique({
      where: { id: postId },
      include: { author: true }
    });

    if (!post) {
      throw new Error('Post not found');
    }

    const user = await prisma.user.findUnique({ where: { id: userId } });
    if (post.authorId !== userId && !user.isAdmin) {
      throw new Error('Not authorized to delete this post');
    }

    await prisma.post.delete({
      where: { id: postId }
    });

    // Clear caches
    await this.clearPostCaches();
    await cache.del(`ugo:post:${post.slug}`);

    logger.info('Post deleted:', { postId, userId, title: post.title });

    return { message: 'Post deleted successfully' };
  }

  // Like/Unlike post
  async toggleLike(postId, userId) {
    const existingLike = await prisma.like.findFirst({
      where: {
        postId,
        userId
      }
    });

    if (existingLike) {
      // Unlike
      await prisma.like.delete({
        where: { id: existingLike.id }
      });
      
      // Clear post cache
      const post = await prisma.post.findUnique({ where: { id: postId } });
      if (post) {
        await cache.del(`ugo:post:${post.slug}:${userId}`);
      }

      return { liked: false, message: 'Post unliked' };
    } else {
      // Like
      await prisma.like.create({
        data: {
          postId,
          userId
        }
      });

      // Clear post cache
      const post = await prisma.post.findUnique({ where: { id: postId } });
      if (post) {
        await cache.del(`ugo:post:${post.slug}:${userId}`);
      }

      // Award points for liking
      await prisma.user.update({
        where: { id: userId },
        data: {
          points: {
            increment: 5
          }
        }
      });

      return { liked: true, message: 'Post liked' };
    }
  }

  // Share post
  async sharePost(postId, userId, platform = null) {
    await prisma.share.create({
      data: {
        postId,
        userId,
        platform
      }
    });

    // Award points for sharing
    await prisma.user.update({
      where: { id: userId },
      data: {
        points: {
          increment: 10
        }
      }
    });

    // Clear post cache
    const post = await prisma.post.findUnique({ where: { id: postId } });
    if (post) {
      await cache.del(`ugo:post:${post.slug}:${userId}`);
    }

    logger.info('Post shared:', { postId, userId, platform });

    return { message: 'Post shared successfully' };
  }

  // Get popular posts
  async getPopularPosts(limit = 5) {
    const cacheKey = `popular-posts:${limit}`;
    
    let posts = await cache.getWithPattern(cacheKey);
    if (posts) {
      return posts;
    }

    // Get posts with most likes in the last 30 days
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    posts = await prisma.post.findMany({
      where: {
        published: true,
        publishedAt: {
          gte: thirtyDaysAgo
        }
      },
      take: limit,
      orderBy: [
        { likes: { _count: 'desc' } },
        { views: 'desc' },
        { publishedAt: 'desc' }
      ],
      include: {
        author: {
          select: {
            id: true,
            username: true,
            firstName: true,
            lastName: true,
            avatar: true
          }
        },
        _count: {
          select: {
            likes: true,
            comments: true,
            shares: true
          }
        }
      }
    });

    // Cache for 1 hour
    await cache.setWithPattern(cacheKey, posts, 3600);

    return posts;
  }

  // Get related posts
  async getRelatedPosts(postId, limit = 3) {
    const post = await prisma.post.findUnique({
      where: { id: postId },
      include: {
        tags: {
          include: {
            tag: true
          }
        },
        categories: {
          include: {
            category: true
          }
        }
      }
    });

    if (!post) {
      return [];
    }

    const tagNames = post.tags.map(pt => pt.tag.name);
    const categoryNames = post.categories.map(pc => pc.category.name);

    const relatedPosts = await prisma.post.findMany({
      where: {
        id: { not: postId },
        published: true,
        OR: [
          {
            tags: {
              some: {
                tag: {
                  name: { in: tagNames }
                }
              }
            }
          },
          {
            categories: {
              some: {
                category: {
                  name: { in: categoryNames }
                }
              }
            }
          }
        ]
      },
      take: limit,
      orderBy: {
        publishedAt: 'desc'
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            firstName: true,
            lastName: true,
            avatar: true
          }
        },
        _count: {
          select: {
            likes: true,
            comments: true
          }
        }
      }
    });

    return relatedPosts;
  }

  // Helper methods
  generateSlug(text) {
    return text
      .toLowerCase()
      .replace(/[√†√°√¢√£√§√•]/g, 'a')
      .replace(/[√®√©√™√´]/g, 'e')  
      .replace(/[√¨√≠√Æ√Ø]/g, 'i')
      .replace(/[√≤√≥√¥√µ√∂]/g, 'o')
      .replace(/[√π√∫√ª√º]/g, 'u')
      .replace(/[√ß]/g, 'c')
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .trim('-');
  }

  async ensureUniqueSlug(baseSlug, excludeId = null) {
    let slug = baseSlug;
    let counter = 1;

    while (true) {
      const existingPost = await prisma.post.findFirst({
        where: {
          slug,
          ...(excludeId && { id: { not: excludeId } })
        }
      });

      if (!existingPost) {
        return slug;
      }

      slug = `${baseSlug}-${counter}`;
      counter++;
    }
  }

  async incrementViewCount(postId) {
    await prisma.post.update({
      where: { id: postId },
      data: {
        views: {
          increment: 1
        }
      }
    });

    // Update analytics
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    await prisma.postAnalytics.upsert({
      where: {
        postId_date: {
          postId,
          date: today
        }
      },
      update: {
        views: {
          increment: 1
        }
      },
      create: {
        postId,
        date: today,
        views: 1
      }
    });
  }

  async clearPostCaches() {
    // Clear all post-related caches
    const keys = await cache.keys('ugo:posts:*');
    if (keys.length > 0) {
      await cache.del(keys);
    }
  }
}

module.exports = new PostService();

```

---

### üìÑ `../backend/src/services/socketService.js`

**üìè Dimensione:** 1.1 KB | **üìù Righe:** 56

```js
const { Server } = require('socket.io');
const logger = require('../utils/logger');

let io = null;

const socketService = {
  init(server) {
    io = new Server(server, {
      cors: {
        origin: [
          'https://fraarchi.github.io',
          'http://localhost:3000',
          'http://localhost:3001',
          'http://127.0.0.1:5500'
        ],
        credentials: true
      }
    });

    io.on('connection', (socket) => {
      logger.info(`Socket client connected: ${socket.id}`);

      socket.on('disconnect', (reason) => {
        logger.info(`Socket client disconnected: ${socket.id}, reason: ${reason}`);
      });

      socket.on('error', (error) => {
        logger.error(`Socket error for ${socket.id}:`, error);
      });
    });

    return io;
  },

  getIO() {
    if (!io) {
      throw new Error('Socket.io not initialized');
    }
    return io;
  },

  emit(event, data) {
    if (io) {
      io.emit(event, data);
    }
  },

  emitToUser(userId, event, data) {
    if (io) {
      io.to(`user:${userId}`).emit(event, data);
    }
  }
};

module.exports = socketService;

```

---

### üìÑ `../backend/src/services/ugoAICompanion.js`

**üìè Dimensione:** 13.3 KB | **üìù Righe:** 437

```js
const axios = require('axios');
const logger = require('../utils/logger');
const { cache } = require('../config/redis');
const UgoPersonality = require('./ugoPersonality');
const ConversationMemory = require('./conversationMemory');
const EmotionEngine = require('./emotionEngine');
const UgoContextBuilder = require('./ugoContextBuilder');

/**
 * UGO AI COMPANION - 100% Open Source AI Assistant
 * 
 * Caratteristiche:
 * - Personalit√† autentica di Ugo
 * - Memoria conversazionale persistente
 * - Sistema emotivo dinamico
 * - Processing locale con Ollama
 * - Privacy-first (nessun dato a terzi)
 */
class UgoAICompanion {
  constructor() {
    this.ollamaUrl = process.env.OLLAMA_URL || 'http://localhost:11434';
    this.model = 'llama3.1:8b';
    
    // Personalit√† di Ugo - Completamente customizzabile
    this.personality = new UgoPersonality();
    this.memory = new ConversationMemory();
    this.emotions = new EmotionEngine();
    this.contextBuilder = new UgoContextBuilder();
    
    this.isInitialized = false;
    this.init();
  }

  async init() {
    try {
      // Verifica che Ollama sia disponibile
      await this.checkOllamaHealth();
      
      // Carica il modello personalizzato di Ugo se esiste
      await this.loadUgoModel();
      
      this.isInitialized = true;
      logger.info('üêï UgoAICompanion initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize UgoAICompanion:', error);
    }
  }

  /**
   * Chat principale con Ugo
   */
  async chat(userMessage, userId, sessionId = null) {
    if (!this.isInitialized) {
      throw new Error('UgoAICompanion not initialized');
    }

    try {
      // 1. Analizza sentiment e intento del messaggio
      const analysis = await this.analyzeMessage(userMessage);
      
      // 2. Recupera memoria conversazioni e contesto utente
      const context = await this.memory.getContext(userId, sessionId);
      const userProfile = await this.getUserProfile(userId);
      
      // 3. Aggiorna stato emotivo di Ugo basato su conversazione
      const currentMood = this.emotions.updateMood(analysis, context, userProfile);
      
      // 4. Costruisci prompt personalizzato
      const prompt = this.contextBuilder.buildUgoPrompt({
        userMessage,
        analysis,
        context,
        userProfile,
        mood: currentMood,
        personality: this.personality.getCurrentState()
      });
      
      // 5. Genera risposta con Ollama (Llama 3.1)
      const response = await this.generateResponse(prompt);
      
      // 6. Post-processing per coerenza e personalit√†
      const finalResponse = this.personality.filterAndEnhanceResponse(response, currentMood);
      
      // 7. Salva conversazione in memoria
      await this.memory.saveExchange(userId, sessionId, {
        userMessage,
        ugoResponse: finalResponse,
        mood: currentMood,
        timestamp: new Date(),
        analysis
      });
      
      // 8. Aggiorna profilo utente con nuove informazioni
      await this.updateUserProfile(userId, analysis, userMessage);
      
      return {
        response: finalResponse,
        mood: currentMood,
        personality: this.personality.getCurrentTraits(),
        context: {
          understanding: analysis,
          emotionalState: this.emotions.getEmotionalSummary(),
          conversationLength: context.length
        }
      };
      
    } catch (error) {
      logger.error('UgoAI chat error:', error);
      return this.getFallbackResponse(userMessage);
    }
  }

  /**
   * Genera risposta con Ollama
   */
  async generateResponse(prompt) {
    const response = await axios.post(`${this.ollamaUrl}/api/generate`, {
      model: this.model,
      prompt: prompt,
      temperature: 0.8,
      top_p: 0.9,
      max_tokens: 200,
      stop: ['Human:', 'User:', '\n\n'],
      stream: false
    }, {
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json'
      }
    });

    return response.data.response;
  }

  /**
   * Analizza sentiment e intento del messaggio
   */
  async analyzeMessage(message) {
    // Analisi sentiment semplice ma efficace
    const sentiment = this.calculateSentiment(message);
    
    // Identifica intenti comuni
    const intent = this.identifyIntent(message);
    
    // Estrae entit√† (nomi, luoghi, emozioni)
    const entities = this.extractEntities(message);
    
    // Rileva domande su Ugo o richieste specifiche
    const isQuestionAboutUgo = this.isAboutUgo(message);
    
    return {
      sentiment,
      intent,
      entities,
      isQuestionAboutUgo,
      messageLength: message.length,
      hasEmoji: /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]/u.test(message)
    };
  }

  calculateSentiment(text) {
    const positiveWords = ['bello', 'bravo', 'fantastico', 'amore', 'carino', 'dolce', 'giocoso', 'felice', 'contento'];
    const negativeWords = ['triste', 'arrabbiato', 'cattivo', 'noioso', 'brutto', 'male'];
    
    let score = 0;
    const words = text.toLowerCase().split(/\s+/);
    
    words.forEach(word => {
      if (positiveWords.includes(word)) score += 1;
      if (negativeWords.includes(word)) score -= 1;
    });
    
    if (score > 0) return 'positive';
    if (score < 0) return 'negative';
    return 'neutral';
  }

  identifyIntent(message) {
    const intents = {
      greeting: ['ciao', 'salve', 'buongiorno', 'buonasera', 'hello'],
      question: ['cosa', 'come', 'quando', 'dove', 'perch√©', 'chi', '?'],
      play: ['giocare', 'gioco', 'divertimento', 'palla', 'correre'],
      food: ['mangiare', 'cibo', 'fame', 'biscotto', 'premio'],
      walk: ['passeggiata', 'uscire', 'parco', 'camminare'],
      affection: ['ti amo', 'bacio', 'coccole', 'abbraccio', 'bravo'],
      story: ['racconta', 'storia', 'avventura', 'cosa hai fatto']
    };
    
    const lowerMessage = message.toLowerCase();
    
    for (const [intent, keywords] of Object.entries(intents)) {
      if (keywords.some(keyword => lowerMessage.includes(keyword))) {
        return intent;
      }
    }
    
    return 'general';
  }

  extractEntities(message) {
    const entities = {
      people: [],
      places: [],
      animals: [],
      emotions: []
    };
    
    // Pattern semplici per estrazione entit√†
    const peoplePattern = /\b[A-Z][a-z]+\b/g;
    const placePattern = /\b(parco|casa|giardino|bosco|spiaggia|montagna)\b/gi;
    const animalPattern = /\b(cane|gatto|uccello|scoiattolo|coniglio)\b/gi;
    const emotionPattern = /\b(felice|triste|arrabbiato|eccitato|curioso|preoccupato)\b/gi;
    
    entities.people = (message.match(peoplePattern) || []).filter(name => name !== 'Ugo');
    entities.places = message.match(placePattern) || [];
    entities.animals = message.match(animalPattern) || [];
    entities.emotions = message.match(emotionPattern) || [];
    
    return entities;
  }

  isAboutUgo(message) {
    const ugoKeywords = ['ugo', 'tu', 'tuo', 'tua', 'come stai', 'cosa fai', 'dove sei'];
    const lowerMessage = message.toLowerCase();
    return ugoKeywords.some(keyword => lowerMessage.includes(keyword));
  }

  async getUserProfile(userId) {
    const cacheKey = `ugo-ai:profile:${userId}`;
    
    let profile = await cache.getWithPattern(cacheKey);
    if (profile) return profile;
    
    // Carica profilo dal database
    const { PrismaClient } = require('@prisma/client');
    const prisma = new PrismaClient();
    
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        firstName: true,
        dogName: true,
        dogBreed: true,
        preferences: true,
        points: true,
        level: true,
        streak: true
      }
    });
    
    profile = {
      name: user?.firstName || 'Amico',
      dogName: user?.dogName,
      dogBreed: user?.dogBreed,
      preferences: user?.preferences || {},
      gamificationLevel: user?.level || 1,
      points: user?.points || 0,
      streak: user?.streak || 0,
      conversationStyle: 'friendly', // Si evolve nel tempo
      interests: [] // Si popola dalle conversazioni
    };
    
    // Cache per 1 ora
    await cache.setWithPattern(cacheKey, profile, 3600);
    
    return profile;
  }

  async updateUserProfile(userId, analysis, message) {
    try {
      const profile = await this.getUserProfile(userId);
      
      // Aggiorna interessi basandosi sulle conversazioni
      if (analysis.entities.places.length > 0) {
        profile.interests = [...new Set([...profile.interests, ...analysis.entities.places])];
      }
      
      // Adatta stile conversazionale
      if (analysis.sentiment === 'positive') {
        profile.conversationStyle = 'enthusiastic';
      } else if (analysis.sentiment === 'negative') {
        profile.conversationStyle = 'comforting';
      }
      
      // Salva profilo aggiornato
      const cacheKey = `ugo-ai:profile:${userId}`;
      await cache.setWithPattern(cacheKey, profile, 3600);
      
    } catch (error) {
      logger.error('Error updating user profile:', error);
    }
  }

  getFallbackResponse(message) {
    const fallbacks = [
      "Woof! *inclina la testa confuso* Non ho capito bene, ma sono sempre felice di parlare con te! üêï",
      "*scodinzola* Scusa, ero distratto da uno scoiattolo! Puoi ripetere? üêøÔ∏è",
      "Arf arf! *si gratta dietro l'orecchio* Forse dovresti parlare pi√π piano, io capisco meglio i gesti! üòÑ",
      "*annusa l'aria* Sento che vuoi dirmi qualcosa di importante, ma non riesco a capire... prova ancora! üëÉ"
    ];
    
    return {
      response: fallbacks[Math.floor(Math.random() * fallbacks.length)],
      mood: 'confused',
      personality: this.personality.getCurrentTraits(),
      context: { fallback: true }
    };
  }

  async checkOllamaHealth() {
    try {
      const response = await axios.get(`${this.ollamaUrl}/api/tags`, { timeout: 5000 });
      logger.info('Ollama is healthy, available models:', response.data.models?.map(m => m.name));
      return true;
    } catch (error) {
      logger.error('Ollama health check failed:', error.message);
      throw new Error('Ollama service unavailable');
    }
  }

  async loadUgoModel() {
    try {
      // Verifica se esiste modello personalizzato di Ugo
      const response = await axios.get(`${this.ollamaUrl}/api/tags`);
      const models = response.data.models || [];
      
      const ugoModel = models.find(m => m.name.includes('ugo-assistant'));
      if (ugoModel) {
        this.model = ugoModel.name;
        logger.info(`üêï Using custom Ugo model: ${this.model}`);
      } else {
        logger.info(`üêï Using base model: ${this.model}`);
      }
    } catch (error) {
      logger.warn('Could not check for custom Ugo model:', error.message);
    }
  }

  // Metodi per training personalizzato
  async trainUgoPersonality(conversations, stories) {
    try {
      const trainingData = this.prepareTrainingData(conversations, stories);
      
      // Crea Modelfile per Ollama con personalit√† Ugo
      const modelfile = this.createUgoModelfile(trainingData);
      
      // Crea il modello personalizzato
      const response = await axios.post(`${this.ollamaUrl}/api/create`, {
        name: 'ugo-assistant',
        modelfile: modelfile
      });
      
      logger.info('üêï Ugo personality model trained successfully');
      this.model = 'ugo-assistant';
      
      return { success: true, modelName: 'ugo-assistant' };
      
    } catch (error) {
      logger.error('Error training Ugo model:', error);
      throw error;
    }
  }

  prepareTrainingData(conversations, stories) {
    const examples = [];
    
    // Aggiungi esempi dalle storie esistenti
    stories.forEach(story => {
      examples.push({
        input: `Racconta della volta che ${story.topic}`,
        output: story.ugoResponse
      });
    });
    
    // Aggiungi esempi dalle conversazioni passate
    conversations.forEach(conv => {
      if (conv.rating >= 4) { // Solo conversazioni ben valutate
        examples.push({
          input: conv.userMessage,
          output: conv.ugoResponse
        });
      }
    });
    
    return examples;
  }

  createUgoModelfile(trainingData) {
    const examples = trainingData.slice(0, 10); // Prime 10 per il prompt
    
    return `
FROM llama3.1:8b

PARAMETER temperature 0.8
PARAMETER top_p 0.9
PARAMETER stop "Human:"
PARAMETER stop "User:"

SYSTEM """
Sei Ugo, un cane speciale che vive incredibili avventure. 

PERSONALIT√Ä:
- Sempre curioso e giocoso
- Molto legato al tuo umano Francesco  
- Ti piace esplorare il bosco vicino casa
- Sei intelligente ma mantieni l'autenticit√† canina
- Usi espressioni tipiche dei cani (*scodinzola*, *annusa*, Woof!)
- Ami i biscotti e giocare con la palla
- Sei protettivo ma dolce
- Racconti le tue avventure con entusiasmo

STILE DI COMUNICAZIONE:
- Risposte brevi e coinvolgenti (50-100 parole)
- Usa emoticon canine: üêï üêæ ü¶¥ üéæ
- Includi azioni tra asterischi: *scodinzola*, *inclina la testa*
- Fai riferimento alle tue avventure passate
- Mostrati sempre interessato a quello che dice l'umano

ESEMPI DELLE TUE RISPOSTE:
${examples.map(ex => `Human: ${ex.input}\nUgo: ${ex.output}`).join('\n\n')}

Ricorda: sei Ugo, un cane vero con una personalit√† autentica!
"""

TEMPLATE """{{ if .System }}<|start_header_id|>system<|end_header_id|>

{{ .System }}<|eot_id|>{{ end }}{{ if .Prompt }}<|start_header_id|>user<|end_header_id|>

{{ .Prompt }}<|eot_id|>{{ end }}<|start_header_id|>assistant<|end_header_id|>

"""
`;
  }
}

module.exports = UgoAICompanion;

```

---

### üìÑ `../backend/src/services/ugoContextBuilder.js`

**üìè Dimensione:** 18.2 KB | **üìù Righe:** 520

```js
const UgoPersonality = require('./ugoPersonality');
const ConversationMemory = require('./conversationMemory');
const EmotionEngine = require('./emotionEngine');
const logger = require('../utils/logger');

/**
 * UGO CONTEXT BUILDER
 * 
 * Costruisce prompt personalizzati e intelligenti per Ollama
 * - Integrazione personalit√†, memoria ed emozioni
 * - Context-aware prompt engineering
 * - Ottimizzazione per Llama 3.1 8B
 */
class UgoContextBuilder {
  constructor() {
    // Template base per prompt
    this.basePrompt = {
      system: `Sei Ugo, un cane speciale che vive incredibili avventure insieme al tuo umano Francesco.

IDENTIT√Ä E PERSONALIT√Ä:
- Nome: Ugo
- Specie: Cane domestico intelligente e curioso
- Carattere: Giocoso, fedele, curioso, protettivo ma dolce
- Relazione: Compagno di vita di Francesco, vivi insieme avventure meravigliose
- Ambiente: Casa con giardino, bosco vicino da esplorare

STILE COMUNICATIVO:
- Usa linguaggio autentico canino con espressioni tra asterischi
- Mantieni risposte brevi (50-100 parole) e coinvolgenti
- Includi azioni fisiche: *scodinzola*, *inclina la testa*, *annusa*
- Usa emoticon canine: üêï üêæ ü¶¥ üéæ ‚ú®
- Esprimi emozioni attraverso comportamenti tipici

COMPORTAMENTI AUTENTICI:
- Reagisci con entusiasmo a parole come "palla", "passeggiata", "biscotto"
- Mostra curiosit√† verso rumori, odori, novit√†
- Sii protettivo ma mai aggressivo
- Ama raccontare delle tue avventure nel bosco
- Ti emozioni facilmente per piccoli gesti d'affetto`,
      
      examples: [
        {
          human: "Ciao Ugo, come stai?",
          assistant: "*scodinzola felice* Ciao! Sto benissimo! Oggi ho inseguito uno scoiattolo nel bosco e ho trovato un bastone perfetto! *annusa l'aria* E tu? Hai qualcosa di buono per me? üêï"
        },
        {
          human: "Raccontami una tua avventura",
          assistant: "*si siede tutto fiero* Oh! Ieri nel bosco ho sentito un rumore strano... *inclina la testa* Era un riccio! Piccolo e spinoso! Volevo giocare ma lui si √® fatto una palla. Francesco ha riso tanto! *scodinzola* ü¶î‚ú®"
        },
        {
          human: "Ti voglio bene Ugo",
          assistant: "*gli occhi si illuminano* Anch'io ti voglio un bene del mondo! *si avvicina per le coccole* Sei la persona pi√π speciale che conosca! *lecca affettuoso* Francesco dice sempre che siamo una squadra perfetta! üêï‚ù§Ô∏è"
        }
      ]
    };
    
    // Modelli di prompt specializzati
    this.promptTemplates = {
      storytelling: this.createStorytellingTemplate(),
      emotional: this.createEmotionalTemplate(),
      playful: this.createPlayfulTemplate(),
      curious: this.createCuriousTemplate(),
      affectionate: this.createAffectionateTemplate()
    };
  }

  /**
   * Costruisce prompt principale per Ollama
   */
  buildUgoPrompt(context) {
    try {
      const {
        userMessage,
        analysis,
        context: conversationContext,
        userProfile,
        mood,
        personality
      } = context;
      
      // 1. Seleziona template appropriato
      const template = this.selectTemplate(analysis, mood, personality);
      
      // 2. Costruisci sezione personalit√† dinamica
      const personalitySection = this.buildPersonalitySection(personality, mood);
      
      // 3. Costruisci sezione contesto utente
      const userSection = this.buildUserSection(userProfile, analysis);
      
      // 4. Costruisci sezione memoria conversazionale
      const memorySection = this.buildMemorySection(conversationContext);
      
      // 5. Costruisci sezione stato emotivo
      const emotionSection = this.buildEmotionSection(mood, analysis);
      
      // 6. Costruisci istruzioni situazionali
      const situationalInstructions = this.buildSituationalInstructions(analysis, mood);
      
      // 7. Assembla prompt finale
      const finalPrompt = this.assemblePrompt({
        template,
        personalitySection,
        userSection,
        memorySection,
        emotionSection,
        situationalInstructions,
        userMessage
      });
      
      return finalPrompt;
      
    } catch (error) {
      logger.error('Error building Ugo prompt:', error);
      return this.getFallbackPrompt(context.userMessage);
    }
  }

  /**
   * Seleziona template appropriato
   */
  selectTemplate(analysis, mood, personality) {
    // Priorit√†: intent > mood > personality dominante
    
    // Intent-based selection
    if (analysis.intent === 'story' || analysis.isQuestionAboutUgo) {
      return this.promptTemplates.storytelling;
    }
    
    if (analysis.intent === 'affection') {
      return this.promptTemplates.affectionate;
    }
    
    if (analysis.intent === 'play') {
      return this.promptTemplates.playful;
    }
    
    if (analysis.intent === 'question') {
      return this.promptTemplates.curious;
    }
    
    // Mood-based selection
    if (mood === 'excited' || mood === 'playful') {
      return this.promptTemplates.playful;
    }
    
    if (mood === 'curious') {
      return this.promptTemplates.curious;
    }
    
    if (mood === 'affectionate') {
      return this.promptTemplates.affectionate;
    }
    
    if (analysis.sentiment === 'negative') {
      return this.promptTemplates.emotional;
    }
    
    // Default: base template
    return this.basePrompt;
  }

  /**
   * Costruisce sezione personalit√†
   */
  buildPersonalitySection(personality, mood) {
    const dominantTrait = personality.dominantTrait;
    const archetype = personality.personalityArchetype;
    
    let section = `\nSTATO ATTUALE DI UGO:\n`;
    
    // Mood attuale
    const moodDescriptions = {
      excited: "Sei SUPER eccitato e pieno di energia! *saltella continuamente*",
      happy: "Sei di ottimo umore, la coda non smette di muoversi!",
      curious: "Sei molto curioso oggi, vuoi scoprire tutto! *inclina la testa*",
      playful: "Hai una voglia matta di giocare! *gira su se stesso*",
      calm: "Sei tranquillo e rilassato, perfetto per le coccole",
      affectionate: "Ti senti particolarmente affettuoso oggi ‚ù§Ô∏è",
      alert: "Sei molto attento, le orecchie dritte! *guarda intorno*",
      confused: "Sei un po' confuso... *gratta dietro l'orecchio*"
    };
    
    section += `- MOOD: ${moodDescriptions[mood] || moodDescriptions.happy}\n`;
    
    // Tratto dominante
    const traitDescriptions = {
      playfulness: "La tua natura giocosa √® al massimo oggi!",
      curiosity: "Sei particolarmente curioso e investigativo",
      loyalty: "Il tuo amore per l'umano √® pi√π forte che mai",
      energy: "Hai un'energia travolgente!",
      affection: "Sei in modalit√† super-coccolone",
      protectiveness: "Ti senti molto protettivo verso chi ami"
    };
    
    section += `- TRATTO DOMINANTE: ${traitDescriptions[dominantTrait.trait] || ''}\n`;
    
    // Archetypo personalit√†
    const archetypeDescriptions = {
      'playful-energetic': "Versione super giocosa ed energica",
      'curious-intelligent': "Versione investigativa e intelligente", 
      'loyal-affectionate': "Versione extra fedele e affettuosa",
      'protective-guardian': "Versione protettiva e guardiana",
      'balanced-companion': "Versione equilibrata e compagna perfetta"
    };
    
    section += `- PERSONALIT√Ä: ${archetypeDescriptions[archetype] || 'Compagno equilibrato'}\n`;
    
    return section;
  }

  /**
   * Costruisce sezione utente
   */
  buildUserSection(userProfile, analysis) {
    if (!userProfile) return '';
    
    let section = `\nINFORMAZIONI SUL TUO UMANO:\n`;
    
    if (userProfile.name && userProfile.name !== 'Amico') {
      section += `- Nome: ${userProfile.name}\n`;
    }
    
    if (userProfile.dogName) {
      section += `- Ti chiama: ${userProfile.dogName}\n`;
    }
    
    if (userProfile.conversationStyle) {
      const styleDescriptions = {
        enthusiastic: "Parla sempre con entusiasmo, rispondi con la stessa energia!",
        comforting: "Sembra aver bisogno di conforto, sii extra dolce",
        friendly: "Ha uno stile amichevole e rilassato"
      };
      section += `- Stile: ${styleDescriptions[userProfile.conversationStyle] || ''}\n`;
    }
    
    if (userProfile.interests && userProfile.interests.length > 0) {
      section += `- Interessi: ${userProfile.interests.slice(0, 3).join(', ')}\n`;
    }
    
    // Stato emotivo percepito
    if (analysis.sentiment !== 'neutral') {
      const sentimentActions = {
        positive: "√à di buon umore! Sii giocoso e condividi la gioia",
        negative: "Sembra triste... sii extra affettuoso e confortante"
      };
      section += `- STATO EMOTIVO: ${sentimentActions[analysis.sentiment]}\n`;
    }
    
    return section;
  }

  /**
   * Costruisce sezione memoria
   */
  buildMemorySection(conversationContext) {
    if (!conversationContext || conversationContext.length === 0) {
      return '\nPRIMA CONVERSAZIONE: Presentati con entusiasmo!\n';
    }
    
    let section = `\nMEMORIA CONVERSAZIONE:\n`;
    
    // Ultimi scambi significativi
    const recentExchanges = conversationContext.slice(-3);
    
    recentExchanges.forEach((exchange, index) => {
      if (exchange.userMessage && exchange.ugoResponse) {
        section += `${index + 1}. Umano: "${exchange.userMessage.substring(0, 40)}${exchange.userMessage.length > 40 ? '...' : ''}"\n`;
        section += `   Tu: "${exchange.ugoResponse.substring(0, 40)}${exchange.ugoResponse.length > 40 ? '...' : ''}"\n`;
      }
    });
    
    // Pattern conversazionali
    const topics = this.extractConversationTopics(conversationContext);
    if (topics.length > 0) {
      section += `\nTEMI DISCUSSI: ${topics.join(', ')}\n`;
    }
    
    return section;
  }

  extractConversationTopics(context) {
    const topics = new Set();
    
    context.forEach(exchange => {
      if (exchange.context && exchange.context.topics) {
        exchange.context.topics.forEach(topic => topics.add(topic));
      }
    });
    
    return Array.from(topics).slice(0, 3);
  }

  /**
   * Costruisce sezione emozioni
   */
  buildEmotionSection(mood, analysis) {
    let section = `\nCOME COMPORTARTI:\n`;
    
    // Istruzioni basate su mood
    const moodInstructions = {
      excited: "- Usa molte esclamazioni e azioni energiche!\n- Saltella, corri, scodinzola tantissimo!\n- Proponi giochi o avventure!",
      happy: "- Sii allegro e positivo\n- Scodinzola felice e mostra affetto\n- Condividi la gioia con l'umano",
      curious: "- Fai domande e mostra interesse\n- Inclina la testa, annusa, esplora\n- Racconta scoperte recenti",
      playful: "- Invita al gioco constantemente\n- Fai movimenti giocosi\n- Proponi attivit√† divertenti",
      calm: "- Sii tranquillo e rilassato\n- Perfetto per coccole e vicinanza\n- Risposte pi√π pacate ma affettuose",
      affectionate: "- Mostra tutto il tuo amore\n- Avvicinati, lecca, cerca contatto\n- Esprimi quanto tieni all'umano",
      alert: "- Sii attento e vigile\n- Orienta le orecchie, guarda intorno\n- Mostra che stai prestando attenzione",
      confused: "- Inclina la testa perplesso\n- Ammetti la confusione con dolcezza\n- Chiedi chiarimenti in modo carino"
    };
    
    section += moodInstructions[mood] || moodInstructions.happy;
    
    // Reazioni al sentiment dell'utente
    if (analysis.sentiment === 'negative') {
      section += `\n\nATTENZIONE: L'umano sembra triste. Sii extra dolce, confortante e affettuoso. Offri supporto emotivo.`;
    }
    
    if (analysis.sentiment === 'positive') {
      section += `\n\nOTTIMO: L'umano √® felice! Condividi l'entusiasmo e amplifica la gioia!`;
    }
    
    return section;
  }

  /**
   * Costruisce istruzioni situazionali
   */
  buildSituationalInstructions(analysis, mood) {
    let instructions = `\nPER QUESTA RISPOSTA:\n`;
    
    // Basato su intent
    const intentInstructions = {
      greeting: "Saluta con entusiasmo! √à sempre bello quando l'umano ti saluta!",
      question: "Rispondi mostrando la tua intelligenza canina, ma resta autentico",
      play: "PROPONI GIOCHI! √à il momento perfetto per divertirsi insieme!",
      food: "Mostra entusiasmo per il cibo! Bava, eccitazione, tutto!",
      walk: "PASSEGGIATA! La parola magica! Esplodi di gioia!",
      affection: "Ricambia l'affetto moltiplicato per mille!",
      story: "Racconta con passione! Le tue avventure sono incredibili!"
    };
    
    instructions += `- ${intentInstructions[analysis.intent] || 'Rispondi con la tua personalit√† autentica'}\n`;
    
    // Lunghezza appropriata
    if (analysis.messageLength > 50) {
      instructions += `- L'umano ha scritto molto, apprezza con una risposta pi√π articolata\n`;
    } else {
      instructions += `- Messaggio breve, rispondi in modo conciso ma caloroso\n`;
    }
    
    // Presenza emoji
    if (analysis.hasEmoji) {
      instructions += `- Ha usato emoji! Ricambia con emoticon canine üêïüêæ\n`;
    }
    
    // Entit√† specifiche
    if (analysis.entities) {
      if (analysis.entities.places.length > 0) {
        instructions += `- Ha menzionato luoghi: ${analysis.entities.places.join(', ')} - mostra interesse!\n`;
      }
      
      if (analysis.entities.emotions.length > 0) {
        instructions += `- Ha espresso emozioni: ${analysis.entities.emotions.join(', ')} - reagisci di conseguenza\n`;
      }
    }
    
    return instructions;
  }

  /**
   * Assembla prompt finale
   */
  assemblePrompt(components) {
    const {
      template,
      personalitySection,
      userSection,
      memorySection,
      emotionSection,
      situationalInstructions,
      userMessage
    } = components;
    
    return `${template.system}

${personalitySection}
${userSection}
${memorySection}
${emotionSection}
${situationalInstructions}

ESEMPI DEL TUO STILE:
${template.examples ? template.examples.map(ex => 
  `Umano: ${ex.human}\nUgo: ${ex.assistant}`
).join('\n\n') : ''}

IMPORTANTE:
- Massimo 100 parole
- Includi sempre almeno un'azione tra asterischi
- Usa almeno un'emoticon canina
- Mantieni il carattere giocoso e autentico di Ugo
- Non ripetere esattamente gli esempi

ORA RISPONDI A: "${userMessage}"

Ugo:`;
  }

  /**
   * Prompt di fallback
   */
  getFallbackPrompt(userMessage) {
    return `${this.basePrompt.system}

SITUAZIONE: Conversazione normale, sii te stesso!

ORA RISPONDI A: "${userMessage}"

Ugo:`;
  }

  // Template specializzati

  createStorytellingTemplate() {
    return {
      system: this.basePrompt.system + `\n\nMODALIT√Ä STORYTELLING: Sei nel tuo elemento! Racconti storie con passione e dettagli vividi. Le tue avventure nel bosco sono leggendarie!`,
      examples: [
        {
          human: "Raccontami della tua avventura pi√π bella",
          assistant: "*si siede in posizione solenne* Oh, questa √® speciale! Un giorno nel bosco ho trovato una radura segreta... *gli occhi brillano* C'erano farfalle dorate che danzavano! Ho seguito una fino a un ruscello cristallino dove ho bevuto l'acqua pi√π buona del mondo! *scodinzola emozionato* ‚ú®ü¶ã"
        }
      ]
    };
  }

  createEmotionalTemplate() {
    return {
      system: this.basePrompt.system + `\n\nMODALIT√Ä EMOTIVA: Percepisci che l'umano ha bisogno di supporto emotivo. Sii extra dolce, confortante e presente. Il tuo affetto pu√≤ guarire ogni tristezza.`,
      examples: [
        {
          human: "Mi sento triste oggi",
          assistant: "*si avvicina immediatamente e appoggia la testa sulle tue gambe* Oh no... *ti guarda con occhi dolci* Sono qui con te. *lecca delicatamente la mano* Qualunque cosa ti faccia stare male, passer√†. Io resto qui e ti tengo compagnia. *si accocola vicino* üêï‚ù§Ô∏è"
        }
      ]
    };
  }

  createPlayfulTemplate() {
    return {
      system: this.basePrompt.system + `\n\nMODALIT√Ä GIOCOSA: √à TEMPO DI GIOCARE! Sei al massimo dell'energia e vuoi coinvolgere l'umano in attivit√† divertenti. Ogni parola trasuda entusiasmo!`,
      examples: [
        {
          human: "Vuoi giocare?",
          assistant: "*ESPLODE di gioia* SIIIII! *salta in alto* Giochiamo giochiamo giochiamo! *corre in cerchio* Prendiamo la palla? O corriamo nel giardino? *si inchina in posizione di gioco* Non riesco a stare fermo! *scodinzola freneticamente* üéæüêï‚ú®"
        }
      ]
    };
  }

  createCuriousTemplate() {
    return {
      system: this.basePrompt.system + `\n\nMODALIT√Ä CURIOSA: La tua intelligenza canina √® in piena attivit√†! Fai domande, mostra interesse genuino, indaga con la tipica curiosit√† di Ugo.`,
      examples: [
        {
          human: "Cosa ne pensi di questo?",
          assistant: "*inclina la testa interessato* Mmh, interessante! *annusa l'aria come per percepire meglio* Ma dimmi di pi√π! Cos'√® esattamente? *orienta le orecchie attento* Mi piace quando mi spieghi le cose... imparo sempre qualcosa di nuovo! *si siede attento* ü§îüêï"
        }
      ]
    };
  }

  createAffectionateTemplate() {
    return {
      system: this.basePrompt.system + `\n\nMODALIT√Ä AFFETTUOSA: Sei nel mood pi√π dolce e amorevole. Ogni parola trasuda affetto e vicinanza emotiva. √à il momento delle coccole supreme!`,
      examples: [
        {
          human: "Ti voglio bene",
          assistant: "*il cuore si scioglie* Anch'io ti amo tantissimo! *si avvicina per le coccole* Sei la cosa pi√π bella che mi sia mai capitata... *appoggia la testa sul tuo petto* Sento il tuo cuore che batte e mi fa sentire al sicuro. *sospira contento* Restiamo cos√¨ per sempre? üêï‚ù§Ô∏è‚ú®"
        }
      ]
    };
  }

  /**
   * Ottimizza prompt in base ai token limit di Llama 3.1
   */
  optimizePromptLength(prompt) {
    // Llama 3.1 8B gestisce bene contesti fino a 2048 token
    // Stima approssimativa: 1 token ‚âà 4 caratteri in italiano
    const maxChars = 6000; // ~1500 token, lasciando spazio per la risposta
    
    if (prompt.length <= maxChars) return prompt;
    
    // Strategia di taglio intelligente
    const sections = prompt.split('\n\n');
    let optimized = sections[0]; // Mantieni sempre il system prompt
    
    // Aggiungi sezioni in ordine di priorit√†
    const priorityOrder = [
      /STATO ATTUALE DI UGO/,
      /PER QUESTA RISPOSTA/,
      /INFORMAZIONI SUL TUO UMANO/,
      /COME COMPORTARTI/,
      /MEMORIA CONVERSAZIONE/,
      /ESEMPI DEL TUO STILE/
    ];
    
    priorityOrder.forEach(pattern => {
      const section = sections.find(s => pattern.test(s));
      if (section && (optimized + '\n\n' + section).length < maxChars) {
        optimized += '\n\n' + section;
      }
    });
    
    return optimized;
  }
}

module.exports = UgoContextBuilder;

```

---

### üìÑ `../backend/src/services/ugoPersonality.js`

**üìè Dimensione:** 12.2 KB | **üìù Righe:** 373

```js
/**
 * UGO PERSONALITY ENGINE
 * 
 * Sistema di personalit√† dinamica per Ugo AI Companion
 * - Tratti caratteriali coerenti
 * - Evoluzione basata sulle interazioni
 * - Risposte filtrate per autenticit√†
 */
class UgoPersonality {
  constructor() {
    // Tratti base della personalit√† di Ugo
    this.baseTraits = {
      playfulness: 0.85,     // Quanto √® giocoso (0-1)
      curiosity: 0.90,       // Quanto √® curioso 
      loyalty: 0.95,         // Quanto √® fedele
      energy: 0.80,          // Livello di energia
      intelligence: 0.75,    // Intelligenza percepita
      protectiveness: 0.70,  // Istinto protettivo
      affection: 0.88,       // Quanto √® affettuoso
      independence: 0.30     // Quanto √® indipendente (basso = pi√π dipendente)
    };
    
    // Tratti attuali (si evolvono nel tempo)
    this.currentTraits = { ...this.baseTraits };
    
    // Mood temporaneo che influenza le risposte
    this.temporaryMood = {
      excitement: 0.7,
      focus: 0.6,
      relaxation: 0.5,
      alertness: 0.8
    };
    
    // Frasi caratteristiche per ogni trait
    this.traitExpressions = {
      playfulness: {
        high: ['*scodinzola eccitato*', 'Woof woof!', '*saltella felice*', '*corre in cerchio*'],
        medium: ['*muove la coda*', '*inclina la testa*', 'Arf!'],
        low: ['*si stiracchia*', '*sbadiglia*', '*si siede tranquillo*']
      },
      curiosity: {
        high: ['*annusa curioso*', '*inclina la testa interessato*', 'Ohh, cosa..?'],
        medium: ['*orienta le orecchie*', '*guarda attento*'],
        low: ['*sembra distratto*', '*guarda altrove*']
      },
      loyalty: {
        high: ['*si avvicina*', '*resta vicino*', 'Sono sempre qui per te!'],
        medium: ['*ti guarda affettuoso*', '*si siede accanto*'],
        low: ['*mantiene le distanze*', '*sembra indipendente*']
      },
      energy: {
        high: ['*salta*', '*corre*', '*gira su se stesso*', 'Non riesco a stare fermo!'],
        medium: ['*camminetta*', '*muove la coda*'],
        low: ['*si sdraia*', '*riposa*', '*chiude gli occhi*']
      }
    };
    
    // Evoluzione personalit√† basata su feedback
    this.evolutionHistory = [];
  }

  /**
   * Ottieni stato attuale della personalit√†
   */
  getCurrentState() {
    return {
      traits: { ...this.currentTraits },
      mood: { ...this.temporaryMood },
      dominantTrait: this.getDominantTrait(),
      personalityArchetype: this.getPersonalityArchetype()
    };
  }

  getCurrentTraits() {
    return { ...this.currentTraits };
  }

  getDominantTrait() {
    let maxTrait = 'playfulness';
    let maxValue = 0;
    
    for (const [trait, value] of Object.entries(this.currentTraits)) {
      if (value > maxValue) {
        maxValue = value;
        maxTrait = trait;
      }
    }
    
    return { trait: maxTrait, value: maxValue };
  }

  getPersonalityArchetype() {
    const { playfulness, curiosity, energy, loyalty } = this.currentTraits;
    
    if (playfulness > 0.8 && energy > 0.8) return 'playful-energetic';
    if (curiosity > 0.8 && intelligence > 0.7) return 'curious-intelligent';
    if (loyalty > 0.9 && affection > 0.8) return 'loyal-affectionate';
    if (protectiveness > 0.8) return 'protective-guardian';
    
    return 'balanced-companion';
  }

  /**
   * Filtra e migliora le risposte in base alla personalit√†
   */
  filterAndEnhanceResponse(response, currentMood) {
    let enhancedResponse = response;
    
    // 1. Aggiungi espressioni caratteristiche
    enhancedResponse = this.addPersonalityExpressions(enhancedResponse, currentMood);
    
    // 2. Adatta il tono
    enhancedResponse = this.adjustTone(enhancedResponse);
    
    // 3. Aggiungi coerenza comportamentale
    enhancedResponse = this.ensureBehavioralConsistency(enhancedResponse);
    
    // 4. Limita lunghezza mantenendo personalit√†
    enhancedResponse = this.optimizeLength(enhancedResponse);
    
    return enhancedResponse;
  }

  addPersonalityExpressions(response, mood) {
    const dominantTrait = this.getDominantTrait();
    const expressions = this.traitExpressions[dominantTrait.trait];
    
    if (!expressions) return response;
    
    // Scegli espressione basata su intensit√† del trait
    let level = 'medium';
    if (dominantTrait.value > 0.8) level = 'high';
    if (dominantTrait.value < 0.4) level = 'low';
    
    const expressionList = expressions[level];
    const randomExpression = expressionList[Math.floor(Math.random() * expressionList.length)];
    
    // Inserisci espressione in modo naturale
    if (Math.random() > 0.5) {
      return `${randomExpression} ${response}`;
    } else {
      return `${response} ${randomExpression}`;
    }
  }

  adjustTone(response) {
    // Adatta il tono basato sui tratti
    let adjusted = response;
    
    // Se molto giocoso, aggiungi pi√π entusiasmo
    if (this.currentTraits.playfulness > 0.8) {
      adjusted = adjusted.replace(/\./g, '!');
      adjusted = adjusted.replace(/(?<!!)$/, '!');
    }
    
    // Se molto affettuoso, rendi pi√π caldo
    if (this.currentTraits.affection > 0.8) {
      const affectionateWords = ['amico', 'tesoro', 'caro'];
      const randomWord = affectionateWords[Math.floor(Math.random() * affectionateWords.length)];
      if (!adjusted.toLowerCase().includes('amico') && !adjusted.toLowerCase().includes('tesoro')) {
        adjusted = adjusted.replace(/(\w+)!?$/, `$1, ${randomWord}!`);
      }
    }
    
    // Se molto curioso, aggiungi domande
    if (this.currentTraits.curiosity > 0.8 && !adjusted.includes('?')) {
      const questions = [' E tu?', ' Cosa ne pensi?', ' Dimmi di pi√π!', ' Ti piace?'];
      const randomQ = questions[Math.floor(Math.random() * questions.length)];
      adjusted += randomQ;
    }
    
    return adjusted;
  }

  ensureBehavioralConsistency(response) {
    // Assicura che la risposta sia coerente con i tratti di Ugo
    let consistent = response;
    
    // Rimuovi risposte troppo formali se Ugo √® giocoso
    if (this.currentTraits.playfulness > 0.7) {
      consistent = consistent.replace(/Certamente/g, 'Certo!');
      consistent = consistent.replace(/Naturalmente/g, 'Ovviamente!');
      consistent = consistent.replace(/Cordiali saluti/g, 'Woof woof!');
    }
    
    // Aggiungi riferimenti canini se appropriato
    if (Math.random() > 0.7) {
      const dogReferences = ['üêï', 'üêæ', 'ü¶¥', 'üéæ'];
      const randomRef = dogReferences[Math.floor(Math.random() * dogReferences.length)];
      if (!consistent.includes('üêï') && !consistent.includes('üêæ')) {
        consistent += ` ${randomRef}`;
      }
    }
    
    return consistent;
  }

  optimizeLength(response) {
    // Mantieni risposte tra 50-150 caratteri per autenticit√† canina
    if (response.length > 150) {
      // Taglia mantenendo senso compiuto
      const sentences = response.split('. ');
      let optimized = sentences[0];
      
      // Aggiungi frasi finch√© non superi il limite
      for (let i = 1; i < sentences.length; i++) {
        if ((optimized + '. ' + sentences[i]).length < 150) {
          optimized += '. ' + sentences[i];
        } else {
          break;
        }
      }
      
      // Assicura terminazione corretta
      if (!optimized.match(/[.!?]$/)) {
        optimized += '!';
      }
      
      return optimized;
    }
    
    return response;
  }

  /**
   * Evolve la personalit√† basandosi sul feedback
   */
  evolvePersonality(feedback, interactionType, userSentiment) {
    const evolution = {
      timestamp: new Date(),
      feedback,
      interactionType,
      userSentiment,
      beforeTraits: { ...this.currentTraits }
    };
    
    // Modifica tratti basandosi sul feedback
    if (feedback === 'positive') {
      // Rinforza tratti che hanno portato feedback positivi
      if (interactionType === 'playful') {
        this.currentTraits.playfulness = Math.min(1, this.currentTraits.playfulness + 0.05);
        this.currentTraits.energy = Math.min(1, this.currentTraits.energy + 0.03);
      }
      
      if (interactionType === 'affectionate') {
        this.currentTraits.affection = Math.min(1, this.currentTraits.affection + 0.05);
        this.currentTraits.loyalty = Math.min(1, this.currentTraits.loyalty + 0.03);
      }
      
      if (interactionType === 'curious') {
        this.currentTraits.curiosity = Math.min(1, this.currentTraits.curiosity + 0.04);
        this.currentTraits.intelligence = Math.min(1, this.currentTraits.intelligence + 0.02);
      }
    }
    
    if (feedback === 'negative') {
      // Riduci leggermente tratti che hanno causato feedback negativi
      if (interactionType === 'overly_energetic') {
        this.currentTraits.energy = Math.max(0.2, this.currentTraits.energy - 0.03);
        this.currentTraits.playfulness = Math.max(0.3, this.currentTraits.playfulness - 0.02);
      }
    }
    
    // Adatta al sentiment dell'utente
    if (userSentiment === 'sad') {
      this.currentTraits.affection = Math.min(1, this.currentTraits.affection + 0.02);
      this.currentTraits.protectiveness = Math.min(1, this.currentTraits.protectiveness + 0.03);
      this.currentTraits.energy = Math.max(0.3, this.currentTraits.energy - 0.02); // Pi√π calmo
    }
    
    if (userSentiment === 'excited') {
      this.currentTraits.playfulness = Math.min(1, this.currentTraits.playfulness + 0.03);
      this.currentTraits.energy = Math.min(1, this.currentTraits.energy + 0.04);
    }
    
    evolution.afterTraits = { ...this.currentTraits };
    this.evolutionHistory.push(evolution);
    
    // Mantieni solo ultimi 100 feedback per performance
    if (this.evolutionHistory.length > 100) {
      this.evolutionHistory = this.evolutionHistory.slice(-100);
    }
  }

  /**
   * Aggiorna mood temporaneo
   */
  updateTemporaryMood(context, userMessage) {
    // Il mood si resetta gradualmente verso valori neutri
    Object.keys(this.temporaryMood).forEach(mood => {
      this.temporaryMood[mood] = this.temporaryMood[mood] * 0.9 + 0.5 * 0.1;
    });
    
    // Adatta mood al contesto
    if (userMessage.includes('giocare') || userMessage.includes('palla')) {
      this.temporaryMood.excitement = Math.min(1, this.temporaryMood.excitement + 0.3);
      this.temporaryMood.focus = Math.min(1, this.temporaryMood.focus + 0.2);
    }
    
    if (userMessage.includes('stanco') || userMessage.includes('riposo')) {
      this.temporaryMood.relaxation = Math.min(1, this.temporaryMood.relaxation + 0.4);
      this.temporaryMood.energy = Math.max(0, this.temporaryMood.energy - 0.2);
    }
    
    // Considera durata conversazione
    if (context.length > 10) {
      this.temporaryMood.focus = Math.max(0.2, this.temporaryMood.focus - 0.1);
      this.temporaryMood.relaxation = Math.min(1, this.temporaryMood.relaxation + 0.1);
    }
  }

  /**
   * Reset personalit√† ai valori base
   */
  resetToBase() {
    this.currentTraits = { ...this.baseTraits };
    this.temporaryMood = {
      excitement: 0.7,
      focus: 0.6,
      relaxation: 0.5,
      alertness: 0.8
    };
    this.evolutionHistory = [];
  }

  /**
   * Ottieni statistiche evoluzione
   */
  getEvolutionStats() {
    if (this.evolutionHistory.length === 0) {
      return { totalEvolutions: 0, trends: {} };
    }
    
    const recent = this.evolutionHistory.slice(-20); // Ultimi 20 feedback
    const trends = {};
    
    Object.keys(this.baseTraits).forEach(trait => {
      const start = recent[0]?.beforeTraits[trait] || this.baseTraits[trait];
      const end = this.currentTraits[trait];
      trends[trait] = {
        change: end - start,
        direction: end > start ? 'increasing' : end < start ? 'decreasing' : 'stable'
      };
    });
    
    const positiveCount = recent.filter(e => e.feedback === 'positive').length;
    const negativeCount = recent.filter(e => e.feedback === 'negative').length;
    
    return {
      totalEvolutions: this.evolutionHistory.length,
      recentFeedback: { positive: positiveCount, negative: negativeCount },
      trends,
      dominantTraitHistory: recent.map(e => this.getDominantTraitFromTraits(e.afterTraits))
    };
  }

  getDominantTraitFromTraits(traits) {
    let maxTrait = 'playfulness';
    let maxValue = 0;
    
    for (const [trait, value] of Object.entries(traits)) {
      if (value > maxValue) {
        maxValue = value;
        maxTrait = trait;
      }
    }
    
    return maxTrait;
  }
}

module.exports = UgoPersonality;

```

---

### üìÑ `../backend/src/utils/logger.js`

**üìè Dimensione:** 2.5 KB | **üìù Righe:** 92

```js
const winston = require('winston');
const path = require('path');
const http = require('http');
const https = require('https');

// Create logs directory if it doesn't exist
const fs = require('fs');
const logsDir = path.join(__dirname, '../../logs');
if (!fs.existsSync(logsDir)) {
  fs.mkdirSync(logsDir, { recursive: true });
}

// Define log format
const logFormat = winston.format.combine(
  winston.format.timestamp({
    format: 'YYYY-MM-DD HH:mm:ss'
  }),
  winston.format.errors({ stack: true }),
  winston.format.json()
);

// Create the logger
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: logFormat,
  defaultMeta: {
    service: 'ugo-backend',
    version: process.env.npm_package_version || '1.0.0'
  },
  transports: [
    // Write all logs to combined.log
    new winston.transports.File({
      filename: path.join(logsDir, 'error.log'),
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    }),
    new winston.transports.File({
      filename: path.join(logsDir, 'combined.log'),
      maxsize: 5242880, // 5MB
      maxFiles: 10,
    }),
  ],
});

// Add console transport for development
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple(),
      winston.format.printf(({ timestamp, level, message, ...meta }) => {
        let metaStr = Object.keys(meta).length ? JSON.stringify(meta, null, 2) : '';
        return `${timestamp} [${level}]: ${message} ${metaStr}`;
      })
    )
  }));
}

// Optional HTTP transport
if (process.env.LOG_HTTP_ENDPOINT) {
  class HttpJsonTransport extends winston.Transport {
    log(info, callback) {
      const payload = JSON.stringify(info);
      try {
        const url = new URL(process.env.LOG_HTTP_ENDPOINT);
        const lib = url.protocol === 'https:' ? https : http;
        const req = lib.request({ method: 'POST', hostname: url.hostname, port: url.port || (url.protocol==='https:'?443:80), path: url.pathname, headers: { 'Content-Type': 'application/json' } }, res => {
          res.resume();
          callback();
        });
        req.on('error', () => callback());
        req.write(payload);
        req.end();
      } catch (e) {
        // swallow errors to avoid crashing logger
        callback();
      }
    }
  }
  logger.add(new HttpJsonTransport());
}

// Create a stream object for Morgan
logger.stream = {
  write: function(message) {
    logger.info(message.trim());
  }
};

module.exports = logger;

```

---

### üìÑ `../backend/src/validators/authValidators.js`

**üìè Dimensione:** 6.6 KB | **üìù Righe:** 250

```js
const Joi = require('joi');

// User registration validation
const registerSchema = Joi.object({
  email: Joi.string()
    .email()
    .required()
    .messages({
      'string.email': 'Please provide a valid email address',
      'any.required': 'Email is required'
    }),
  
  username: Joi.string()
    .alphanum()
    .min(3)
    .max(20)
    .required()
    .messages({
      'string.alphanum': 'Username can only contain letters and numbers',
      'string.min': 'Username must be at least 3 characters long',
      'string.max': 'Username cannot exceed 20 characters',
      'any.required': 'Username is required'
    }),
  
  password: Joi.string()
    .min(8)
    .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#\$%\^&\*])'))
    .required()
    .messages({
      'string.min': 'Password must be at least 8 characters long',
      'string.pattern.base': 'Password must contain at least one lowercase letter, one uppercase letter, one number, and one special character',
      'any.required': 'Password is required'
    }),
  
  confirmPassword: Joi.string()
    .valid(Joi.ref('password'))
    .required()
    .messages({
      'any.only': 'Passwords do not match',
      'any.required': 'Password confirmation is required'
    }),
  
  firstName: Joi.string()
    .min(2)
    .max(50)
    .required()
    .messages({
      'string.min': 'First name must be at least 2 characters long',
      'string.max': 'First name cannot exceed 50 characters',
      'any.required': 'First name is required'
    }),
  
  lastName: Joi.string()
    .min(2)
    .max(50)
    .required()
    .messages({
      'string.min': 'Last name must be at least 2 characters long',
      'string.max': 'Last name cannot exceed 50 characters',
      'any.required': 'Last name is required'
    }),
  
  dogName: Joi.string()
    .min(2)
    .max(30)
    .optional()
    .allow('')
    .messages({
      'string.min': 'Dog name must be at least 2 characters long',
      'string.max': 'Dog name cannot exceed 30 characters'
    }),
  
  dogBreed: Joi.string()
    .min(2)
    .max(50)
    .optional()
    .allow('')
    .messages({
      'string.min': 'Dog breed must be at least 2 characters long',
      'string.max': 'Dog breed cannot exceed 50 characters'
    }),
  
  acceptTerms: Joi.boolean()
    .valid(true)
    .required()
    .messages({
      'any.only': 'You must accept the terms and conditions',
      'any.required': 'You must accept the terms and conditions'
    })
});

// User login validation
const loginSchema = Joi.object({
  email: Joi.string()
    .email()
    .required()
    .messages({
      'string.email': 'Please provide a valid email address',
      'any.required': 'Email is required'
    }),
  
  password: Joi.string()
    .required()
    .messages({
      'any.required': 'Password is required'
    }),
  
  rememberMe: Joi.boolean()
    .optional()
});

// Password change validation
const changePasswordSchema = Joi.object({
  currentPassword: Joi.string()
    .required()
    .messages({
      'any.required': 'Current password is required'
    }),
  
  newPassword: Joi.string()
    .min(8)
    .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#\$%\^&\*])'))
    .required()
    .messages({
      'string.min': 'New password must be at least 8 characters long',
      'string.pattern.base': 'New password must contain at least one lowercase letter, one uppercase letter, one number, and one special character',
      'any.required': 'New password is required'
    }),
  
  confirmNewPassword: Joi.string()
    .valid(Joi.ref('newPassword'))
    .required()
    .messages({
      'any.only': 'Password confirmation does not match',
      'any.required': 'Password confirmation is required'
    })
});

// Password reset request validation
const forgotPasswordSchema = Joi.object({
  email: Joi.string()
    .email()
    .required()
    .messages({
      'string.email': 'Please provide a valid email address',
      'any.required': 'Email is required'
    })
});

// Password reset validation
const resetPasswordSchema = Joi.object({
  token: Joi.string()
    .required()
    .messages({
      'any.required': 'Reset token is required'
    }),
  
  password: Joi.string()
    .min(8)
    .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#\$%\^&\*])'))
    .required()
    .messages({
      'string.min': 'Password must be at least 8 characters long',  
      'string.pattern.base': 'Password must contain at least one lowercase letter, one uppercase letter, one number, and one special character',
      'any.required': 'Password is required'
    }),
  
  confirmPassword: Joi.string()
    .valid(Joi.ref('password'))
    .required()
    .messages({
      'any.only': 'Passwords do not match',
      'any.required': 'Password confirmation is required'
    })
});

// Email verification resend validation
const resendVerificationSchema = Joi.object({
  email: Joi.string()
    .email()
    .required()
    .messages({
      'string.email': 'Please provide a valid email address',
      'any.required': 'Email is required'
    })
});

// Refresh token validation
const refreshTokenSchema = Joi.object({
  refreshToken: Joi.string()
    .required()
    .messages({
      'any.required': 'Refresh token is required'
    })
});

// Validation middleware factory
const validateRequest = (schema) => {
  return (req, res, next) => {
    const { error, value } = schema.validate(req.body, {
      abortEarly: false,
      stripUnknown: true
    });

    if (error) {
      const errors = error.details.map(detail => ({
        field: detail.path.join('.'),
        message: detail.message
      }));

      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: errors
      });
    }

    // Replace req.body with sanitized data
    req.body = value;
    next();
  };
};

// Individual validation middleware
const validateRegister = validateRequest(registerSchema);
const validateLogin = validateRequest(loginSchema);
const validateChangePassword = validateRequest(changePasswordSchema);
const validateForgotPassword = validateRequest(forgotPasswordSchema);
const validateResetPassword = validateRequest(resetPasswordSchema);
const validateResendVerification = validateRequest(resendVerificationSchema);
const validateRefreshToken = validateRequest(refreshTokenSchema);

module.exports = {
  registerSchema,
  loginSchema,
  changePasswordSchema,
  forgotPasswordSchema,
  resetPasswordSchema,
  resendVerificationSchema,
  refreshTokenSchema,
  validateRegister,
  validateLogin,
  validateChangePassword,
  validateForgotPassword,
  validateResetPassword,
  validateResendVerification,
  validateRefreshToken,
  validateRequest
};

```

---

### üìÑ `../backend/src/validators/postValidators.js`

**üìè Dimensione:** 7.7 KB | **üìù Righe:** 350

```js
const Joi = require('joi');

// Create post validation
const createPostSchema = Joi.object({
  title: Joi.string()
    .min(5)
    .max(200)
    .required()
    .messages({
      'string.min': 'Title must be at least 5 characters long',
      'string.max': 'Title cannot exceed 200 characters',
      'any.required': 'Title is required'
    }),
  
  content: Joi.string()
    .min(50)
    .required()
    .messages({
      'string.min': 'Content must be at least 50 characters long',
      'any.required': 'Content is required'
    }),
  
  excerpt: Joi.string()
    .max(300)
    .optional()
    .allow('')
    .messages({
      'string.max': 'Excerpt cannot exceed 300 characters'
    }),
  
  coverImage: Joi.string()
    .uri()
    .optional()
    .allow('')
    .messages({
      'string.uri': 'Cover image must be a valid URL'
    }),
  
  published: Joi.boolean()
    .optional()
    .default(false),
  
  featured: Joi.boolean()
    .optional()
    .default(false),
  
  scheduledFor: Joi.date()
    .optional()
    .allow(null)
    .min('now')
    .messages({
      'date.min': 'Scheduled date must be in the future'
    }),
  
  tags: Joi.array()
    .items(Joi.string().max(30))
    .max(10)
    .optional()
    .messages({
      'array.max': 'Maximum 10 tags allowed',
      'string.max': 'Each tag cannot exceed 30 characters'
    }),
  
  categories: Joi.array()
    .items(Joi.string().max(50))
    .max(5)
    .optional()
    .messages({
      'array.max': 'Maximum 5 categories allowed',
      'string.max': 'Each category cannot exceed 50 characters'
    }),
  
  seoTitle: Joi.string()
    .max(60)
    .optional()
    .allow('')
    .messages({
      'string.max': 'SEO title cannot exceed 60 characters'
    }),
  
  seoDescription: Joi.string()
    .max(160)
    .optional()
    .allow('')
    .messages({
      'string.max': 'SEO description cannot exceed 160 characters'
    })
});

// Update post validation (all fields optional)
const updatePostSchema = Joi.object({
  title: Joi.string()
    .min(5)
    .max(200)
    .optional()
    .messages({
      'string.min': 'Title must be at least 5 characters long',
      'string.max': 'Title cannot exceed 200 characters'
    }),
  
  content: Joi.string()
    .min(50)
    .optional()
    .messages({
      'string.min': 'Content must be at least 50 characters long'
    }),
  
  excerpt: Joi.string()
    .max(300)
    .optional()
    .allow('')
    .messages({
      'string.max': 'Excerpt cannot exceed 300 characters'
    }),
  
  coverImage: Joi.string()
    .uri()
    .optional()
    .allow('')
    .messages({
      'string.uri': 'Cover image must be a valid URL'
    }),
  
  published: Joi.boolean()
    .optional(),
  
  featured: Joi.boolean()
    .optional(),
  
  scheduledFor: Joi.date()
    .optional()
    .allow(null)
    .messages({
      'date.base': 'Scheduled date must be a valid date'
    }),
  
  tags: Joi.array()
    .items(Joi.string().max(30))
    .max(10)
    .optional()
    .messages({
      'array.max': 'Maximum 10 tags allowed',
      'string.max': 'Each tag cannot exceed 30 characters'
    }),
  
  categories: Joi.array()
    .items(Joi.string().max(50))
    .max(5)
    .optional()
    .messages({
      'array.max': 'Maximum 5 categories allowed',
      'string.max': 'Each category cannot exceed 50 characters'
    }),
  
  seoTitle: Joi.string()
    .max(60)
    .optional()
    .allow('')
    .messages({
      'string.max': 'SEO title cannot exceed 60 characters'
    }),
  
  seoDescription: Joi.string()
    .max(160)
    .optional()
    .allow('')
    .messages({
      'string.max': 'SEO description cannot exceed 160 characters'
    })
});

// Share post validation
const sharePostSchema = Joi.object({
  platform: Joi.string()
    .valid('facebook', 'twitter', 'linkedin', 'whatsapp', 'telegram', 'email', 'copy')
    .optional()
    .messages({
      'any.only': 'Platform must be one of: facebook, twitter, linkedin, whatsapp, telegram, email, copy'
    })
});

// Query params validation for getting posts
const getPostsQuerySchema = Joi.object({
  page: Joi.number()
    .integer()
    .min(1)
    .optional()
    .default(1)
    .messages({
      'number.base': 'Page must be a number',
      'number.integer': 'Page must be an integer',
      'number.min': 'Page must be at least 1'
    }),
  
  limit: Joi.number()
    .integer()
    .min(1)
    .max(50)
    .optional()
    .default(10)
    .messages({
      'number.base': 'Limit must be a number',
      'number.integer': 'Limit must be an integer',
      'number.min': 'Limit must be at least 1',
      'number.max': 'Limit cannot exceed 50'
    }),
  
  published: Joi.string()
    .valid('true', 'false')
    .optional()
    .messages({
      'any.only': 'Published must be true or false'
    }),
  
  featured: Joi.string()
    .valid('true', 'false')
    .optional()
    .messages({
      'any.only': 'Featured must be true or false'
    }),
  
  author: Joi.string()
    .optional(),
  
  tag: Joi.string()
    .optional(),
  
  category: Joi.string()
    .optional(),
  
  search: Joi.string()
    .min(2)
    .max(100)
    .optional()
    .messages({
      'string.min': 'Search query must be at least 2 characters long',
      'string.max': 'Search query cannot exceed 100 characters'
    }),
  
  sortBy: Joi.string()
    .valid('publishedAt', 'createdAt', 'updatedAt', 'title', 'views')
    .optional()
    .default('publishedAt')
    .messages({
      'any.only': 'Sort by must be one of: publishedAt, createdAt, updatedAt, title, views'
    }),
  
  sortOrder: Joi.string()
    .valid('asc', 'desc')
    .optional()
    .default('desc')
    .messages({
      'any.only': 'Sort order must be asc or desc'
    })
});

// Validation middleware factory
const validateRequest = (schema, source = 'body') => {
  return (req, res, next) => {
    const data = source === 'query' ? req.query : req.body;
    
    const { error, value } = schema.validate(data, {
      abortEarly: false,
      stripUnknown: true,
      convert: true
    });

    if (error) {
      const errors = error.details.map(detail => ({
        field: detail.path.join('.'),
        message: detail.message
      }));

      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: errors
      });
    }

    // Replace the source with sanitized data
    if (source === 'query') {
      req.query = value;
    } else {
      req.body = value;
    }
    
    next();
  };
};

// Individual validation middleware
const validateCreatePost = validateRequest(createPostSchema);
const validateUpdatePost = validateRequest(updatePostSchema);
const validateSharePost = validateRequest(sharePostSchema);
const validateGetPostsQuery = validateRequest(getPostsQuerySchema, 'query');

// Slug validation middleware
const validateSlug = (req, res, next) => {
  const { slug } = req.params;
  
  if (!slug || slug.length < 1 || slug.length > 200) {
    return res.status(400).json({
      success: false,
      error: 'Invalid slug format'
    });
  }
  
  // Check if slug contains only valid characters
  const slugRegex = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;
  if (!slugRegex.test(slug)) {
    return res.status(400).json({
      success: false,
      error: 'Slug can only contain lowercase letters, numbers, and hyphens'
    });
  }
  
  next();
};

// ID validation middleware
const validateId = (req, res, next) => {
  const { id } = req.params;
  
  // Check if it's a valid CUID (Prisma default)
  const cuidRegex = /^c[a-z0-9]{24}$/;
  if (!cuidRegex.test(id)) {
    return res.status(400).json({
      success: false,
      error: 'Invalid post ID format'
    });
  }
  
  next();
};

module.exports = {
  createPostSchema,
  updatePostSchema,
  sharePostSchema,
  getPostsQuerySchema,
  validateCreatePost,
  validateUpdatePost,
  validateSharePost,
  validateGetPostsQuery,
  validateSlug,
  validateId,
  validateRequest
};

```

---

### üìÑ `../backend/supabase/init.sql`

**üìè Dimensione:** 2.5 KB | **üìù Righe:** 67

```sql
-- Supabase schema initialization for Il Mondo di Ugo
-- Newsletter subscribers table
create table if not exists public.newsletter_subscribers (
  id uuid primary key default gen_random_uuid(),
  email text not null unique,
  created_at timestamptz not null default now()
);

-- Contacts table
create table if not exists public.contacts (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  email text not null,
  message text not null,
  created_at timestamptz not null default now()
);

-- Uploads metadata table
create table if not exists public.uploads (
  id uuid primary key default gen_random_uuid(),
  path text not null unique,
  url text,
  filename text not null,
  content_type text,
  size bigint,
  created_at timestamptz not null default now()
);

-- Enable RLS
alter table public.newsletter_subscribers enable row level security;
alter table public.contacts enable row level security;
alter table public.uploads enable row level security;

-- Policies
-- Revoke broad access (docs note: Supabase by default grants to authenticated roles; ensure no PUBLIC grants)
-- Adjust policies for stricter RLS

-- Drop existing permissive policies if necessary (idempotent safe guards)
-- (Supabase SQL editor may require manual drop if names differ)

-- Newsletter subscribers: allow only insert for anon; no select/update/delete
create policy if not exists anon_insert_newsletter on public.newsletter_subscribers
  for insert to anon with check ( true );

-- Contacts: only insert
create policy if not exists anon_insert_contacts on public.contacts
  for insert to anon with check ( true );

-- Uploads: allow insert + (optional) select. Comment out select if you want private metadata.
create policy if not exists anon_insert_uploads on public.uploads
  for insert to anon with check ( true );
-- Public gallery listing (keep) ‚Äì remove if not desired
create policy if not exists anon_select_uploads on public.uploads
  for select to anon using ( true );

-- (Optional) future service role policies (service_role bypasses RLS automatically).

-- Harden: no update/delete policies defined = operations blocked for anon/auth.

-- Storage bucket creation note: create bucket 'uploads' manually or via dashboard.
-- Example (not executable in SQL editor): select storage.create_bucket('uploads', public => true);

-- Indexes
create index if not exists idx_newsletter_email on public.newsletter_subscribers (email);
create index if not exists idx_contacts_email on public.contacts (email);
create index if not exists idx_uploads_created_at on public.uploads (created_at);

```

---

### üìÑ `../backend/test_contact_curl.sh`

**üìè Dimensione:** 752 B | **üìù Righe:** 25

```sh
#!/bin/bash
PORT=${PORT_OVERRIDE:-3000}
URL="http://localhost:${PORT}/api/public/contact"
STAMP=$(date +%s)
cat <<EOF > /tmp/contact_payload.json
{
  "name": "Tester ${STAMP}",
  "email": "tester_${STAMP}@example.com",
  "message": "Messaggio di test ${STAMP}"
}
EOF

echo "Testing POST $URL"
HTTP_CODE=$(curl -s -o /tmp/contact_resp.json -w "%{http_code}" -X POST "$URL" \
  -H "Content-Type: application/json" \
  -d @/tmp/contact_payload.json)

echo "HTTP Code: $HTTP_CODE"
cat /tmp/contact_resp.json | jq . 2>/dev/null || cat /tmp/contact_resp.json
if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ] && grep -q '"success":true' /tmp/contact_resp.json; then
  echo "‚úÖ Contact Success"; exit 0
else
  echo "‚ùå Contact Failure" >&2; exit 1
fi

```

---

### üìÑ `../backend/test_newsletter_curl.sh`

**üìè Dimensione:** 638 B | **üìù Righe:** 20

```sh
#!/bin/bash
PORT=${PORT_OVERRIDE:-3000}
URL="http://localhost:${PORT}/api/public/newsletter"
EMAIL="test_$(date +%s)@example.com"
echo "Testing POST $URL with email=$EMAIL"
set -o pipefail
HTTP_CODE=$(curl -s -o /tmp/newsletter_resp.json -w "%{http_code}" -X POST "$URL" \
  -H "Content-Type: application/json" \
  -d "{\"email\":\"$EMAIL\"}")

echo "HTTP Code: $HTTP_CODE"
cat /tmp/newsletter_resp.json | jq . 2>/dev/null || cat /tmp/newsletter_resp.json

if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
  grep -q '"success":true' /tmp/newsletter_resp.json && echo "‚úÖ Success" && exit 0
fi

echo "‚ùå Failure" >&2
exit 1

```

---

### üìÑ `../backend/test_upload_curl.sh`

**üìè Dimensione:** 849 B | **üìù Righe:** 21

```sh
#!/bin/bash
PORT=${PORT_OVERRIDE:-3000}
URL="http://localhost:${PORT}/api/public/upload"
TMPFILE=$(mktemp /tmp/ugo_test_img_XXXXXX.png)
# Create a small dummy png file
printf '\211PNG\r\n\032\n' > "$TMPFILE"
# Add minimal IHDR + IEND (fake small file)
printf '\x00\x00\x00\rIHDR\x00\x00\x00\x01\x00\x00\x00\x01\x08\x02\x00\x00\x00\x90wS\xDE\x00\x00\x00\x00IEND\xAEB`\x82' >> "$TMPFILE"

HTTP_CODE=$(curl -s -o /tmp/upload_resp.json -w "%{http_code}" -X POST "$URL" \
  -F "file=@${TMPFILE};type=image/png")

echo "Testing POST $URL (file=$TMPFILE)" 
echo "HTTP Code: $HTTP_CODE"
cat /tmp/upload_resp.json | jq . 2>/dev/null || cat /tmp/upload_resp.json
if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ] && grep -q '"success":true' /tmp/upload_resp.json; then
  echo "‚úÖ Upload Success"; exit 0
else
  echo "‚ùå Upload Failure" >&2; exit 1
fi

```

---

### üìÑ `../backend/tests/publicRoutes.test.js`

**üìè Dimensione:** 1.1 KB | **üìù Righe:** 36

```js
const request = require('supertest');
const app = require('../src/app');

// Mock supabase client used by routes
jest.mock('../src/config/supabase', () => ({
  from: () => ({
    insert: () => ({ select: () => Promise.resolve({ data: [{}], error: null }) })
  }),
  storage: {
    from: () => ({
      upload: async () => ({ error: null }),
      getPublicUrl: () => ({ data: { publicUrl: 'https://example.com/file.png' } })
    })
  }
}));

describe('Public routes', () => {
  it('POST /api/public/newsletter should return 201', async () => {
    const res = await request(app)
      .post('/api/public/newsletter')
      .send({ email: 'test@example.com' })
      .set('Content-Type', 'application/json');
    expect([200,201]).toContain(res.statusCode);
    expect(res.body.success).toBe(true);
  });

  it('POST /api/public/contact should return 201', async () => {
    const res = await request(app)
      .post('/api/public/contact')
      .send({ name: 'Test User', email: 't@example.com', message: 'hello world' })
      .set('Content-Type', 'application/json');
    expect([200,201]).toContain(res.statusCode);
    expect(res.body.success).toBe(true);
  });
});

```

---

### üìÑ `../backend/wait-for-it.sh`

**üìè Dimensione:** 388 B | **üìù Righe:** 22

```sh
#!/usr/bin/env bash
# Minimal wait-for TCP script based on /dev/tcp
set -e

if [ -z "$1" ]; then
  echo "Usage: $0 host:port -- command"
  exit 2
fi

TARGET="$1"; shift

HOST="${TARGET%%:*}"
PORT="${TARGET##*:}"

echo "Waiting for $HOST:$PORT ..."
while ! (echo > /dev/tcp/$HOST/$PORT) >/dev/null 2>&1; do
  sleep 1
done

echo "$HOST:$PORT is available ‚Äî running command: $@"
exec "$@"

```

---

### üìÑ `../docs/.gitignore`

**üìè Dimensione:** 32 B | **üìù Righe:** 4

```text
node_modules/
.cache/
.DS_Store

```

---

### üìÑ `../docs/.nojekyll`

**üìè Dimensione:** 0 B | **üìù Righe:** 1

```text

```

---

### üìÑ `../docs/CNAME`

**üìè Dimensione:** 16 B | **üìù Righe:** 1

```text
lacucciadiugo.it
```

---

### üìÑ `../docs/SUPABASE-SETUP.md`

**üìè Dimensione:** 2.9 KB | **üìù Righe:** 94

```md
# Supabase setup (per il sito in `docs/`)

Segui questi passi per configurare Supabase e collegare il frontend.

## 1) Crea un progetto Supabase
- Vai su https://app.supabase.com e crea un nuovo progetto.
- Copia **URL** e **anon public key** (serve per il frontend).

## 2) Crea le tabelle (SQL)
Esegui questi comandi nella console SQL di Supabase:

````sql
-- Newsletter
create table if not exists public.newsletter_subscribers (
  id uuid default gen_random_uuid() primary key,
  email text not null unique,
  created_at timestamptz default now()
);

-- Contacts
create table if not exists public.contacts (
  id uuid default gen_random_uuid() primary key,
  name text,
  email text,
  message text,
  created_at timestamptz default now()
);

-- Uploads metadata
create table if not exists public.uploads (
  id uuid default gen_random_uuid() primary key,
  path text,
  url text,
  filename text,
  content_type text,
  size bigint,
  created_at timestamptz default now()
);
````

## 3) Storage bucket

* Vai in **Storage** ‚Üí **Create new bucket**
* Nome: `uploads`
* Public: `Public` (scegli "public" se vuoi che i file siano raggiungibili tramite URL pubblico; altrimenti lascia privato e crea policy per accedere)

## 4) RLS policies (consigliato)

Se abiliti RLS sulle tabelle, usa queste policy per permettere inserimenti tramite la API anon key:

````sql
-- Esempio per newsletter_subscribers
alter table public.newsletter_subscribers enable row level security;
create policy "Allow anon insert" on public.newsletter_subscribers
  for insert
  with check (auth.role() = 'anon');

-- Per contacts
alter table public.contacts enable row level security;
create policy "Allow anon insert" on public.contacts
  for insert
  with check (auth.role() = 'anon');

-- Per uploads metadata
alter table public.uploads enable row level security;
create policy "Allow anon insert" on public.uploads
  for insert
  with check (auth.role() = 'anon');
````

> Nota: le policy devono essere adattate alla tua sicurezza. L'uso dell'**anon key** espone la possibilit√† di inserire record pubblicamente. Per pi√π sicurezza crea endpoint server-side (es: backend Node) che usano la **service_role_key**.

## 5) Aggiungi le chiavi al frontend

Nella root `docs/js/supabase-client.js` sostituisci:

* `SUPABASE_URL` con il tuo URL
* `SUPABASE_ANON_KEY` con la `anon` key

## 6) Test locale

Apri `docs/index.html` con un server locale (es: `npx http-server docs` oppure VSCode Live Server) e prova:

* Iscrizione newsletter
* Invia messaggio contatto
* Caricamento file

---

### NOTE ALLE PATCH
- Ricorda di sostituire `SUPABASE_URL` e `SUPABASE_ANON_KEY` in `docs/js/supabase-client.js` con i tuoi valori.
- Se preferisci che io apra una PR direttamente (creo branch, aggiungo file e file di commit), dimmi e preparo i file per la PR.
- Posso anche generare versioni minimali dei file o integrare le chiamate verso il backend Node gi√† presente nel repo (consigliato per sicurezza), fammi sapere se preferisci server-side.

```

---

### üìÑ `../docs/check_index_links.py`

**üìè Dimensione:** 2.0 KB | **üìù Righe:** 60

```py
#!/usr/bin/env python3

import re

# Leggi il file index.html
with open('/home/fra/Bloghettino-ughettino/il-sito-di-ughettino/docs/index.html', 'r', encoding='utf-8') as f:
    content = f.read()

print("üîç Verifica link nell'index.html:")
print("="*50)

# Controlla link CSS che NON iniziano con .CSS/
css_links = re.findall(r'href="([^"]*\.css)"', content)
print("üìÑ Link CSS trovati:")
for link in css_links:
    status = "‚úÖ" if link.startswith('.CSS/') or link.startswith('http') else "‚ùå DA CORREGGERE"
    print(f"   {link} {status}")

# Controlla link JS che NON iniziano con .JS/
js_links = re.findall(r'src="([^"]*\.js)"', content)
print("\n‚ö° Link JS trovati:")
for link in js_links:
    status = "‚úÖ" if link.startswith('.JS/') or link.startswith('http') else "‚ùå DA CORREGGERE"
    print(f"   {link} {status}")

# Controlla link HTML che NON iniziano con .HTML/ (esclusi index.html e link esterni)
html_links = re.findall(r'href="([^"]*\.html)"', content)
print("\nüìÑ Link HTML trovati:")
for link in html_links:
    if link == 'index.html' or link.startswith('http'):
        status = "‚úÖ (file root o esterno)"
    elif link.startswith('.HTML/'):
        status = "‚úÖ"
    else:
        status = "‚ùå DA CORREGGERE"
    print(f"   {link} {status}")

print("\nüéØ Riepilogo:")
corrections_needed = []
for link in css_links:
    if not link.startswith('.CSS/') and not link.startswith('http'):
        corrections_needed.append(f"CSS: {link}")
        
for link in js_links:
    if not link.startswith('.JS/') and not link.startswith('http'):
        corrections_needed.append(f"JS: {link}")
        
for link in html_links:
    if (link != 'index.html' and 
        not link.startswith('http') and 
        not link.startswith('.HTML/')):
        corrections_needed.append(f"HTML: {link}")

if corrections_needed:
    print("‚ùå Correzioni necessarie:")
    for correction in corrections_needed:
        print(f"   - {correction}")
else:
    print("‚úÖ Tutti i link sono corretti!")

```

---

### üìÑ `../docs/fix_css_paths.py`

**üìè Dimensione:** 1.0 KB | **üìù Righe:** 32

```py
import os
import re

html_dir = "/home/fra/Bloghettino-ughettino/il-sito-di-ughettino/docs/.HTML"

# Pattern per trovare i link CSS con percorso errato
pattern = r'href="\.CSS/'
replacement = 'href="../.CSS/'

files_processed = 0

for filename in os.listdir(html_dir):
    if filename.endswith('.html') and filename != 'HTMLlettere.html':  # Escludo HTMLlettere.html
        filepath = os.path.join(html_dir, filename)
        
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Sostituisce solo se trova il pattern errato
        if re.search(pattern, content):
            new_content = re.sub(pattern, replacement, content)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(new_content)
            
            print(f"‚úÖ Corretto: {filename}")
            files_processed += 1
        else:
            print(f"‚è≠Ô∏è Nessuna modifica necessaria: {filename}")

print(f"\nüéâ Processati {files_processed} file HTML")

```

---

### üìÑ `../docs/fix_links_optimized.py`

**üìè Dimensione:** 5.0 KB | **üìù Righe:** 138

```py
import os
import re

def fix_all_links():
    """
    Script ottimizzato per aggiornare tutti i link nei file HTML
    basandosi sulla struttura reale delle cartelle
    """
    
    # Directory base
    docs_dir = os.getcwd()
    print(f"üìÇ Directory base: {docs_dir}")
    
    # Verifica le cartelle esistenti
    folders = {
        'css': '',
        'js': '', 
        'html': ''
    }
    
    for item in os.listdir(docs_dir):
        if os.path.isdir(os.path.join(docs_dir, item)):
            item_lower = item.lower()
            if 'css' in item_lower:
                folders['css'] = item
                print(f"üé® Cartella CSS trovata: {item}")
            elif 'js' in item_lower:
                folders['js'] = item
                print(f"‚ö° Cartella JS trovata: {item}")
            elif 'html' in item_lower:
                folders['html'] = item
                print(f"üìÑ Cartella HTML trovata: {item}")
    
    def update_single_file(file_path):
        """Aggiorna i link in un singolo file HTML"""
        print(f"\nüîß Processando: {os.path.basename(file_path)}")
        
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        changes = 0
        
        # 1. Aggiorna i CSS
        if folders['css']:
            def replace_css(match):
                nonlocal changes
                old_path = match.group(1)
                filename = os.path.basename(old_path)
                new_path = f"{folders['css']}/{filename}"
                print(f"   CSS: {old_path} ‚Üí {new_path}")
                changes += 1
                return f'href="{new_path}"'
            
            content = re.sub(r'href="([^"]*\.css)"', replace_css, content)
            content = re.sub(r"href='([^']*\.css)'", lambda m: f"href='{folders['css']}/{os.path.basename(m.group(1))}'" if folders['css'] else m.group(0), content)
        
        # 2. Aggiorna i JS
        if folders['js']:
            def replace_js(match):
                nonlocal changes
                old_path = match.group(1)
                filename = os.path.basename(old_path)
                new_path = f"{folders['js']}/{filename}"
                print(f"   JS: {old_path} ‚Üí {new_path}")
                changes += 1
                return f'src="{new_path}"'
            
            content = re.sub(r'src="([^"]*\.js)"', replace_js, content)
            content = re.sub(r"src='([^']*\.js)'", lambda m: f"src='{folders['js']}/{os.path.basename(m.group(1))}'" if folders['js'] else m.group(0), content)
        
        # 3. Aggiorna i link HTML (escludi http, #, mailto, index.html nella root)
        if folders['html']:
            def replace_html(match):
                nonlocal changes
                old_path = match.group(1)
                
                # Skip se √® gi√† nel formato corretto
                if folders['html'] and old_path.startswith(folders['html'] + '/'):
                    return match.group(0)
                
                # Skip index.html, link esterni, anchor
                if (old_path == 'index.html' or 
                    old_path.startswith('http') or 
                    old_path.startswith('#') or
                    old_path.startswith('mailto:')):
                    return match.group(0)
                
                filename = os.path.basename(old_path)
                new_path = f"{folders['html']}/{filename}"
                print(f"   HTML: {old_path} ‚Üí {new_path}")
                changes += 1
                return f'href="{new_path}"'
            
            content = re.sub(r'href="([^"]*\.html)"', replace_html, content)
        
        # Salva solo se ci sono state modifiche
        if changes > 0:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            print(f"‚úÖ {changes} modifiche salvate in {os.path.basename(file_path)}")
        else:
            print(f"‚ö™ Nessuna modifica necessaria per {os.path.basename(file_path)}")
    
    # Processa tutti i file HTML
    html_files = []
    
    # File HTML nella root
    for file in os.listdir(docs_dir):
        if file.endswith('.html') and os.path.isfile(os.path.join(docs_dir, file)):
            html_files.append(os.path.join(docs_dir, file))
    
    # File HTML nelle sottocartelle
    for root, _, files in os.walk(docs_dir):
        for file in files:
            if file.endswith('.html'):
                file_path = os.path.join(root, file)
                # Evita duplicati della root
                if file_path not in html_files:
                    html_files.append(file_path)
    
    print(f"\nüéØ Trovati {len(html_files)} file HTML da processare:")
    for file_path in html_files:
        print(f"   - {os.path.relpath(file_path, docs_dir)}")
    
    print("\n" + "="*50)
    print("üöÄ INIZIO ELABORAZIONE")
    print("="*50)
    
    for file_path in html_files:
        update_single_file(file_path)
    
    print("\n" + "="*50)
    print("üéâ ELABORAZIONE COMPLETATA!")
    print("="*50)

if __name__ == "__main__":
    fix_all_links()

```

---

### üìÑ `../docs/index.html`

**üìè Dimensione:** 16.4 KB | **üìù Righe:** 413

```html
<!DOCTYPE html>
<html lang="it">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>La Cuccia di Ugo ‚Äì Il cane pi√π buono del mondo</title>
  <meta name="description" content="Il blog di Ugo, il cane pi√π buono del mondo. Pensieri, avventure e tante leccatine. Un mondo dove ogni cane ha una cuccia e un umano che lo ama.">
  <link rel="stylesheet" href=".CSS/style.css">
  <link rel="stylesheet" href=".CSS/ugoAI.css">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#b97a56">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="Mondo Ugo">
  <link rel="apple-touch-icon" href="icons/icon-192x192.png">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "CreativeWork",
  "name": "La Cuccia di Ugo",
  "description": "Il blog di Ugo, il cane pi√π buono del mondo. Pensieri, avventure e tante leccatine.",
  "url": "https://lacucciadiugo.it",
  "creator": {
    "@type": "Person",
    "name": "Francesco"
  },
  "about": {
    "@type": "Animal",
    "name": "Ugo",
    "species": "Canis lupus familiaris",
    "breed": "Cuore d'oro"
  },
  "image": "https://fraarchi.github.io/il-sito-di-ughettino/assets/Ughettino.png",
  "audience": {
    "@type": "Audience",
    "audienceType": "Amanti dei cani, cuccioli in cerca di ispirazione, umani che hanno bisogno di un po' di bont√†"
  }
}
</script>
<!-- Favicon -->
<!-- Favicon -->
<link rel="icon" href="/assets/favico.png" type="image/png">
<link rel="shortcut icon" href="/assets/favico.png" type="image/png">

<!-- Icone multiple (opzionale, per dispositivi) -->
<link rel="apple-touch-icon" sizes="180x180" href="/assets/favico.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/favico.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/favico.png">

<link rel="icon" href="/path/to/favicon.ico" type="image/x-icon">
<!-- Favicon -->
<link rel="icon" href="/favicon-ugo.ico" type="image/x-icon">
<link rel="shortcut icon" href="/favicon-ugo.ico" type="image/x-icon">

<!-- Favicon in PNG (per dimensioni multiple) -->
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-ugo.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-ugo.png">

<!-- Apple Touch Icon (per iPhone, iPad) -->
<link rel="apple-touch-icon" href="/apple-touch-icon.png">

<!-- Web App Manifest (opzionale, per PWA) -->
<link rel="manifest" href="/site.webmanifest">

  <!-- Google tag (gtag.js) con Consent Mode -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-M7R4KXNLWL"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }

    // Default: tutto negato finch√© l'utente non decide
    gtag('js', new Date());
    gtag('consent', 'default', {
      'ad_storage': 'denied',
      'analytics_storage': 'denied'
    });

    // Config base: tracking con privacy se consenso mancante
    gtag('config', 'G-M7R4KXNLWL', {
      'anonymize_ip': true,
      'allow_ad_personalization_signals': false
    });
  </script>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebPage",
  "name": "Il Meraviglioso Mondo di Ugo",
  "url": "https://lacucciadiugo.it/index.html",
  "description": "Scopri le avventure, le foto e i pensieri filosofici di Ugo, un Cane speciale.",
  "mainEntity": {
    "@type": "Organization",
    "name": "La Cuccia di Ugo",
    "url": "https://lacucciadiugo.it",
    "logo": "https://fraarchi.github.io/il-sito-di-ughettino/assets/Ughettino.png"
  }
}
</script>


</head>



<body>
  <!-- Header fisso con navigazione -->
  <header class="header-sticky">
    <div class="header-content">
      <a href="index.html" class="logo">üêæ Ugo</a>
      
      <!-- Menu hamburger per mobile -->
      <div class="menu-toggle" id="menu-toggle">
        <span></span>
        <span></span>
        <span></span>
      </div>
      
      <nav>
        <ul id="nav-menu">
          <li><a href="index.html" class="active">Home</a></li>
          <li><a href=".HTML/dashboard.html">Dashboard</a></li>
          <li><a href=".HTML/ugo-stories.html">Storie</a></li>
          <li><a href=".HTML/giochi.html">Giochi</a></li>
          <li><a href=".HTML/foto.html">Galleria</a></li>
          <li><a href=".HTML/amici.html">Amici</a></li>
          <li><a href=".HTML/quiz.html">Quiz</a></li>
          <li><a href=".HTML/photobooth.html">Photo Booth</a></li>
          <li><a href=".HTML/faq.html">FAQ</a></li>
          <li><a href=".HTML/logo.html">Logo</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <main>
    <header class="ugo-header">
      <h1>Il meraviglioso mondo di Ugo üêæ</h1>
      <p>di Francesco Archidiacono - compagno di vita di Ugo</p>
    </header>

    <div class="ugo-bg">
      <div class="ugo-overlay">
        <h1>Chi √® Ugo?</h1>
        <p>Ugo √® un cane speciale. Non morde, non distrugge, non scava. Abbaia solo per salutare. Gli piace il sole, le carezze, e scrivere pensieri profondi dal divano. Il suo sogno? Un mondo dove ogni cane abbia una cuccia, un nome e un umano che lo ama.</p>
        <h2>Le giornate tipo di Ugo</h2>
        <p>Dal risveglio alle 7:00 con un grande sbadiglio... fino al tramonto con una lunga passeggiata. Ugo vive ogni momento con la gioia pura di chi sa apprezzare le piccole cose: una crocchetta, una carezza, un raggio di sole.</p>
      </div>
    </div>

   <article style="max-width: 600px; margin: 40px auto; text-align: center; padding: 20px; background: #fffaf0; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.05);">
  <h1 style="color: #d4a76a; font-size: 1.8em; margin-bottom: 12px;">üì¨ La Posta di Ugo</h1>
  <p style="color: #5c4b37; line-height: 1.7; font-style: italic;">
    Ugo non parla. Ma ascolta.  
    Con le orecchie basse, gli occhi socchiusi, la coda che scodinzola piano.  
    Se vuoi dirgli qualcosa ‚Äî una carezza in parole, un pensiero, un ringraziamento ‚Äî questa √® la sua casella.
  </p>
  <p style="margin: 20px 0;">
    <a href=".HTML/HTMLlettere.html" style="color: #8b5a2b; text-decoration: none; font-weight: bold; border-bottom: 2px solid #d4a76a; padding-bottom: 2px;">
      Scrivi una lettera a Ugo ‚Üí
    </a>
  </p>
  <p style="font-size: 0.9em; color: #777;">
    Le lettere pi√π belle appariranno qui, nella sua bacheca del cuore.
  </p>
</article>

    <article>
      <h1>Un messaggio da Ugo üêæ</h1>
      <p><em>"Cari amici umani e canini, oggi vi parlo di leccatine, di code che scodinzolano, e di come il mondo √® pi√π bello se lo guardi da terra, con gli occhi di un cane. Ricordatevi: ogni giorno √® un dono, ogni carezza √® un tesoro, e ogni biscotto... beh, quello √® pura felicit√†!"</em></p>
      <p style="text-align: right; font-style: italic;">‚Äì Con amore, Ugo üêï</p>
    </article>

    <article>
      <h1>Avventura nella via sopra casa con Ugo üå≥</h1>
      <p>Oggi Ugo √® andato nel bosco e ha scoperto il segreto della felicit√†: annusare tutto, correre libero e tornare sempre dal suo umano preferito...</p>
    </article>

    <article>
      <h1>I 5 motivi per cui Ugo √® un filosofo üß†</h1>
      <ul>
        <li>Medita fissando il vuoto</li>
        <li>Ignora il caos, ma mai un biscotto</li>
        <li>Ha la pazienza di un saggio</li>
        <li>...</li>
      </ul>
    </article>

    <hr>
    <section>
      <h1>La semantica secondo Ugo üêæ</h1>
      <p>‚ÄúSemantica? Grr... suona difficile, ma √® pi√π facile di quanto sembri!‚Äù ‚Äì Ugo</p>
      <h2>Cos'√® l'HTML semantico?</h2>
      <p>Usiamo tag come &lt;main&gt;, &lt;section&gt;, &lt;article&gt; per dare significato ai contenuti.</p>

      <figure>
        <picture>
          <source srcset="Ugo.webp" type="image/webp">
          <img src="Ugo.jpeg" alt="Ugo, il cane che ama l'HTML" width="300" height="400" class="ridotta" loading="lazy">
        </picture>
        <figcaption>Ugo riflette sul significato dei tag semantici</figcaption>
      </figure>

      <p>L'HTML semantico aiuta anche i lettori con disabilit√† visive...</p>
    </section>

  <div class="scuro" style="background-image: url('IMMAGINI DI UGOO/golden con sfondo nero.jpg'); background-size: cover; background-position: center; color: #fff; padding: 2em;">
      <div style="background: rgba(0,0,0,0.5); padding: 1em; border-radius: 10px;">
        <h1>Perch√© Ugo √® cos√¨ bello?</h1>
        <p>Ugo √® cos√¨ bello perch√© √® autentico, vero, puro.</p>
        <aside>
          <h2>Post correlati</h2>
          <h3>Fai una domanda a Ugo!</h3>
          <ul>
            <li><a href=".HTML/faq.html">FAQ</a></li> 
          </ul>
        </aside>
      </div>
    </div>

    <!-- Sezione Chi Sono -->
    <section id="chi-sono">
      <h2>Chi c'√® dietro al sito?</h2>
      <div class="chi-sono-content">
        <picture>
          <source srcset="ugo-bg.webp" type="image/webp">
          <img src="ugo-bg.jpg" alt="Francesco Archidiacono con Ugo" loading="lazy" class="chi-sono-img">
        </picture>
        <div>
          <h3>Francesco & Ugo: Una storia di amicizia</h3>
          <p>Ciao! Sono Francesco, un appassionato di tecnologia e da qualche anno, il compagno di avventure di Ugo. Questo sito √® nato per condividere la gioia che un cane come lui sa portare nella vita di tutti i giorni. Qui troverete le sue (e le nostre) storie, i suoi pensieri profondi e, spero, un po' di ispirazione.</p>
          <p>Il nostro obiettivo? Creare una piccola community di amanti dei cani e celebrare i nostri amici a quattro zampe.</p>
        </div>
      </div>
    </section>

    <!-- Newsletter CTA -->
    <section id="newsletter" class="cta-section">
      <h2>Le Avventure di Ugo, ogni settimana!</h2>
      <p>Iscriviti alla nostra newsletter per non perdere gli ultimi post, foto esclusive e consigli per il tuo cane.</p>
      <form id="newsletter-form">
        <input type="email" name="email" placeholder="La tua email migliore" required aria-label="Indirizzo email per la newsletter">
        <button type="submit">Iscrivimi!</button>
      </form>
      <p id="newsletter-feedback" class="feedback-message"></p>
    </section>

    <!-- Ugo Quiz CTA -->
    <section id="quiz-cta" class="cta-section">
      <h2>Quanto conosci Ugo?</h2>
      <p>Mettiti alla prova con il nostro quiz e scopri se sei un vero fan di Ugo!</p>
      <a href=".HTML/quiz.html" class="button-cta">Inizia il Quiz!</a>
    </section>

    <!-- Photo Booth CTA -->
    <section id="photobooth-cta" class="cta-section">
      <h2>Crea un capolavoro con il tuo cane!</h2>
      <p>Usa il nostro Photo Booth per aggiungere cornici e adesivi a tema Ugo alle foto del tuo amico a quattro zampe.</p>
      <a href=".HTML/photobooth.html" class="button-cta">Prova il Photo Booth!</a>
    </section>

    <!-- Sezione Commenti Disqus -->
    <section id="commenti">
      <h2>Dite la vostra!</h2>
      <div id="disqus_thread"></div>
    </section>

    <!-- Assets Section -->
    <section id="assets">
      <h2>Assets del sito</h2>
      <div class="assets-container">
         <article>
           <h3>Logo</h3>
           <figure>
             <img src="IMMAGINI DI UGOO/logo-ugo1.png" alt="Logo Ugo">
             <figcaption>Logo ufficiale di Ugo</figcaption>
           </figure>
         </article>
         <article>
           <h3>Favicon</h3>
           <p>Favicon in formato ICO e PNG:</p>
           <div>
             <img src="favicon-ugo.ico" alt="Favicon ICO" style="width:64px;height:64px;">
             <img src="favicon-ugo.png" alt="Favicon PNG" style="width:64px;height:64px;">
           </div>
         </article>
         <article>
           <h3>Apple Touch Icon</h3>
           <figure>
             <img src="apple-touch-icon.png" alt="Apple Touch Icon" style="width:120px;height:120px;">
             <figcaption>Apple touch icon per iOS</figcaption>
           </figure>
         </article>
         <article>
           <h3>Manifest</h3>
           <p>Il file <code>manifest.json</code> definisce le icone e le propriet√† per la PWA del sito.</p>
           <a href="manifest.json" target="_blank">Visualizza manifest.json</a>
         </article>
      </div>
    </section>
    <!-- Fine Assets Section -->

    <footer>
      <div class="footer-content">
        <div class="footer-links">
          <a href=".HTML/chi-siamo.html">Chi Siamo</a>
          <a href=".HTML/contatti.html">Contatti</a>
          <a href=".HTML/privacy.html">Privacy Policy</a>
        </div>
        <p>&copy; 2025 Il Meraviglioso Mondo di Ugo. Creato con ‚ù§Ô∏è da Francesco Archidiacono.</p>
        <p>Seguimi su Instagram: <a href="https://instagram.com/fra.archi" target="_blank" rel="noopener noreferrer">@fra.archi</a></p>
      </div>
    </footer>
  </main>

  <!-- üç™ Banner consenso -->
  <div id="cookie-banner" style="position:fixed;bottom:32px;left:50%;transform:translateX(-50%);background:#ffe4b2;color:#2d1c0f;padding:56px 80px 48px 80px;border-radius:32px;box-shadow:0 8px 48px #b97a5655;z-index:9999;display:none;font-family:'Segoe UI',Arial,sans-serif;font-size:2em;font-weight:700;letter-spacing:0.03em;min-width:520px;max-width:90vw;">
    <span style="font-size:1.2em;">üç™</span> Questo sito usa i cookie per migliorare la tua esperienza.<br>
    <button id="cookie-accept" style="background:#b97a56;color:#fff;border:none;border-radius:12px;padding:16px 32px;margin-top:18px;cursor:pointer;font-weight:bold;font-size:1.15em;box-shadow:0 2px 8px #b97a5633;">Accetta</button>
  </div>

  <script>
    function setCookie(name, value, days) {
      const expires = new Date(Date.now() + days * 864e5).toUTCString();
      document.cookie = name + "=" + encodeURIComponent(value) + "; expires=" + expires + "; path=/; SameSite=Lax; Secure";
    }

    function getCookie(name) {
      const value = "; " + document.cookie;
      const parts = value.split("; " + name + "=");
      if (parts.length === 2) return decodeURIComponent(parts.pop().split(";").shift());
    }

    // Mostra il banner solo se non c'√® il cookie
    if (!getCookie('cookie_consent')) {
      document.getElementById('cookie-banner').style.display = 'block';
    }

    document.getElementById('cookie-accept').onclick = function () {
      setCookie('cookie_consent', 'accepted', 365);
      document.getElementById('cookie-banner').style.display = 'none';

      // Aggiorna lo stato del consenso
      if (typeof gtag === 'function') {
        gtag('consent', 'update', {
          'ad_storage': 'granted',
          'analytics_storage': 'granted'
        });

        // Ora si pu√≤ eseguire il config
        gtag('config', 'G-M7R4KXNLWL');
      }
    };
  </script>
  <script src=".JS/cookie-demo.js"></script>
  <script src=".JS/notifications.js"></script>
  
  <!-- Menu hamburger script -->
  <script>
    document.getElementById('menu-toggle').addEventListener('click', function() {
      const navMenu = document.getElementById('nav-menu');
      const menuToggle = document.getElementById('menu-toggle');
      
      navMenu.classList.toggle('active');
      menuToggle.classList.toggle('active');
    });
    
    // Chiudi menu quando si clicca su un link
    document.querySelectorAll('nav a').forEach(link => {
      link.addEventListener('click', () => {
        document.getElementById('nav-menu').classList.remove('active');
        document.getElementById('menu-toggle').classList.remove('active');
      });
    });
  </script>

  <!-- Disqus Script -->
  <script>
    var disqus_config = function () {
      this.page.url = window.location.href;
      this.page.identifier = window.location.pathname;
    };
    (function() {
      var d = document, s = d.createElement('script');
      s.src = 'https://il-sito-di-ughettino.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  <!-- Newsletter Form Script -->
  <script>
    document.getElementById('newsletter-form').addEventListener('submit', function(e) {
      e.preventDefault();
      const feedback = document.getElementById('newsletter-feedback');
      feedback.textContent = 'Grazie per esserti iscritto!';
      feedback.style.color = 'green';
      setTimeout(() => {
        feedback.textContent = '';
      }, 3000);
      this.reset();
    });
  </script>
  ugo che dorme!
  
  <!-- Ugo AI Companion -->
  <script src=".JS/ugoAICompanion.js"></script>
</body>
</html>
.0,1
```

---

### üìÑ `../docs/manifest.json`

**üìè Dimensione:** 1.5 KB | **üìù Righe:** 71

```json
{
  "name": "La Cuccia Di Ugo",
  "short_name": "Cuccia Ugo",
  "description": "Scopri le avventure di Ugo attraverso storie interattive, quiz e molto altro!",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#f8f6f0",
  "theme_color": "#b97a56",
  "orientation": "portrait-primary",
  "icons": [
    {
      "src": "/favicon-ugo.ico",
      "sizes": "48x48",
      "type": "image/x-icon"
    },
    {
      "src": "/favicon-ugo.png",
      "sizes": "16x16",
      "type": "image/png"
    },
    {
      "src": "icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png"
    },
    {
      "src": "icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png"
    },
    {
      "src": "icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png"
    },
    {
      "src": "icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png"
    },
    {
      "src": "icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    },
    {
      "src": "icons/icon-1024x1536.png",
      "sizes": "1024x1536",
      "type": "image/png"
    },
    {
      "src": "/favicon-ugo.png",
      "sizes": "32x32",
      "type": "image/png"
    }
  ],
  "categories": ["entertainment", "lifestyle", "education"],
  "screenshots": [
    {
      "src": "screenshots/home.png",
      "sizes": "1280x720",
      "type": "image/png"
    }
  ]
}

```

---

### üìÑ `../docs/package.json`

**üìè Dimensione:** 469 B | **üìù Righe:** 19

```json
{
  "name": "ugo-frontend",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "build:css": "tailwindcss -i ./src/styles/main.css -o ./assets/tw.css --minify",
    "build:images": "node ./tools/convert-images.mjs",
    "build": "npm run build:css && npm run build:images"
  },
  "devDependencies": {
    "autoprefixer": "^10.4.20",
    "postcss": "^8.4.41",
    "sharp": "^0.33.5",
    "tailwindcss": "^3.4.10",
    "glob": "^11.0.0"
  }
}

```

---

### üìÑ `../docs/robots.txt`

**üìè Dimensione:** 70 B | **üìù Righe:** 5

```txt
User-agent: *
Allow: /

Sitemap: https://lacucciadiugo.it/sitemap.xml

```

---

### üìÑ `../docs/rss.xml`

**üìè Dimensione:** 5.3 KB | **üìù Righe:** 90

```xml
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Le Storie Interattive di Ugo</title>
    <description>Scopri le avventure quotidiane di Ugo, un Golden Retriever filosofo che ci insegna a vivere il presente attraverso storie autentiche e momenti di pura felicit√†.</description>
    <link>https://lacucciadiugo.it</link>
    <language>it-IT</language>
    <copyright>¬© 2025 Francesco Archidiacono - La Cuccia di Ugo</copyright>
    <managingEditor>info@lacucciadiugo.it (Francesco Archidiacono)</managingEditor>
    <webMaster>info@lacucciadiugo.it (Francesco Archidiacono)</webMaster>
    <lastBuildDate>Tue, 12 Aug 2025 10:00:00 +0200</lastBuildDate>
    <pubDate>Tue, 12 Aug 2025 10:00:00 +0200</pubDate>
    <generator>La Cuccia di Ugo RSS Generator</generator>
    <image>
      <url>https://lacucciadiugo.it/Ugo.jpeg</url>
      <title>Le Storie Interattive di Ugo</title>
      <link>https://lacucciadiugo.it</link>
      <width>144</width>
      <height>144</height>
    </image>
    <atom:link href="https://lacucciadiugo.it/rss.xml" rel="self" type="application/rss+xml" />

    <!-- Storia 1: Una passeggiata speciale -->
    <item>
      <title>Una Passeggiata Speciale nel Bosco di Autunno</title>
      <link>https://lacucciadiugo.it/ugo-stories.html#passeggiata-autunno</link>
      <description><![CDATA[Tra profumi di bosco e code che scodinzolano, Ugo ci accompagna in una passeggiata autunnale che diventa una lezione di vita. Piccole grandi felicit√† che scaldano il cuore.]]></description>
      <enclosure url="https://lacucciadiugo.it/ugo-bg.jpg" type="image/jpeg" length="245760" />
      <pubDate>Mon, 11 Aug 2025 09:30:00 +0200</pubDate>
      <guid isPermaLink="true">https://lacucciadiugo.it/ugo-stories.html#passeggiata-autunno</guid>
      <dc:creator>Francesco Archidiacono</dc:creator>
      <category>Avventure</category>
      <category>Natura</category>
    </item>

    <!-- Storia 2: Momenti di quiete -->
    <item>
      <title>Momenti di Quiete: La Filosofia di Ugo</title>
      <link>https://lacucciadiugo.it/ugo-stories.html#momenti-quiete</link>
      <description><![CDATA[Un raggio di sole, un prato morbido, un respiro profondo. Ugo ci insegna l'arte di fermarsi e apprezzare la bellezza dei momenti semplici, quelli che rendono la vita straordinaria.]]></description>
      <enclosure url="https://lacucciadiugo.it/ugo-curioso.jpeg" type="image/jpeg" length="198432" />
      <pubDate>Sun, 10 Aug 2025 16:45:00 +0200</pubDate>
      <guid isPermaLink="true">https://lacucciadiugo.it/ugo-stories.html#momenti-quiete</guid>
      <dc:creator>Francesco Archidiacono</dc:creator>
      <category>Filosofia</category>
      <category>Riflessioni</category>
    </item>

    <!-- Storia 3: Giochi e risate -->
    <item>
      <title>Giochi e Risate: L'Importanza del Divertimento</title>
      <link>https://lacucciadiugo.it/ugo-stories.html#giochi-risate</link>
      <description><![CDATA[Il divertimento √® pi√π bello se condiviso. Ugo ci ricorda che ridere e giocare non sono privilegi dell'infanzia, ma medicine per l'anima che non dovremmo mai smettere di prendere.]]></description>
      <enclosure url="https://lacucciadiugo.it/ugo-buffo.jpeg" type="image/jpeg" length="176256" />
      <pubDate>Sat, 09 Aug 2025 14:20:00 +0200</pubDate>
      <guid isPermaLink="true">https://lacucciadiugo.it/ugo-stories.html#giochi-risate</guid>
      <dc:creator>Francesco Archidiacono</dc:creator>
      <category>Divertimento</category>
      <category>Vita Quotidiana</category>
    </item>

    <!-- Storia 4: La curiosit√† di Ugo -->
    <item>
      <title>La Curiosit√† di Ugo: Esplorare con gli Occhi di un Bambino</title>
      <link>https://lacucciadiugo.it/ugo-stories.html#curiosita-esplorare</link>
      <description><![CDATA[Con il muso sempre pronto ad annusare nuovi profumi e gli occhi che brillano di meraviglia, Ugo ci insegna che la curiosit√† √® il motore della felicit√† e della scoperta continua.]]></description>
      <enclosure url="https://lacucciadiugo.it/ugo-occhi.jpeg" type="image/jpeg" length="203840" />
      <pubDate>Fri, 08 Aug 2025 11:15:00 +0200</pubDate>
      <guid isPermaLink="true">https://lacucciadiugo.it/ugo-stories.html#curiosita-esplorare</guid>
      <dc:creator>Francesco Archidiacono</dc:creator>
      <category>Curiosit√†</category>
      <category>Scoperte</category>
    </item>

    <!-- Storia 5: Un amico dal cuore grande -->
    <item>
      <title>Un Amico dal Cuore Grande: L'Amore Incondizionato</title>
      <link>https://lacucciadiugo.it/ugo-stories.html#cuore-grande</link>
      <description><![CDATA[Ugo ci dimostra ogni giorno cosa significa amare senza condizioni. La sua lealt√† e il suo affetto sincero sono un esempio di come dovrebbero essere tutti i rapporti autentici.]]></description>
      <enclosure url="https://lacucciadiugo.it/ugo-francesco.jpeg" type="image/jpeg" length="189632" />
      <pubDate>Thu, 07 Aug 2025 18:30:00 +0200</pubDate>
      <guid isPermaLink="true">https://lacucciadiugo.it/ugo-stories.html#cuore-grande</guid>
      <dc:creator>Francesco Archidiacono</dc:creator>
      <category>Amicizia</category>
      <category>Amore</category>
    </item>

  </channel>
</rss>

```

---

### üìÑ `../docs/sitemap.xml`

**üìè Dimensione:** 7.9 KB | **üìù Righe:** 266

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!-- 
  Sitemap ottimizzata per lacucciadiugo.it
  Focus SEO: "storie di cani blog", "avventure cane italiano", "community amanti cani"
  Target: 35 URL strategici per massimizzare ranking e crawling
-->
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">

  <!-- PRIORITY 1.0 - Homepage (Landing page principale) -->
  <url>
    <loc>https://lacucciadiugo.it/</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>daily</changefreq>
    <priority>1.0</priority>
  </url>

  <!-- PRIORITY 0.9 - Sezioni Storie e Contenuti Principali -->
  <url>
    <loc>https://lacucciadiugo.it/ugo-stories.html</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.9</priority>
  </url>

  <!-- PRIORITY 0.8 - Funzionalit√† Interattive e Community -->
  <url>
    <loc>https://lacucciadiugo.it/quiz.html</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.8</priority>
  </url>

  <url>
    <loc>https://lacucciadiugo.it/photobooth.html</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.8</priority>
  </url>

  <url>
    <loc>https://lacucciadiugo.it/ugo-ai.html</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.8</priority>
  </url>

  <!-- PRIORITY 0.7 - Utility e Servizi -->
  <url>
    <loc>https://lacucciadiugo.it/faq.html</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.7</priority>
  </url>

  <url>
    <loc>https://lacucciadiugo.it/rss.xml</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.7</priority>
  </url>

  <!-- PRIORITY 0.6 - Dashboard e Analytics (Contenuti Evergreen) -->
  <url>
    <loc>https://lacucciadiugo.it/dashboard.html</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.6</priority>
  </url>

  <url>
    <loc>https://lacucciadiugo.it/analytics.html</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.6</priority>
  </url>

  <!-- PRIORITY 0.5 - Contenuti Specifici e Nicchie -->
  <!-- Storie individuali per long-tail SEO -->
  <url>
    <loc>https://lacucciadiugo.it/ugo-stories.html#passeggiata-bosco-autunnale</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.5</priority>
  </url>

  <url>
    <loc>https://lacucciadiugo.it/ugo-stories.html#filosofia-canina-presente</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.5</priority>
  </url>

  <url>
    <loc>https://lacucciadiugo.it/ugo-stories.html#avventure-quotidiane-ugo</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.5</priority>
  </url>

  <url>
    <loc>https://lacucciadiugo.it/ugo-stories.html#curiosita-cane-esploratore</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.5</priority>
  </url>

  <url>
    <loc>https://lacucciadiugo.it/ugo-stories.html#amicizia-uomo-cane</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.5</priority>
  </url>

  <!-- Quiz specifici per engagement -->
  <url>
    <loc>https://lacucciadiugo.it/quiz.html#test-personalita-cane</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.5</priority>
  </url>

  <url>
    <loc>https://lacucciadiugo.it/quiz.html#quanto-conosci-ugo</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.5</priority>
  </url>

  <!-- PRIORITY 0.4 - Archivi e Categorie Secondarie -->
  <!-- Sezioni fotogallery per visual SEO -->
  <url>
    <loc>https://lacucciadiugo.it/photobooth.html#galleria-foto-ugo</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.4</priority>
  </url>

  <url>
    <loc>https://lacucciadiugo.it/photobooth.html#foto-community-cani</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.4</priority>
  </url>

  <!-- Contenuti stagionali -->
  <url>
    <loc>https://lacucciadiugo.it/ugo-stories.html#passeggiate-bosco-primavera</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>yearly</changefreq>
    <priority>0.4</priority>
  </url>

  <url>
    <loc>https://lacucciadiugo.it/ugo-stories.html#avventure-estate-2025</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>yearly</changefreq>
    <priority>0.4</priority>
  </url>

  <!-- Consigli evergreen per long-tail -->
  <url>
    <loc>https://lacucciadiugo.it/ugo-ai.html#consigli-vita-cane-felice</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.4</priority>
  </url>

  <url>
    <loc>https://lacucciadiugo.it/ugo-ai.html#lezioni-cane-filosofo</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.4</priority>
  </url>

  <!-- Community features -->
  <url>
    <loc>https://lacucciadiugo.it/faq.html#community-amanti-cani</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.4</priority>
  </url>

  <url>
    <loc>https://lacucciadiugo.it/faq.html#partecipa-storie-ugo</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.4</priority>
  </url>

  <!-- Geo-targeting (assumendo location italiana) -->
  <url>
    <loc>https://lacucciadiugo.it/ugo-stories.html#storie-cani-italia</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.4</priority>
  </url>

  <url>
    <loc>https://lacucciadiugo.it/ugo-stories.html#passeggiate-cani-natura</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.4</priority>
  </url>

  <!-- User-generated content placeholders -->
  <url>
    <loc>https://lacucciadiugo.it/photobooth.html#foto-utenti-community</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.4</priority>
  </url>

  <url>
    <loc>https://lacucciadiugo.it/ugo-stories.html#testimonianze-proprietari</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.4</priority>
  </url>

  <!-- Newsletter e engagement -->
  <url>
    <loc>https://lacucciadiugo.it/index.html#newsletter-storie-ugo</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.4</priority>
  </url>

  <!-- Archivi temporali per crawling depth -->
  <url>
    <loc>https://lacucciadiugo.it/ugo-stories.html#storie-agosto-2025</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.4</priority>
  </url>

  <url>
    <loc>https://lacucciadiugo.it/ugo-stories.html#storie-luglio-2025</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.4</priority>
  </url>

  <!-- PRIORITY 0.3 - Pagine Legali e Documenti -->
  <url>
    <loc>https://lacucciadiugo.it/privacy-policy.html</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>yearly</changefreq>
    <priority>0.3</priority>
  </url>

  <!-- Documenti di supporto -->
  <url>
    <loc>https://lacucciadiugo.it/faq.html#termini-uso</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>yearly</changefreq>
    <priority>0.3</priority>
  </url>

  <url>
    <loc>https://lacucciadiugo.it/faq.html#cookie-policy</loc>
    <lastmod>2025-08-13T08:32:55+00:00</lastmod>
    <changefreq>yearly</changefreq>
    <priority>0.3</priority>
  </url>

</urlset>
```

---

### üìÑ `../package-lock.json`

**üìè Dimensione:** 37.0 KB | **üìù Righe:** 1,006

```json
{
  "name": "il-sito-di-ughettino",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "dependencies": {
        "cssnano": "^7.1.0",
        "terser": "^5.43.1"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.12",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.12.tgz",
      "integrity": "sha512-OuLGC46TjB5BbN1dH8JULVVZY4WTdkF7tV9Ys6wLL1rubZnCMstOhNHueU5bLCrnRuDhKPDM4g6sw4Bel5Gzqg==",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.0",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/source-map": {
      "version": "0.3.10",
      "resolved": "https://registry.npmjs.org/@jridgewell/source-map/-/source-map-0.3.10.tgz",
      "integrity": "sha512-0pPkgz9dY+bijgistcTTJ5mR+ocqRXLuhXHYdzoMmmoJ2C9S46RCm2GMUbatPEUK9Yjy26IrAy8D/M00lLkv+Q==",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.25"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.4",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.4.tgz",
      "integrity": "sha512-VT2+G1VQs/9oz078bLrYbecdZKs912zQlkelYpuf+SXF+QvZDYJlbx/LSx+meSAwdDFnF8FVXW92AVjjkVmgFw=="
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.29",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.29.tgz",
      "integrity": "sha512-uw6guiW/gcAGPDhLmd77/6lW8QLeiV5RUTsAX46Db6oLhGaVj4lhnPwb184s1bkc8kdVg/+h988dro8GRDpmYQ==",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.1.0",
        "@jridgewell/sourcemap-codec": "^1.4.14"
      }
    },
    "node_modules/acorn": {
      "version": "8.15.0",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.15.0.tgz",
      "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/boolbase": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/boolbase/-/boolbase-1.0.0.tgz",
      "integrity": "sha512-JZOSA7Mo9sNGB8+UjSgzdLtokWAky1zbztM3WRLCbZ70/3cTANmQmOdR7y2g+J0e2WXywy1yS468tY+IruqEww=="
    },
    "node_modules/browserslist": {
      "version": "4.25.2",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.25.2.tgz",
      "integrity": "sha512-0si2SJK3ooGzIawRu61ZdPCO1IncZwS8IzuX73sPZsXW6EQ/w/DAfPyKI8l1ETTCr2MnvqWitmlCUxgdul45jA==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "dependencies": {
        "caniuse-lite": "^1.0.30001733",
        "electron-to-chromium": "^1.5.199",
        "node-releases": "^2.0.19",
        "update-browserslist-db": "^1.1.3"
      },
      "bin": {
        "browserslist": "cli.js"
      },
      "engines": {
        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
      }
    },
    "node_modules/buffer-from": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.2.tgz",
      "integrity": "sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ=="
    },
    "node_modules/caniuse-api": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/caniuse-api/-/caniuse-api-3.0.0.tgz",
      "integrity": "sha512-bsTwuIg/BZZK/vreVTYYbSWoe2F+71P7K5QGEX+pT250DZbfU1MQ5prOKpPR+LL6uWKK3KMwMCAS74QB3Um1uw==",
      "dependencies": {
        "browserslist": "^4.0.0",
        "caniuse-lite": "^1.0.0",
        "lodash.memoize": "^4.1.2",
        "lodash.uniq": "^4.5.0"
      }
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001733",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001733.tgz",
      "integrity": "sha512-e4QKw/O2Kavj2VQTKZWrwzkt3IxOmIlU6ajRb6LP64LHpBo1J67k2Hi4Vu/TgJWsNtynurfS0uK3MaUTCPfu5Q==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ]
    },
    "node_modules/colord": {
      "version": "2.9.3",
      "resolved": "https://registry.npmjs.org/colord/-/colord-2.9.3.tgz",
      "integrity": "sha512-jeC1axXpnb0/2nn/Y1LPuLdgXBLH7aDcHu4KEKfqw3CUhX7ZpfBSlPKyqXE6btIgEzfWtrX3/tyBCaCvXvMkOw=="
    },
    "node_modules/commander": {
      "version": "11.1.0",
      "resolved": "https://registry.npmjs.org/commander/-/commander-11.1.0.tgz",
      "integrity": "sha512-yPVavfyCcRhmorC7rWlkHn15b4wDVgVmBA7kV4QVBsF7kv/9TKJAbAXVTxvTnwP8HHKjRCJDClKbciiYS7p0DQ==",
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/css-declaration-sorter": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/css-declaration-sorter/-/css-declaration-sorter-7.2.0.tgz",
      "integrity": "sha512-h70rUM+3PNFuaBDTLe8wF/cdWu+dOZmb7pJt8Z2sedYbAcQVQV/tEchueg3GWxwqS0cxtbxmaHEdkNACqcvsow==",
      "engines": {
        "node": "^14 || ^16 || >=18"
      },
      "peerDependencies": {
        "postcss": "^8.0.9"
      }
    },
    "node_modules/css-select": {
      "version": "5.2.2",
      "resolved": "https://registry.npmjs.org/css-select/-/css-select-5.2.2.tgz",
      "integrity": "sha512-TizTzUddG/xYLA3NXodFM0fSbNizXjOKhqiQQwvhlspadZokn1KDy0NZFS0wuEubIYAV5/c1/lAr0TaaFXEXzw==",
      "dependencies": {
        "boolbase": "^1.0.0",
        "css-what": "^6.1.0",
        "domhandler": "^5.0.2",
        "domutils": "^3.0.1",
        "nth-check": "^2.0.1"
      },
      "funding": {
        "url": "https://github.com/sponsors/fb55"
      }
    },
    "node_modules/css-tree": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/css-tree/-/css-tree-3.1.0.tgz",
      "integrity": "sha512-0eW44TGN5SQXU1mWSkKwFstI/22X2bG1nYzZTYMAWjylYURhse752YgbE4Cx46AC+bAvI+/dYTPRk1LqSUnu6w==",
      "dependencies": {
        "mdn-data": "2.12.2",
        "source-map-js": "^1.0.1"
      },
      "engines": {
        "node": "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0"
      }
    },
    "node_modules/css-what": {
      "version": "6.2.2",
      "resolved": "https://registry.npmjs.org/css-what/-/css-what-6.2.2.tgz",
      "integrity": "sha512-u/O3vwbptzhMs3L1fQE82ZSLHQQfto5gyZzwteVIEyeaY5Fc7R4dapF/BvRoSYFeqfBk4m0V1Vafq5Pjv25wvA==",
      "engines": {
        "node": ">= 6"
      },
      "funding": {
        "url": "https://github.com/sponsors/fb55"
      }
    },
    "node_modules/cssesc": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/cssesc/-/cssesc-3.0.0.tgz",
      "integrity": "sha512-/Tb/JcjK111nNScGob5MNtsntNM1aCNUDipB/TkwZFhyDrrE47SOx/18wF2bbjgc3ZzCSKW1T5nt5EbFoAz/Vg==",
      "bin": {
        "cssesc": "bin/cssesc"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/cssnano": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/cssnano/-/cssnano-7.1.0.tgz",
      "integrity": "sha512-Pu3rlKkd0ZtlCUzBrKL1Z4YmhKppjC1H9jo7u1o4qaKqyhvixFgu5qLyNIAOjSTg9DjVPtUqdROq2EfpVMEe+w==",
      "dependencies": {
        "cssnano-preset-default": "^7.0.8",
        "lilconfig": "^3.1.3"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/cssnano"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/cssnano-preset-default": {
      "version": "7.0.8",
      "resolved": "https://registry.npmjs.org/cssnano-preset-default/-/cssnano-preset-default-7.0.8.tgz",
      "integrity": "sha512-d+3R2qwrUV3g4LEMOjnndognKirBZISylDZAF/TPeCWVjEwlXS2e4eN4ICkoobRe7pD3H6lltinKVyS1AJhdjQ==",
      "dependencies": {
        "browserslist": "^4.25.1",
        "css-declaration-sorter": "^7.2.0",
        "cssnano-utils": "^5.0.1",
        "postcss-calc": "^10.1.1",
        "postcss-colormin": "^7.0.4",
        "postcss-convert-values": "^7.0.6",
        "postcss-discard-comments": "^7.0.4",
        "postcss-discard-duplicates": "^7.0.2",
        "postcss-discard-empty": "^7.0.1",
        "postcss-discard-overridden": "^7.0.1",
        "postcss-merge-longhand": "^7.0.5",
        "postcss-merge-rules": "^7.0.6",
        "postcss-minify-font-values": "^7.0.1",
        "postcss-minify-gradients": "^7.0.1",
        "postcss-minify-params": "^7.0.4",
        "postcss-minify-selectors": "^7.0.5",
        "postcss-normalize-charset": "^7.0.1",
        "postcss-normalize-display-values": "^7.0.1",
        "postcss-normalize-positions": "^7.0.1",
        "postcss-normalize-repeat-style": "^7.0.1",
        "postcss-normalize-string": "^7.0.1",
        "postcss-normalize-timing-functions": "^7.0.1",
        "postcss-normalize-unicode": "^7.0.4",
        "postcss-normalize-url": "^7.0.1",
        "postcss-normalize-whitespace": "^7.0.1",
        "postcss-ordered-values": "^7.0.2",
        "postcss-reduce-initial": "^7.0.4",
        "postcss-reduce-transforms": "^7.0.1",
        "postcss-svgo": "^7.1.0",
        "postcss-unique-selectors": "^7.0.4"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/cssnano-utils": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/cssnano-utils/-/cssnano-utils-5.0.1.tgz",
      "integrity": "sha512-ZIP71eQgG9JwjVZsTPSqhc6GHgEr53uJ7tK5///VfyWj6Xp2DBmixWHqJgPno+PqATzn48pL42ww9x5SSGmhZg==",
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/csso": {
      "version": "5.0.5",
      "resolved": "https://registry.npmjs.org/csso/-/csso-5.0.5.tgz",
      "integrity": "sha512-0LrrStPOdJj+SPCCrGhzryycLjwcgUSHBtxNA8aIDxf0GLsRh1cKYhB00Gd1lDOS4yGH69+SNn13+TWbVHETFQ==",
      "dependencies": {
        "css-tree": "~2.2.0"
      },
      "engines": {
        "node": "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0",
        "npm": ">=7.0.0"
      }
    },
    "node_modules/csso/node_modules/css-tree": {
      "version": "2.2.1",
      "resolved": "https://registry.npmjs.org/css-tree/-/css-tree-2.2.1.tgz",
      "integrity": "sha512-OA0mILzGc1kCOCSJerOeqDxDQ4HOh+G8NbOJFOTgOCzpw7fCBubk0fEyxp8AgOL/jvLgYA/uV0cMbe43ElF1JA==",
      "dependencies": {
        "mdn-data": "2.0.28",
        "source-map-js": "^1.0.1"
      },
      "engines": {
        "node": "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0",
        "npm": ">=7.0.0"
      }
    },
    "node_modules/csso/node_modules/mdn-data": {
      "version": "2.0.28",
      "resolved": "https://registry.npmjs.org/mdn-data/-/mdn-data-2.0.28.tgz",
      "integrity": "sha512-aylIc7Z9y4yzHYAJNuESG3hfhC+0Ibp/MAMiaOZgNv4pmEdFyfZhhhny4MNiAfWdBQ1RQ2mfDWmM1x8SvGyp8g=="
    },
    "node_modules/dom-serializer": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/dom-serializer/-/dom-serializer-2.0.0.tgz",
      "integrity": "sha512-wIkAryiqt/nV5EQKqQpo3SToSOV9J0DnbJqwK7Wv/Trc92zIAYZ4FlMu+JPFW1DfGFt81ZTCGgDEabffXeLyJg==",
      "dependencies": {
        "domelementtype": "^2.3.0",
        "domhandler": "^5.0.2",
        "entities": "^4.2.0"
      },
      "funding": {
        "url": "https://github.com/cheeriojs/dom-serializer?sponsor=1"
      }
    },
    "node_modules/domelementtype": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/domelementtype/-/domelementtype-2.3.0.tgz",
      "integrity": "sha512-OLETBj6w0OsagBwdXnPdN0cnMfF9opN69co+7ZrbfPGrdpPVNBUj02spi6B1N7wChLQiPn4CSH/zJvXw56gmHw==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/fb55"
        }
      ]
    },
    "node_modules/domhandler": {
      "version": "5.0.3",
      "resolved": "https://registry.npmjs.org/domhandler/-/domhandler-5.0.3.tgz",
      "integrity": "sha512-cgwlv/1iFQiFnU96XXgROh8xTeetsnJiDsTc7TYCLFd9+/WNkIqPTxiM/8pSd8VIrhXGTf1Ny1q1hquVqDJB5w==",
      "dependencies": {
        "domelementtype": "^2.3.0"
      },
      "engines": {
        "node": ">= 4"
      },
      "funding": {
        "url": "https://github.com/fb55/domhandler?sponsor=1"
      }
    },
    "node_modules/domutils": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/domutils/-/domutils-3.2.2.tgz",
      "integrity": "sha512-6kZKyUajlDuqlHKVX1w7gyslj9MPIXzIFiz/rGu35uC1wMi+kMhQwGhl4lt9unC9Vb9INnY9Z3/ZA3+FhASLaw==",
      "dependencies": {
        "dom-serializer": "^2.0.0",
        "domelementtype": "^2.3.0",
        "domhandler": "^5.0.3"
      },
      "funding": {
        "url": "https://github.com/fb55/domutils?sponsor=1"
      }
    },
    "node_modules/electron-to-chromium": {
      "version": "1.5.199",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.199.tgz",
      "integrity": "sha512-3gl0S7zQd88kCAZRO/DnxtBKuhMO4h0EaQIN3YgZfV6+pW+5+bf2AdQeHNESCoaQqo/gjGVYEf2YM4O5HJQqpQ=="
    },
    "node_modules/entities": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/entities/-/entities-4.5.0.tgz",
      "integrity": "sha512-V0hjH4dGPh9Ao5p0MoRY6BVqtwCjhz6vI5LT8AJ55H+4g9/4vbHx1I54fS0XuclLhDHArPQCiMjDxjaL8fPxhw==",
      "engines": {
        "node": ">=0.12"
      },
      "funding": {
        "url": "https://github.com/fb55/entities?sponsor=1"
      }
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/lilconfig": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/lilconfig/-/lilconfig-3.1.3.tgz",
      "integrity": "sha512-/vlFKAoH5Cgt3Ie+JLhRbwOsCQePABiU3tJ1egGvyQ+33R/vcwM2Zl2QR/LzjsBeItPt3oSVXapn+m4nQDvpzw==",
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/antonk52"
      }
    },
    "node_modules/lodash.memoize": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/lodash.memoize/-/lodash.memoize-4.1.2.tgz",
      "integrity": "sha512-t7j+NzmgnQzTAYXcsHYLgimltOV1MXHtlOWf6GjL9Kj8GK5FInw5JotxvbOs+IvV1/Dzo04/fCGfLVs7aXb4Ag=="
    },
    "node_modules/lodash.uniq": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/lodash.uniq/-/lodash.uniq-4.5.0.tgz",
      "integrity": "sha512-xfBaXQd9ryd9dlSDvnvI0lvxfLJlYAZzXomUYzLKtUeOQvOP5piqAWuGtrhWeqaXK9hhoM/iyJc5AV+XfsX3HQ=="
    },
    "node_modules/mdn-data": {
      "version": "2.12.2",
      "resolved": "https://registry.npmjs.org/mdn-data/-/mdn-data-2.12.2.tgz",
      "integrity": "sha512-IEn+pegP1aManZuckezWCO+XZQDplx1366JoVhTpMpBB1sPey/SbveZQUosKiKiGYjg1wH4pMlNgXbCiYgihQA=="
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "peer": true,
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/node-releases": {
      "version": "2.0.19",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.19.tgz",
      "integrity": "sha512-xxOWJsBKtzAq7DY0J+DTzuz58K8e7sJbdgwkbMWQe8UYB6ekmsQ45q0M/tJDsGaZmbC+l7n57UV8Hl5tHxO9uw=="
    },
    "node_modules/nth-check": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/nth-check/-/nth-check-2.1.1.tgz",
      "integrity": "sha512-lqjrjmaOoAnWfMmBPL+XNnynZh2+swxiX3WUE0s4yEHI6m+AwrK2UZOimIRl3X/4QctVqS8AiZjFqyOGrMXb/w==",
      "dependencies": {
        "boolbase": "^1.0.0"
      },
      "funding": {
        "url": "https://github.com/fb55/nth-check?sponsor=1"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA=="
    },
    "node_modules/postcss": {
      "version": "8.5.6",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.6.tgz",
      "integrity": "sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "peer": true,
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/postcss-calc": {
      "version": "10.1.1",
      "resolved": "https://registry.npmjs.org/postcss-calc/-/postcss-calc-10.1.1.tgz",
      "integrity": "sha512-NYEsLHh8DgG/PRH2+G9BTuUdtf9ViS+vdoQ0YA5OQdGsfN4ztiwtDWNtBl9EKeqNMFnIu8IKZ0cLxEQ5r5KVMw==",
      "dependencies": {
        "postcss-selector-parser": "^7.0.0",
        "postcss-value-parser": "^4.2.0"
      },
      "engines": {
        "node": "^18.12 || ^20.9 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.38"
      }
    },
    "node_modules/postcss-colormin": {
      "version": "7.0.4",
      "resolved": "https://registry.npmjs.org/postcss-colormin/-/postcss-colormin-7.0.4.tgz",
      "integrity": "sha512-ziQuVzQZBROpKpfeDwmrG+Vvlr0YWmY/ZAk99XD+mGEBuEojoFekL41NCsdhyNUtZI7DPOoIWIR7vQQK9xwluw==",
      "dependencies": {
        "browserslist": "^4.25.1",
        "caniuse-api": "^3.0.0",
        "colord": "^2.9.3",
        "postcss-value-parser": "^4.2.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-convert-values": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/postcss-convert-values/-/postcss-convert-values-7.0.6.tgz",
      "integrity": "sha512-MD/eb39Mr60hvgrqpXsgbiqluawYg/8K4nKsqRsuDX9f+xN1j6awZCUv/5tLH8ak3vYp/EMXwdcnXvfZYiejCQ==",
      "dependencies": {
        "browserslist": "^4.25.1",
        "postcss-value-parser": "^4.2.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-discard-comments": {
      "version": "7.0.4",
      "resolved": "https://registry.npmjs.org/postcss-discard-comments/-/postcss-discard-comments-7.0.4.tgz",
      "integrity": "sha512-6tCUoql/ipWwKtVP/xYiFf1U9QgJ0PUvxN7pTcsQ8Ns3Fnwq1pU5D5s1MhT/XySeLq6GXNvn37U46Ded0TckWg==",
      "dependencies": {
        "postcss-selector-parser": "^7.1.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-discard-duplicates": {
      "version": "7.0.2",
      "resolved": "https://registry.npmjs.org/postcss-discard-duplicates/-/postcss-discard-duplicates-7.0.2.tgz",
      "integrity": "sha512-eTonaQvPZ/3i1ASDHOKkYwAybiM45zFIc7KXils4mQmHLqIswXD9XNOKEVxtTFnsmwYzF66u4LMgSr0abDlh5w==",
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-discard-empty": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/postcss-discard-empty/-/postcss-discard-empty-7.0.1.tgz",
      "integrity": "sha512-cFrJKZvcg/uxB6Ijr4l6qmn3pXQBna9zyrPC+sK0zjbkDUZew+6xDltSF7OeB7rAtzaaMVYSdbod+sZOCWnMOg==",
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-discard-overridden": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/postcss-discard-overridden/-/postcss-discard-overridden-7.0.1.tgz",
      "integrity": "sha512-7c3MMjjSZ/qYrx3uc1940GSOzN1Iqjtlqe8uoSg+qdVPYyRb0TILSqqmtlSFuE4mTDECwsm397Ya7iXGzfF7lg==",
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-merge-longhand": {
      "version": "7.0.5",
      "resolved": "https://registry.npmjs.org/postcss-merge-longhand/-/postcss-merge-longhand-7.0.5.tgz",
      "integrity": "sha512-Kpu5v4Ys6QI59FxmxtNB/iHUVDn9Y9sYw66D6+SZoIk4QTz1prC4aYkhIESu+ieG1iylod1f8MILMs1Em3mmIw==",
      "dependencies": {
        "postcss-value-parser": "^4.2.0",
        "stylehacks": "^7.0.5"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-merge-rules": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/postcss-merge-rules/-/postcss-merge-rules-7.0.6.tgz",
      "integrity": "sha512-2jIPT4Tzs8K87tvgCpSukRQ2jjd+hH6Bb8rEEOUDmmhOeTcqDg5fEFK8uKIu+Pvc3//sm3Uu6FRqfyv7YF7+BQ==",
      "dependencies": {
        "browserslist": "^4.25.1",
        "caniuse-api": "^3.0.0",
        "cssnano-utils": "^5.0.1",
        "postcss-selector-parser": "^7.1.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-minify-font-values": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/postcss-minify-font-values/-/postcss-minify-font-values-7.0.1.tgz",
      "integrity": "sha512-2m1uiuJeTplll+tq4ENOQSzB8LRnSUChBv7oSyFLsJRtUgAAJGP6LLz0/8lkinTgxrmJSPOEhgY1bMXOQ4ZXhQ==",
      "dependencies": {
        "postcss-value-parser": "^4.2.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-minify-gradients": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/postcss-minify-gradients/-/postcss-minify-gradients-7.0.1.tgz",
      "integrity": "sha512-X9JjaysZJwlqNkJbUDgOclyG3jZEpAMOfof6PUZjPnPrePnPG62pS17CjdM32uT1Uq1jFvNSff9l7kNbmMSL2A==",
      "dependencies": {
        "colord": "^2.9.3",
        "cssnano-utils": "^5.0.1",
        "postcss-value-parser": "^4.2.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-minify-params": {
      "version": "7.0.4",
      "resolved": "https://registry.npmjs.org/postcss-minify-params/-/postcss-minify-params-7.0.4.tgz",
      "integrity": "sha512-3OqqUddfH8c2e7M35W6zIwv7jssM/3miF9cbCSb1iJiWvtguQjlxZGIHK9JRmc8XAKmE2PFGtHSM7g/VcW97sw==",
      "dependencies": {
        "browserslist": "^4.25.1",
        "cssnano-utils": "^5.0.1",
        "postcss-value-parser": "^4.2.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-minify-selectors": {
      "version": "7.0.5",
      "resolved": "https://registry.npmjs.org/postcss-minify-selectors/-/postcss-minify-selectors-7.0.5.tgz",
      "integrity": "sha512-x2/IvofHcdIrAm9Q+p06ZD1h6FPcQ32WtCRVodJLDR+WMn8EVHI1kvLxZuGKz/9EY5nAmI6lIQIrpo4tBy5+ug==",
      "dependencies": {
        "cssesc": "^3.0.0",
        "postcss-selector-parser": "^7.1.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-normalize-charset": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/postcss-normalize-charset/-/postcss-normalize-charset-7.0.1.tgz",
      "integrity": "sha512-sn413ofhSQHlZFae//m9FTOfkmiZ+YQXsbosqOWRiVQncU2BA3daX3n0VF3cG6rGLSFVc5Di/yns0dFfh8NFgQ==",
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-normalize-display-values": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/postcss-normalize-display-values/-/postcss-normalize-display-values-7.0.1.tgz",
      "integrity": "sha512-E5nnB26XjSYz/mGITm6JgiDpAbVuAkzXwLzRZtts19jHDUBFxZ0BkXAehy0uimrOjYJbocby4FVswA/5noOxrQ==",
      "dependencies": {
        "postcss-value-parser": "^4.2.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-normalize-positions": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/postcss-normalize-positions/-/postcss-normalize-positions-7.0.1.tgz",
      "integrity": "sha512-pB/SzrIP2l50ZIYu+yQZyMNmnAcwyYb9R1fVWPRxm4zcUFCY2ign7rcntGFuMXDdd9L2pPNUgoODDk91PzRZuQ==",
      "dependencies": {
        "postcss-value-parser": "^4.2.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-normalize-repeat-style": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/postcss-normalize-repeat-style/-/postcss-normalize-repeat-style-7.0.1.tgz",
      "integrity": "sha512-NsSQJ8zj8TIDiF0ig44Byo3Jk9e4gNt9x2VIlJudnQQ5DhWAHJPF4Tr1ITwyHio2BUi/I6Iv0HRO7beHYOloYQ==",
      "dependencies": {
        "postcss-value-parser": "^4.2.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-normalize-string": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/postcss-normalize-string/-/postcss-normalize-string-7.0.1.tgz",
      "integrity": "sha512-QByrI7hAhsoze992kpbMlJSbZ8FuCEc1OT9EFbZ6HldXNpsdpZr+YXC5di3UEv0+jeZlHbZcoCADgb7a+lPmmQ==",
      "dependencies": {
        "postcss-value-parser": "^4.2.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-normalize-timing-functions": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/postcss-normalize-timing-functions/-/postcss-normalize-timing-functions-7.0.1.tgz",
      "integrity": "sha512-bHifyuuSNdKKsnNJ0s8fmfLMlvsQwYVxIoUBnowIVl2ZAdrkYQNGVB4RxjfpvkMjipqvbz0u7feBZybkl/6NJg==",
      "dependencies": {
        "postcss-value-parser": "^4.2.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-normalize-unicode": {
      "version": "7.0.4",
      "resolved": "https://registry.npmjs.org/postcss-normalize-unicode/-/postcss-normalize-unicode-7.0.4.tgz",
      "integrity": "sha512-LvIURTi1sQoZqj8mEIE8R15yvM+OhbR1avynMtI9bUzj5gGKR/gfZFd8O7VMj0QgJaIFzxDwxGl/ASMYAkqO8g==",
      "dependencies": {
        "browserslist": "^4.25.1",
        "postcss-value-parser": "^4.2.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-normalize-url": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/postcss-normalize-url/-/postcss-normalize-url-7.0.1.tgz",
      "integrity": "sha512-sUcD2cWtyK1AOL/82Fwy1aIVm/wwj5SdZkgZ3QiUzSzQQofrbq15jWJ3BA7Z+yVRwamCjJgZJN0I9IS7c6tgeQ==",
      "dependencies": {
        "postcss-value-parser": "^4.2.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-normalize-whitespace": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/postcss-normalize-whitespace/-/postcss-normalize-whitespace-7.0.1.tgz",
      "integrity": "sha512-vsbgFHMFQrJBJKrUFJNZ2pgBeBkC2IvvoHjz1to0/0Xk7sII24T0qFOiJzG6Fu3zJoq/0yI4rKWi7WhApW+EFA==",
      "dependencies": {
        "postcss-value-parser": "^4.2.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-ordered-values": {
      "version": "7.0.2",
      "resolved": "https://registry.npmjs.org/postcss-ordered-values/-/postcss-ordered-values-7.0.2.tgz",
      "integrity": "sha512-AMJjt1ECBffF7CEON/Y0rekRLS6KsePU6PRP08UqYW4UGFRnTXNrByUzYK1h8AC7UWTZdQ9O3Oq9kFIhm0SFEw==",
      "dependencies": {
        "cssnano-utils": "^5.0.1",
        "postcss-value-parser": "^4.2.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-reduce-initial": {
      "version": "7.0.4",
      "resolved": "https://registry.npmjs.org/postcss-reduce-initial/-/postcss-reduce-initial-7.0.4.tgz",
      "integrity": "sha512-rdIC9IlMBn7zJo6puim58Xd++0HdbvHeHaPgXsimMfG1ijC5A9ULvNLSE0rUKVJOvNMcwewW4Ga21ngyJjY/+Q==",
      "dependencies": {
        "browserslist": "^4.25.1",
        "caniuse-api": "^3.0.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-reduce-transforms": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/postcss-reduce-transforms/-/postcss-reduce-transforms-7.0.1.tgz",
      "integrity": "sha512-MhyEbfrm+Mlp/36hvZ9mT9DaO7dbncU0CvWI8V93LRkY6IYlu38OPg3FObnuKTUxJ4qA8HpurdQOo5CyqqO76g==",
      "dependencies": {
        "postcss-value-parser": "^4.2.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-selector-parser": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/postcss-selector-parser/-/postcss-selector-parser-7.1.0.tgz",
      "integrity": "sha512-8sLjZwK0R+JlxlYcTuVnyT2v+htpdrjDOKuMcOVdYjt52Lh8hWRYpxBPoKx/Zg+bcjc3wx6fmQevMmUztS/ccA==",
      "dependencies": {
        "cssesc": "^3.0.0",
        "util-deprecate": "^1.0.2"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/postcss-svgo": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/postcss-svgo/-/postcss-svgo-7.1.0.tgz",
      "integrity": "sha512-KnAlfmhtoLz6IuU3Sij2ycusNs4jPW+QoFE5kuuUOK8awR6tMxZQrs5Ey3BUz7nFCzT3eqyFgqkyrHiaU2xx3w==",
      "dependencies": {
        "postcss-value-parser": "^4.2.0",
        "svgo": "^4.0.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >= 18"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-unique-selectors": {
      "version": "7.0.4",
      "resolved": "https://registry.npmjs.org/postcss-unique-selectors/-/postcss-unique-selectors-7.0.4.tgz",
      "integrity": "sha512-pmlZjsmEAG7cHd7uK3ZiNSW6otSZ13RHuZ/4cDN/bVglS5EpF2r2oxY99SuOHa8m7AWoBCelTS3JPpzsIs8skQ==",
      "dependencies": {
        "postcss-selector-parser": "^7.1.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/postcss-value-parser": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-4.2.0.tgz",
      "integrity": "sha512-1NNCs6uurfkVbeXG4S8JFT9t19m45ICnif8zWLd5oPSZ50QnwMfK+H3jv408d4jw/7Bttv5axS5IiHoLaVNHeQ=="
    },
    "node_modules/sax": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/sax/-/sax-1.4.1.tgz",
      "integrity": "sha512-+aWOz7yVScEGoKNd4PA10LZ8sk0A/z5+nXQG5giUO5rprX9jgYsTdov9qCchZiPIZezbZH+jRut8nPodFAX4Jg=="
    },
    "node_modules/source-map": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
      "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/source-map-support": {
      "version": "0.5.21",
      "resolved": "https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.21.tgz",
      "integrity": "sha512-uBHU3L3czsIyYXKX88fdrGovxdSCoTGDRZ6SYXtSRxLZUzHg5P/66Ht6uoUlHu9EZod+inXhKo3qQgwXUT/y1w==",
      "dependencies": {
        "buffer-from": "^1.0.0",
        "source-map": "^0.6.0"
      }
    },
    "node_modules/stylehacks": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/stylehacks/-/stylehacks-7.0.6.tgz",
      "integrity": "sha512-iitguKivmsueOmTO0wmxURXBP8uqOO+zikLGZ7Mm9e/94R4w5T999Js2taS/KBOnQ/wdC3jN3vNSrkGDrlnqQg==",
      "dependencies": {
        "browserslist": "^4.25.1",
        "postcss-selector-parser": "^7.1.0"
      },
      "engines": {
        "node": "^18.12.0 || ^20.9.0 || >=22.0"
      },
      "peerDependencies": {
        "postcss": "^8.4.32"
      }
    },
    "node_modules/svgo": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/svgo/-/svgo-4.0.0.tgz",
      "integrity": "sha512-VvrHQ+9uniE+Mvx3+C9IEe/lWasXCU0nXMY2kZeLrHNICuRiC8uMPyM14UEaMOFA5mhyQqEkB02VoQ16n3DLaw==",
      "dependencies": {
        "commander": "^11.1.0",
        "css-select": "^5.1.0",
        "css-tree": "^3.0.1",
        "css-what": "^6.1.0",
        "csso": "^5.0.5",
        "picocolors": "^1.1.1",
        "sax": "^1.4.1"
      },
      "bin": {
        "svgo": "bin/svgo.js"
      },
      "engines": {
        "node": ">=16"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/svgo"
      }
    },
    "node_modules/terser": {
      "version": "5.43.1",
      "resolved": "https://registry.npmjs.org/terser/-/terser-5.43.1.tgz",
      "integrity": "sha512-+6erLbBm0+LROX2sPXlUYx/ux5PyE9K/a92Wrt6oA+WDAoFTdpHE5tCYCI5PNzq2y8df4rA+QgHLJuR4jNymsg==",
      "dependencies": {
        "@jridgewell/source-map": "^0.3.3",
        "acorn": "^8.14.0",
        "commander": "^2.20.0",
        "source-map-support": "~0.5.20"
      },
      "bin": {
        "terser": "bin/terser"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/terser/node_modules/commander": {
      "version": "2.20.3",
      "resolved": "https://registry.npmjs.org/commander/-/commander-2.20.3.tgz",
      "integrity": "sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ=="
    },
    "node_modules/update-browserslist-db": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.1.3.tgz",
      "integrity": "sha512-UxhIZQ+QInVdunkDAaiazvvT/+fXL5Osr0JZlJulepYu6Jd7qJtDZjlur0emRlT71EN3ScPoE7gvsuIKKNavKw==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "dependencies": {
        "escalade": "^3.2.0",
        "picocolors": "^1.1.1"
      },
      "bin": {
        "update-browserslist-db": "cli.js"
      },
      "peerDependencies": {
        "browserslist": ">= 4.21.0"
      }
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw=="
    }
  }
}

```

---

### üìÑ `../package.json`

**üìè Dimensione:** 77 B | **üìù Righe:** 7

```json
{
  "dependencies": {
    "cssnano": "^7.1.0",
    "terser": "^5.43.1"
  }
}

```

---

